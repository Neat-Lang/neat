module std.macro.quasiquoting;

import package(compiler).neat.base;
import package(compiler).neat.quasiquoting;
import package(compiler).neat.runtime;

class QuasiQuoterImpl : Quoter
{
    ASTSymbol compilerExpr;

    this(this.compiler, this.compilerExpr) { }

    override ASTSymbol compilerCall(string name, ASTSymbol[] parameters, LocRange locRange) {
        return compiler.astCall(
            compiler.astMember(compilerExpr, name, locRange), parameters ~ quoteLocRange(locRange), locRange);
    }

    override ASTSymbol quoteLocRange(LocRange locRange) {
        return compiler.astCall(
            compiler.astMember(compilerExpr, compiler.astIdentifier("makeLocRange", __RANGE__), __RANGE__), [
                compiler.astNumberLiteral(locRange.fileId, __RANGE__),
                compiler.astNumberLiteral(locRange.from.row, __RANGE__),
                compiler.astNumberLiteral(locRange.from.column, __RANGE__),
                compiler.astNumberLiteral(locRange.to.row, __RANGE__),
                compiler.astNumberLiteral(locRange.to.column, __RANGE__),
            ], __RANGE__);
    }
}

class QuasiQuoting : Macro
{
    this() { }
    override void apply(MacroArgs args) {
        if (auto args = args.instanceOf(ParsePropertyArgs)) {
            args.result = this.parse(args.parser, args.lexicalContext, args.left);
        }
    }

    (nullable ASTSymbol | fail Error) parse(Parser parser, LexicalContext lexicalContext, ASTSymbol compilerExpr) {
        auto compiler = lexicalContext.compiler;

        auto quoter = new QuasiQuoterImpl(compiler, compilerExpr);

        parser.pinned = true;
        parser.begin;
        // .$expr
        if (!parser.acceptToken(TokenType.dot) || !parser.acceptToken(TokenType.dollar)) {
            parser.revert;
            return null;
        }
        auto ident = parser.parseIdentifier;
        if (ident != "stmt" && ident != "expr" && ident != "type") {
            parser.revert;
            return null;
        }
        parser.commit;
        auto from = parser.from;
        auto remainingText = parser.remainingText;
        // deadbeef scopeId, because we should not be doing anything with these results!
        // If you see this value, somehow a parsed quote from this block leaked.
        // Remember, the point of parsing here is just to determine the text fragment to
        // be parsed at runtime.
        auto quoteLexicalContext = new QuoteLexicalContext(scopeId=0xdeadbeef, compiler, lexicalContext.pak);
        mut string methodName;
        if (ident == "stmt") {
            auto stmt = compiler.parseStatement(parser, quoteLexicalContext)?;
            parser.assert_(!!stmt, "statement expected")?;
            methodName = "astQuotedStatement";
        } else if (ident == "expr" ) {
            auto expr = compiler.parseExpression(parser, quoteLexicalContext)?;
            parser.assert_(!!expr, "expression expected")?;
            methodName = "astQuotedExpression";
        } else if (ident == "type") {
            auto type = compiler.parseType(parser, quoteLexicalContext)?;
            parser.assert_(!!type, "type expected")?;
            methodName = "astQuotedType";
        } else assert(false);
        auto locRange = parser.to(from);
        auto text = remainingText[0 .. $ - parser.remainingText.length];
        with (compiler) {
            // `compiler.$stmt { $stmt a; }`
            // compiles to `compiler.astQuotedStatement(id, "{ $stmt a; }", pak, [], [a], [], (LocRange at '{'))`
            return astCall(
                astMember(compilerExpr, astIdentifier(methodName, __RANGE__), __RANGE__),
                [
                    astStringLiteral(text, __RANGE__),
                    lexicalContext.pak.quote(quoter),
                    astArrayLiteral(quoteLexicalContext.macroSymbols, __RANGE__),
                    astArrayLiteral(quoteLexicalContext.macroStatements, __RANGE__),
                    astArrayLiteral(quoteLexicalContext.macroIdentifiers, __RANGE__),
                    quoter.quoteLocRange(locRange),
                ],
                locRange);
        }
    }
}

void addQuasiQuotingMacro(MacroState macroState)
{
    macroState.addMacro(new QuasiQuoting);
}

macro(addQuasiQuotingMacro);
