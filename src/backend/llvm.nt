module backend.llvm;

macro import package(compiler).std.macro.assert;
macro import package(compiler).std.macro.cimport;
macro import package(compiler).std.macro.listcomprehension;

import backend.base;
import package(compiler).std.string;
import package(compiler).std.thread;
import polyhash;

import c_header("llvm-c/Analysis.h");
import c_header("llvm-c/BitWriter.h");
import c_header("llvm-c/Core.h");
import c_header("llvm-c/DebugInfo.h");
import c_header("llvm-c/Target.h");
import c_header("llvm-c/TargetMachine.h");

pragma(lib, "LLVM");

LLVMTypeRef translate(BackendType type, LLVMContextRef context, bool allowVoid) {
    assert(!!type);
    if (type.instanceOf(BackendLongType)) return LLVMInt64TypeInContext(context);
    if (type.instanceOf(BackendIntType)) return LLVMInt32TypeInContext(context);
    if (type.instanceOf(BackendShortType)) return LLVMInt16TypeInContext(context);
    if (type.instanceOf(BackendCharType)) return LLVMInt8TypeInContext(context);
    if (type.instanceOf(BackendFloatType)) return LLVMFloatTypeInContext(context);
    if (type.instanceOf(BackendDoubleType)) return LLVMDoubleTypeInContext(context);
    if (type.instanceOf(BackendFlagType)) return LLVMInt1TypeInContext(context);
    if (type.size == 0) {
        if (allowVoid) return LLVMVoidTypeInContext(context);
        print("Empty type outside of return context");
        assert(false);
    }
    if (auto backendSpacerType = type.instanceOf(BackendSpacerType)) {
        if (backendSpacerType.(alignment == 8 && size % 8 == 0)) {
            return LLVMArrayType(LLVMInt64TypeInContext(context), backendSpacerType.size / 8);
        }
        if (backendSpacerType.(alignment == 4 && size % 4 == 0)) {
            return LLVMArrayType(LLVMInt32TypeInContext(context), backendSpacerType.size / 4);
        }
        if (backendSpacerType.(alignment == 2 && size % 2 == 0)) {
            return LLVMArrayType(LLVMInt16TypeInContext(context), backendSpacerType.size / 2);
        }
        if (backendSpacerType.alignment == 1) {
            return LLVMArrayType(LLVMInt8TypeInContext(context), backendSpacerType.size);
        }
        print("cannot compile spacer type to llvm: unknown size/alignment combo $backendSpacerType");
    }
    if (auto backendPointerType = type.instanceOf(BackendPointerType)) {
        if (backendPointerType.target.size == 0) {
            return LLVMPointerType(LLVMInt8TypeInContext(context), 0);
        }
        return LLVMPointerType(
            translate(backendPointerType.target, context, allowVoid=false),
            0);
    }
    if (auto backendStructType = type.instanceOf(BackendStructType)) {
        mut LLVMTypeRef[] types;
        for (member in backendStructType.members) {
            if (member.size > 0) {
                types ~= translate(member, context, false);
            }
        }
        return LLVMStructTypeInContext(context, types.ptr, cast(int) types.length, false);
    }
    if (auto backendFpType = type.instanceOf(BackendFunctionPointerType)) {
        return LLVMPointerType(translateFunc(backendFpType, context), 0);
    }
    if (auto backendSAtype = type.instanceOf(BackendStaticArrayType)) {
        return LLVMArrayType(
            translate(backendSAtype.element, context, false),
            cast(int) backendSAtype.length);
    }
    print(type.repr);
    assert(false);
}

nullable BackendType toAmd64ParamType(BackendType type) {
    if (type.instanceOf(BackendFlagType)) return type;
    if (type.size > 16) return null;
    mut auto sseFields = new int mut[](2), intFields = new int mut[](2), unkFields = new int mut[](2);
    mut auto fill = new int mut[](2);
    void walk(int offset, BackendType type) {
        if (type.size == 0) return;
        assert(offset < 16);
        fill[offset / 8] = (offset % 8) + type.size;
        if (type.instanceOf(BackendFloatType) || type.instanceOf(BackendDoubleType))
            sseFields[offset / 8] += 1;
        else if (type.instanceOf(BackendLongType) || type.instanceOf(BackendIntType)
            || type.instanceOf(BackendShortType) || type.instanceOf(BackendCharType))
            intFields[offset / 8] += 1;
        else if (auto struct_ = type.instanceOf(BackendStructType)) {
            for (int i, field in struct_.members) {
                if (field.size == 0) continue;
                walk(offset + struct_.memberOffset(i), field);
            }
        }
        else
            unkFields[offset / 8] += 1;
    }
    walk(0, type);
    mut BackendType[] blobs;
    for (i in 0 .. 2) {
        bool isSSE = sseFields[i] > 0, isInt = intFields[i] > 0, isUnk = unkFields[i] > 0;
        BackendType intFillType() {
            if (fill[i] > 4) return new BackendLongType;
            if (fill[i] > 2) return new BackendIntType;
            if (fill[i] > 1) return new BackendShortType;
            return new BackendCharType;
        }
        BackendType doubleFillType() {
            if (fill[i] > 4) return new BackendDoubleType;
            return new BackendFloatType;
        }
        if (isInt && !isUnk) blobs ~= intFillType;
        else if (isSSE && !isUnk) blobs ~= doubleFillType;
        else if (isUnk) return null;
    }
    // only zero-sized types
    if (blobs.length == 0) return null;
    if (blobs.length == 1) return blobs[0];
    return new BackendStructType(blobs);
}

unittest {
    // TODO literal
    mut BackendType[] inputArray;
    inputArray ~= new BackendFloatType; inputArray ~= new BackendIntType; inputArray ~= new BackendIntType;
    auto input = new BackendStructType(inputArray);
    auto output = toAmd64ParamType(input);

    mut BackendType[] expectedArray;
    expectedArray ~= new BackendLongType; expectedArray ~= new BackendIntType;
    assert(output.same(new BackendStructType(expectedArray)));
}

LLVMTypeRef translateFunc(BackendFunctionPointerType backendFpType, LLVMContextRef context) {
    bool sret = passByMemory(backendFpType.ret);
    mut LLVMTypeRef returnType;
    mut LLVMTypeRef[] paramTypes;

    if (sret) returnType = LLVMVoidTypeInContext(context);
    else returnType = translate(backendFpType.ret, context, true);
    if (!sret) {
        if (auto translatedType = toAmd64ParamType(backendFpType.ret)) {
            returnType = translate(translatedType, context, true);
        }
    }

    if (sret) {
        paramTypes ~= LLVMPointerType(
            translate(backendFpType.ret, context, true), 0);
    }
    for (param in backendFpType.params) {
        if (param.zeroSize) continue;
        if (auto translatedType = toAmd64ParamType(param)) {
            paramTypes ~= translate(translatedType, context, false);
            continue;
        }
        if (passByMemory(param)) {
            paramTypes ~= LLVMPointerType(
                translate(param, context, false), 0);
            continue;
        }
        paramTypes ~= translate(param, context, false);
    }
    return LLVMFunctionType(returnType, paramTypes.ptr, cast(int) paramTypes.length, backendFpType.variadic);
}

bool passByMemory(BackendType type) {
    // AMD64 ABI, rule 5c: aggregates over 16 bytes that are not SSE are passed in memory (byval).
    if (type.instanceOf(BackendStructType) && type.size > 16)
        return true;
    return false;
}

bool zeroSize(BackendType type) {
    if (type.instanceOf(BackendFlagType)) return false;
    return type.size == 0;
}

class LLVMBackend : Backend {
    this() {
        LLVMInitializeX86TargetInfo;
        LLVMInitializeX86Target;
        LLVMInitializeX86TargetMC;
        LLVMInitializeX86AsmParser;
        LLVMInitializeX86AsmPrinter;
    }
    override LLVMBackendModule createModule(
        Platform platform, string targetFile, BackendLocation loc, bool forMacro)
    {
        return new LLVMBackendModule(platform, targetFile, loc, forMacro);
    }
    override void hash(Hash hash) {
        hash.adds("LLVM");
    }
    override void linkSharedLib(string soname, string flags, bool verbose, string[] objFiles) {
        string objStr = [join " " ~ a for a in objFiles];
        string basecmd = "clang-15 -opaque-pointers -Wno-unused-command-line-argument -fpic $flags";
        string cmd = "$basecmd -shared $objStr -o $soname";
        if (verbose) {
            print("\$ $cmd");
        }
        neat_runtime_system(cmd);
    }
}

extern(C) void neat_runtime_system(string command);

struct DeclarationEntry
{
    string name;
    bool function_;
    BackendType type;
}

void defineIntrinsics(LLVMBackendModule mod, Platform platform) {
    BackendType voidp = platform.voidp;
    BackendType void_ = new BackendVoidType;
    BackendType sizet = platform.nativeWordType;
    BackendType flag = new BackendFlagType;
    {
        auto argTypes = [voidp, voidp, sizet];
        mod.declare("memcpy", voidp, argTypes, variadic=false);
    }
    {
        auto argTypes = [voidp, voidp, sizet, flag];
        mod.declare("llvm.memcpy.inline.p0i8.p0i8.i64", void_, argTypes, variadic=false);
    }
    mod.declare("neat_runtime_alloc", voidp, [sizet], variadic=false);
    mod.declare("neat_runtime_refcount_set", void_, [voidp, sizet], variadic=false);
}

// i1
class BackendFlagType : BackendType {
    this() { }
    override string repr() { return "<i1>"; }
    override bool same(BackendType other) { return !!other.instanceOf(BackendFlagType); }
}

class LLVMBackendModule : BackendModule {
    Platform platform;

    int literalId;
    BackendType[string] globals;

    bool forMacro;

    LLVMContextRef context;
    LLVMTargetMachineRef machine;

    LLVMModuleRef module_;

    LLVMDIBuilderRef dibuilder;
    LLVMMetadataRef dicu;

    string targetFile;

    LLVMValueRef llMemcpy;
    LLVMTypeRef llMemcpyType;

    this(this.platform, this.targetFile, BackendLocation loc, this.forMacro) {
        this.context = LLVMContextCreate;

        auto comps = split(loc.file, "/");
        auto dir = join(comps[0 .. $ - 1], "/");
        auto filename = comps[$ - 1];

        this.module_ = LLVMModuleCreateWithNameInContext(filename.toStringz, context);
        this.dibuilder = LLVMCreateDIBuilder(this.module_);

        char* triple = "x86_64-pc-linux-gnu";
        mut char* error;
        mut LLVMTargetRef target;
        bool succ = LLVMGetTargetFromTriple(triple, &target, &error) == 0;
        assert(succ);
        this.machine = LLVMCreateTargetMachine(
            target, triple, "generic", LLVMGetHostCPUFeatures, LLVMCodeGenLevelNone, LLVMRelocPIC, LLVMCodeModelDefault);
        auto datalayout = LLVMCreateTargetDataLayout(machine);
        auto datalayoutStr = LLVMCopyStringRepOfTargetData(datalayout);

        LLVMSetTarget(this.module_, "x86_64-pc-linux-gnu");
        LLVMSetDataLayout(this.module_, datalayoutStr);

        auto verStr = "Debug Info Version";
        LLVMAddModuleFlag(
            this.module_, LLVMModuleFlagBehaviorWarning,
            verStr.ptr, verStr.length,
            LLVMValueAsMetadata(LLVMConstInt(LLVMInt32TypeInContext(this.context), 3, SignExtend=false)));
        auto dwarfStr = "Dwarf Version";
        LLVMAddModuleFlag(
            this.module_, LLVMModuleFlagBehaviorWarning,
            dwarfStr.ptr, dwarfStr.length,
            LLVMValueAsMetadata(LLVMConstInt(LLVMInt32TypeInContext(this.context), 2, SignExtend=false)));
        auto picLevel = "PIC Level";
        LLVMAddModuleFlag(
            this.module_, LLVMModuleFlagBehaviorWarning,
            picLevel.ptr, picLevel.length,
            LLVMValueAsMetadata(LLVMConstInt(LLVMInt32TypeInContext(this.context), 1, SignExtend=false)));

        auto file = LLVMDIBuilderCreateFile(
            dibuilder,
            filename.ptr, filename.length,
            dir.ptr, dir.length);
        this.dicu = LLVMDIBuilderCreateCompileUnit(
            dibuilder,
            LLVMDWARFSourceLanguageC,
            file, "neat".ptr, 4,
            false, null, 0,
            0, null, 0,
            LLVMDWARFEmissionFull, 0, false,
            false, null, 0, null, 0);

        defineIntrinsics(this, platform);
    }

    void writeOutput() {
        import package(compiler).std.string : cToString, endsWith;

        if (this.platform.platformFlags.verbose) {
            LLVMPrintModuleToFile(this.module_, (this.targetFile ~ ".ll").toStringz, null);
        }
        if (this.targetFile.endsWith(".bc")) {
            LLVMWriteBitcodeToFile(this.module_, this.targetFile.toStringz);
            LLVMContextDispose(this.context);
            return;
        }
        mut char* error;
        if (this.platform.platformFlags.verbose) {
            bool verifySucc = !LLVMVerifyModule(this.module_, LLVMReturnStatusAction, &error);
            if (!verifySucc) {
                print("verification failed in $(this.targetFile).ll: $(cToString(error))");
                assert(false);
            }
        }
        bool succ = LLVMTargetMachineEmitToFile(
            this.machine, this.module_, this.targetFile.toStringz, LLVMObjectFile, &error) == 0;
        if (!succ) {
            print("compilation failed: $(cToString(error))");
            assert(false);
        }
        LLVMContextDispose(this.context);
    }

    LLVMTypeRef translate(BackendType type, bool allowVoid) {
        return .translate(type, this.context, allowVoid=allowVoid);
    }

    override bool declared(string name) { return this.globals.has(name); }

    override void declare(string name, BackendType ret, BackendType[] params, bool variadic)
    {
        assert(!this.declared(name));
        auto type = new BackendFunctionPointerType(ret, params, variadic, this.platform);
        auto llFunctionType = translateFunc(type, this.context);
        auto llFunction = LLVMAddFunction(module_, name.toStringz, llFunctionType);
        llSetCoerceAttribs(llFunction, ret, params);
        this.globals[name] = type;
        if (name == "llvm.memcpy.inline.p0i8.p0i8.i64") {
            this.llMemcpy = LLVMGetNamedFunction(this.module_, name.toStringz);
            this.llMemcpyType = llFunctionType;
        }
    }

    void llSetCoerceAttribs(LLVMValueRef llFun, BackendType ret, BackendType[] params) {
        bool sret = passByMemory(ret);
        if (sret) {
            auto sretAttrKind = LLVMGetEnumAttributeKindForName("sret", 4);
            assert(sretAttrKind != 0);
            auto sretTypeAttr = LLVMCreateTypeAttribute(
                this.context, sretAttrKind, translate(ret, true));
            // first attribute is sret
            LLVMAddAttributeAtIndex(llFun, 1, sretTypeAttr);
        }
        for (i, param in params) {
            if (passByMemory(param)) {
                auto byvalAttrKind = LLVMGetEnumAttributeKindForName("byval", 5);
                assert(byvalAttrKind != 0);
                auto byvalTypeAttr = LLVMCreateTypeAttribute(
                    this.context, byvalAttrKind, translate(param, false));
                // base-1 (0 is return type), + 1 for sret parameter
                int base = 1 + sret;
                LLVMAddAttributeAtIndex(llFun, base + cast(int) i, byvalTypeAttr);
            }
        }
    }

    void declareVar(string name, BackendType type, bool define, bool threadlocal) {
        if (this.declared(name)) {
            if (define) {
                .print("double-define $name");
                assert(false);
            }
            return;
        }
        auto llType = translate(type, false);
        auto global = LLVMAddGlobal(this.module_, llType, name.toStringz);
        if (define) {
            LLVMSetInitializer(global, LLVMConstNull(llType));
        }
        if (threadlocal) {
            LLVMSetThreadLocal(global, true);
        }
        this.globals[name] = type;
    }

    override BackendFunction define(
        string name, string decoration, BackendType ret, BackendType[] args, BackendLocation loc)
    {
        this.globals[name] = new BackendFunctionPointerType(ret, args, variadic=false, this.platform);

        return new LLVMBackendFunction(this, name, ret, args, loc, decoration);
    }

    override void declareSymbolList(string name, size_t length)
    {
        auto globalType = new BackendStaticArrayType(
            new BackendFunctionPointerType(
                new BackendVoidType, new BackendType[](0), variadic=false, this.platform), cast(int) length);
        auto llType = translate(globalType, allowVoid=true);
        LLVMAddGlobal(this.module_, llType, name.toStringz);
        this.globals[name] = globalType;
    }

    override void defineSymbolList(string name, (string | size_t)[] symbols)
    {
        if (forMacro && neat_runtime_symbol_defined_in_main(name))
            return;

        auto defaultFpType = new BackendFunctionPointerType(
            new BackendVoidType, new BackendType[](0), variadic=false, this.platform);
        auto defaultFpTypeL = translate(defaultFpType, false);
        auto globalType = new BackendStaticArrayType(defaultFpType, cast(int) symbols.length);

        mut LLVMValueRef[] symbolList;
        for (symbol in symbols) {
            symbol.case {
                string sym: {
                    auto fun = LLVMGetNamedFunction(this.module_, sym.toStringz);
                    symbolList ~= LLVMConstBitCast(fun, defaultFpTypeL);
                }
                size_t l: {
                    auto int_ = LLVMConstInt(LLVMInt32TypeInContext(this.context), l, SignExtend=false);
                    symbolList ~= LLVMConstIntToPtr(int_, defaultFpTypeL);
                }
            }
        }
        auto array = LLVMConstArray(defaultFpTypeL, symbolList.ptr, cast(int) symbolList.length);
        auto llvmType = translate(globalType, allowVoid=true);

        mut uninitialized LLVMValueRef var;
        if (auto existingVar = LLVMGetNamedGlobal(this.module_, name.toStringz)) {
            var = existingVar;
        } else {
            var = LLVMAddGlobal(this.module_, llvmType, name.toStringz);
        }
        LLVMSetInitializer(var, array);

        this.globals[name] = globalType;
    }

    string nextLiteral() {
        string res = "str" ~ itoa(this.literalId);
        this.literalId = this.literalId + 1;
        return res;
    }

    BackendType globalType(string name) {
        return this.globals.get(name, ({
            .print("no such global " ~ name);
            assert(false);
            BackendType t = new BackendVoidType; t;
        }));
    }

    override void done()
    {
        LLVMDIBuilderFinalize(this.dibuilder);
        LLVMDisposeDIBuilder(this.dibuilder);
        // LLVMVerifyModule(this.module_, LLVMAbortProcessAction, null);
    }
}

extern(C) bool neat_runtime_symbol_defined_in_main(string symbol);

struct RegDefine
{
    int reg;
    BackendType type;
    LLVMValueRef value;
    /**
     * These modes are used to avoid LLVM's difficulties with large struct moves - instead of
     * loading incremental fields of a pointer, we pass around references into the original alloca,
     * so long as we can be assured that it *is* a temporary alloca and not, say, a pointer into user code.
     *
     * Modes:
     * - value: <reg> is a register of type <type> and LLVM value <value>.
     * - temporary ptr: as value, but <type> is a pointer to a temporary allocation
     *   (an allocation guaranteed to never change, that is just used for union casting and the like)
     * - transparent ptr: <value> is actually a pointer to <type> that must be deferenced on load.
     */
    (:value | :temporaryPtr | :transparentPtr) mode;
    bool isTemporaryPtr() => mode == :temporaryPtr;
    bool isTransparentPtr() => mode == :transparentPtr;
    string toString() => "RegDefine($reg, $type, <value>, $mode)";
}

struct RegDefines
{
    // reg is index. FIXME hashmap
    RegDefine mut[] regDefines;
    void add(RegDefine define) {
        resize(define.reg + 1);
        regDefines[define.reg] = define;
    }
    void resize(int targetLength) {
        if (regDefines.length < targetLength) {
            auto copy = new RegDefine mut[](targetLength * 2);
            for (i, regDefine in regDefines)
                copy[i] = regDefine;
            regDefines = copy;
        }
    }
    RegDefine reg(int reg) {
        if (reg >= regDefines.length || regDefines[reg].reg != reg) {
            print("internal error: undefined register $reg");
            assert(false);
        }
        return regDefines[reg];
    }
    (RegDefine | fail :notFound) get(int reg) {
        if (reg >= regDefines.length || regDefines[reg].reg != reg)
            return :notFound;
        return regDefines[reg];
    }
}

extern(C) LLVMBuilderRef LLVMCreateNoFolderBuilderInContext(LLVMContextRef C);

class LLVMBackendFunction : BackendFunction, PhiCapable {
    LLVMBackendModule mod;
    BackendType ret_;
    BackendType[] params;

    RegDefines regDefines;
    int regId;
    int blockId;
    string curLabel;

    int loadId;
    int memcpyId;

    // correct for sret, byvalue
    LLVMValueRef[] llArgs;
    LLVMMetadataRef difun;

    LLVMValueRef function_;
    LLVMBuilderRef builder;
    LLVMBuilderRef entryBuilder;
    LLVMBasicBlockRef[string] labels;

    LLVMBasicBlockRef llLabel(string name) {
        if (!this.labels.has(name)) {
            this.labels[name] = LLVMAppendBasicBlockInContext(
                this.mod.context, this.function_, name.toStringz);
        }
        return this.labels[name];
    }

    this(this.mod, this.name, this.ret_, this.params, BackendLocation loc, string decoration)
    {
        auto fpType = new BackendFunctionPointerType(this.ret_, this.params, false, this.mod.platform);
        auto llFpType = translateFunc(fpType, this.mod.context);
        if (auto llExistingFunction = LLVMGetNamedFunction(this.mod.module_, this.name.toStringz)) {
            this.function_ = llExistingFunction;
        } else {
            this.function_ = LLVMAddFunction(this.mod.module_, this.name.toStringz, llFpType);
            this.mod.llSetCoerceAttribs(this.function_, this.ret_, this.params);
        }

        auto comps = split(loc.file, "/");
        auto dir = join(comps[0 .. $ - 1], "/");
        auto filename = comps[$ - 1];

        auto unit = LLVMDIBuilderCreateFile(
            this.mod.dibuilder, filename.ptr, filename.length,
            dir.ptr, dir.length);
        /*auto diType = LLVMDIBuilderCreateSubroutineType(
            this.mod.dibuilder,
            unit,
            [this.mod.translate(a, false) for a in this.params].ptr,
            this.params.length,
            0);*/
        auto diType = LLVMDIBuilderCreateSubroutineType(
            this.mod.dibuilder,
            unit,
            null, 0,
            0);
        this.difun = LLVMDIBuilderCreateFunction(
            this.mod.dibuilder, unit,
            name.ptr, name.length,
            decoration.ptr, decoration.length,
            unit, 0, diType,
            false, true, 0, /* LLVMDIFlagPrototyped */ 256 /* why? */, false);
        this.function_.LLVMSetSubprogram(this.difun);

        this.regId = 1;
        this.blockId = 1;
        this.builder = LLVMCreateBuilderInContext(this.mod.context);
        this.entryBuilder = LLVMCreateBuilderInContext(this.mod.context);

        // 'entry' branches into 'first' in done(), until then it just gets filled with static allocas
        LLVMPositionBuilderAtEnd(this.entryBuilder, llLabel("entry"));
        LLVMPositionBuilderAtEnd(this.builder, llLabel("first"));

        // TODO RegDefine[] llArgs
        auto llArgs = new LLVMValueRef mut[](this.params.length);
        bool sret = passByMemory(this.ret_);
        mut int llvmParamId = sret;
        for (int i, param in params) {
            if (param.size == 0) {
                llArgs[i] = null;
                continue;
            }
            auto llParam = this.mod.translate(param, allowVoid=false);
            if (auto amd64Type = toAmd64ParamType(param)) {
                auto llAllocaReg = LLVMBuildAlloca(this.entryBuilder, llParam, "tmparg$i".toStringz);
                auto llAmd64Type = this.mod.translate(amd64Type, false);
                auto llAmd64Ptr = this.mod.translate(new BackendPointerType(amd64Type, this.mod.platform), false);
                auto llAllocaAmd64Ptr = LLVMBuildBitCast(
                    this.builder, llAllocaReg, llAmd64Ptr, "argload_alloca$i".toStringz);
                auto paramPtr = LLVMGetParam(this.function_, llvmParamId++);
                LLVMBuildStore(this.builder, paramPtr, llAllocaAmd64Ptr);
                llArgs[i] = LLVMBuildLoad2(this.builder, llParam, llAllocaReg, "argload$i".toStringz);
            } else if (passByMemory(param)) {
                auto paramPtr = LLVMGetParam(this.function_, llvmParamId++);
                llArgs[i] = LLVMBuildLoad2(
                    this.builder, llParam, paramPtr, "arg$i.load".toStringz);
            } else {
                llArgs[i] = LLVMGetParam(this.function_, llvmParamId++);
            }
        }
        this.llArgs = llArgs.freeze;
    }

    override string toString() => "LLVMBackendFunction($(this.name))";

    LLVMValueRef llReg(int reg) {
        with (this.regDefines.reg(reg)) {
            if (isTransparentPtr) {
                auto loadId = this.loadId++;
                auto llType = this.mod.translate(type, allowVoid=false);
                return LLVMBuildLoad2(this.builder, llType, value, "reg$reg.load$loadId".toStringz);
            }
            return value;
        }
    }
    bool llRegIsTransparentPtr(int reg) => this.regDefines.reg(reg).isTransparentPtr;
    LLVMValueRef llRegPtr(int reg) => this.regDefines.reg(reg).value;
    BackendType regType(int reg) => this.regDefines.reg(reg).type;
    void defReg2(int reg, BackendType type, LLVMValueRef value) {
        this.regDefines.add(RegDefine(reg, type, value, mode=:value));
    }
    void defRegTemporaryPtr(int reg, BackendType type, LLVMValueRef value) {
        this.regDefines.add(RegDefine(reg, type, value, mode=:temporaryPtr));
    }
    void defRegTransparentPtr(int reg, BackendType type, LLVMValueRef value) {
        this.regDefines.add(RegDefine(reg, type, value, mode=:transparentPtr));
    }
    int defReg(BackendType type, LLVMValueRef value) {
        int reg = this.nextReg;
        this.defReg2(reg, type, value);
        return reg;
    }
    private int nextReg() {
        int result = this.regId;
        this.regId = this.regId + 1;
        return result;
    }
    override string getLabel() {
        return "Label" ~ itoa(this.blockId);
    }
    override string getCurrentLabel() {
        return curLabel;
    }
    override void setLabel(string label) {
        curLabel = label;
        LLVMPositionBuilderAtEnd(builder, llLabel(label));
    }
    override void setLocation(BackendLocation loc) {
        auto di = LLVMDIBuilderCreateDebugLocation(this.mod.context, loc.line + 1, loc.column, this.difun, null);
        LLVMSetCurrentDebugLocation2(builder, di);
    }
    override int arg(int index) {
        return this.defReg(this.params[index], this.llArgs[index]);
    }
    // TODO template all these with alias?
    override int intLiteral(long value) {
        auto llType = this.mod.translate(new BackendIntType, false);
        return this.defReg(new BackendIntType, LLVMConstInt(llType, value, false));
    }
    override int shortLiteral(int value) {
        auto llType = this.mod.translate(new BackendShortType, false);
        return this.defReg(new BackendShortType, LLVMConstInt(llType, value, false));
    }
    override int byteLiteral(int value) {
        auto llType = this.mod.translate(new BackendCharType, false);
        return this.defReg(new BackendCharType, LLVMConstInt(llType, value, false));
    }
    override int longLiteral(long value) {
        auto llType = this.mod.translate(new BackendLongType, false);
        return this.defReg(new BackendLongType, LLVMConstInt(llType, value, false));
    }
    override int floatLiteral(float value) {
        auto llType = this.mod.translate(new BackendFloatType, false);
        return this.defReg(new BackendFloatType, LLVMConstReal(llType, value));
    }
    override int doubleLiteral(double value) {
        auto llType = this.mod.translate(new BackendDoubleType, false);
        return this.defReg(new BackendDoubleType, LLVMConstReal(llType, value));
    }
    override int wordLiteral(Platform platform, size_t value) {
        auto llType = this.mod.translate(platform.nativeWordType, false);
        return this.defReg(platform.nativeWordType, LLVMConstInt(llType, value, false));
    }
    override int stringLiteral(string text) {
        auto ptrType = new BackendPointerType(new BackendCharType, this.mod.platform);
        string literalId = this.mod.nextLiteral;
        auto llType = this.mod.translate(
            new BackendStaticArrayType(new BackendCharType, cast(int) text.length), false);
        auto stringVar = LLVMAddGlobal(this.mod.module_, llType, literalId.toStringz);
        LLVMSetLinkage(stringVar, LLVMPrivateLinkage);
        LLVMSetUnnamedAddress(stringVar, LLVMGlobalUnnamedAddr);
        LLVMSetGlobalConstant(stringVar, true);
        LLVMSetInitializer(stringVar, LLVMConstStringInContext(
            this.mod.context, text.ptr, cast(int) text.length, DontNullTerminate=true));
        auto stringVal = LLVMConstPointerCast(stringVar, this.mod.translate(ptrType, false));

        return this.defReg(ptrType, stringVal);
    }
    override int voidLiteral() {
        return zeroLiteral(new BackendVoidType);
    }
    override void unreachable() {
        LLVMBuildUnreachable(this.builder);
        this.blockId += 1;
    }
    override int zeroLiteral(BackendType type) {
        // fake reg
        if (type.size == 0) return this.defReg(type, null);
        return this.defReg(type, LLVMConstNull(this.mod.translate(type, false)));
    }
    override int structLiteral(BackendType backendType, int[] regs) {
        auto struct_ = backendType.instanceOf(BackendStructType);
        assert(!!struct_);

        // fake reg
        if (backendType.size == 0) return this.defReg(backendType, null);

        auto llType = this.mod.translate(struct_, false);
        mut int curReg = this.defReg(struct_, LLVMGetUndef(llType));
        for (int i, reg in regs) {
            if (struct_.members[i].size == 0) continue;
            int nextReg = this.nextReg;
            auto translatedIndex = [count a in struct_.members[0 .. i] where a.size > 0];
            auto nextVal = LLVMBuildInsertValue(
                this.builder, this.llReg(curReg), this.llReg(reg), translatedIndex, "reg$nextReg".toStringz);
            this.defReg2(nextReg, struct_, nextVal);
            curReg = nextReg;
        }
        return curReg;
    }
    override int symbolList(string name) {
        int reg = this.nextReg;
        auto type = this.mod.globalType(name);
        auto llType = this.mod.translate(type, allowVoid=true);
        auto llGlobal = LLVMGetNamedGlobal(this.mod.module_, name.toStringz);
        assert(!!llGlobal);

        auto bytePtr = new BackendPointerType(new BackendCharType, this.mod.platform);
        auto llCast = LLVMConstBitCast(llGlobal, this.mod.translate(bytePtr, false));
        return this.defReg(bytePtr, llCast);
    }
    override int globalVar(string name, BackendType type, bool define, bool threadlocal) {
        this.mod.declareVar(name, type, define, threadlocal);
        int reg = this.nextReg;
        auto llGlobal = LLVMGetNamedGlobal(this.mod.module_, name.toStringz);
        assert(!!llGlobal);
        return this.defReg(type, llGlobal);
    }
    override int binop(string op, BackendType type, int left, int right) {
        mut uninitialized (:op, LLVMOpcode | :fcmp, LLVMRealPredicate | :icmp, LLVMIntPredicate) llOp;
        if (type.instanceOf(BackendFloatType) || type.instanceOf(BackendDoubleType)) {
            if (op == "+") llOp = (:op, LLVMFAdd);
            else if (op == "-") llOp = (:op, LLVMFSub);
            else if (op == "*") llOp = (:op, LLVMFMul);
            else if (op == "/") llOp = (:op, LLVMFDiv);
            else if (op == "==") llOp = (:fcmp, LLVMRealOEQ);
            else if (op == "!=") llOp = (:fcmp, LLVMRealONE);
            else if (op == "<") llOp = (:fcmp, LLVMRealOLT);
            else if (op == "<=") llOp = (:fcmp, LLVMRealOLE);
            else if (op == ">") llOp = (:fcmp, LLVMRealOGT);
            else if (op == ">=") llOp = (:fcmp, LLVMRealOGE);
            else { .print(op); assert(false); }
        } else if (type.instanceOf(BackendLongType) || type.instanceOf(BackendIntType)
                || type.instanceOf(BackendShortType) || type.instanceOf(BackendCharType)) {
            if (op == "+") llOp = (:op, LLVMAdd);
            else if (op == "-") llOp = (:op, LLVMSub);
            else if (op == "*") llOp = (:op, LLVMMul);
            else if (op == "/") llOp = (:op, LLVMSDiv);
            else if (op == "%") {
                return wrappedRemainder(type, left, right);
            }
            else if (op == "__%") llOp = (:op, LLVMSRem);
            else if (op == "&") llOp = (:op, LLVMAnd);
            else if (op == "^") llOp = (:op, LLVMXor);
            else if (op == "|") llOp = (:op, LLVMOr);
            else if (op == "<<") llOp = (:op, LLVMShl);
            else if (op == ">>") llOp = (:op, LLVMAShr);
            else if (op == ">>>") llOp = (:op, LLVMLShr);
            else if (op == "==") llOp = (:icmp, LLVMIntEQ);
            else if (op == "!=") llOp = (:icmp, LLVMIntNE);
            else if (op == "<") llOp = (:icmp, LLVMIntSLT);
            else if (op == "<=") llOp = (:icmp, LLVMIntSLE);
            else if (op == ">") llOp = (:icmp, LLVMIntSGT);
            else if (op == ">=") llOp = (:icmp, LLVMIntSGE);
            else { .print(op); assert(false); }
        } else if (type.isPointer && (op == "==" || op == "!=")) {
            if (op == "==") llOp = (:icmp, LLVMIntEQ);
            else if (op == "!=") llOp = (:icmp, LLVMIntNE);
            else { .print(op); assert(false); }
        } else {
            .print("unknown op $op on $(type.repr)");
            assert(false);
        }
        mut int reg = this.nextReg;
        auto llResult = llOp.case(
            (:op, LLVMOpcode op):
                LLVMBuildBinOp(this.builder, op, llReg(left), llReg(right), "reg$reg".toStringz),
            (:fcmp, LLVMRealPredicate pred):
                LLVMBuildFCmp(this.builder, pred, llReg(left), llReg(right), "reg$reg".toStringz),
            (:icmp, LLVMIntPredicate pred):
                LLVMBuildICmp(this.builder, pred, llReg(left), llReg(right), "reg$reg".toStringz));
        if (isBooleanOp(op)) {
            reg = this.nextReg;
            auto lli32 = this.mod.translate(new BackendIntType, false);
            auto llZext = LLVMBuildZExt(this.builder, llResult, lli32, "reg$reg".toStringz);
            this.defReg2(reg, new BackendIntType, llZext);
        } else {
            this.defReg2(reg, type, llResult);
        }
        return reg;
    }
    int wrappedRemainder(BackendType type, int left, int right) {
        int op(int left, string op, int right) { return binop(op, type, left, right); }
        // ((a % b) + b) % b
        return left.op("__%", right).op("+", right).op("__%", right);
    }
    override int bitcast(int from, BackendType to) {
        auto def = this.regDefines.reg(from);
        if (def.type.same(to)) return from;

        auto fromType = def.type;
        if (fromType && fromType.size == 0 && to.size != 0) {
            print("fromType = $(fromType.repr), to = $(to.repr)");
            assert(false);
        }

        bool shorter(BackendType left, BackendType right) {
            // TODO validate both are a numeric type
            return left.size < right.size;
        }

        assert(!fromType || !fromType.instanceOf(BackendStructType));
        assert(!fromType || fromType.instanceOf(BackendPointerType) || to.instanceOf(BackendPointerType)
            || fromType.size >= to.size);

        int reg = this.nextReg;
        mut LLVMValueRef llRes;
        auto llTo = this.mod.translate(to, false);
        if (auto fromType = fromType) {
            if (!fromType.instanceOf(BackendPointerType) && to.instanceOf(BackendPointerType))
                llRes = LLVMBuildIntToPtr(this.builder, llReg(from), llTo, "reg$reg".toStringz);
            else if (fromType.instanceOf(BackendPointerType) && !to.instanceOf(BackendPointerType))
                llRes = LLVMBuildPtrToInt(this.builder, llReg(from), llTo, "reg$reg".toStringz);
            else if (fromType.instanceOf(BackendDoubleType) && to.instanceOf(BackendFloatType))
                llRes = LLVMBuildFPTrunc(this.builder, llReg(from), llTo, "reg$reg".toStringz);
            else if (!fromType.instanceOf(BackendPointerType) && to.shorter(fromType))
                llRes = LLVMBuildTrunc(this.builder, llReg(from), llTo, "reg$reg".toStringz);
            else
                llRes = LLVMBuildBitCast(this.builder, llReg(from), llTo, "reg$reg".toStringz);
        } else
            llRes = LLVMBuildBitCast(this.builder, llReg(from), llTo, "reg$reg".toStringz);
        if (def.isTemporaryPtr)
            this.defRegTemporaryPtr(reg, to, llRes);
        else
            this.defReg2(reg, to, llRes);
        return reg;
    }
    override int zeroExtend(int value, BackendType to) {
        int reg = this.nextReg;
        auto llRes = LLVMBuildZExt(
            this.builder, llReg(value), this.mod.translate(to, false), "reg$reg".toStringz);
        this.defReg2(reg, to, llRes);
        return reg;
    }
    override int signExtend(int value, BackendType to) {
        int reg = this.nextReg;
        auto llRes = LLVMBuildSExt(
            this.builder, llReg(value), this.mod.translate(to, false), "reg$reg".toStringz);
        this.defReg2(reg, to, llRes);
        return reg;
    }
    override int trunc(int value, BackendType to) {
        int reg = this.nextReg;
        auto llRes = LLVMBuildTrunc(
            this.builder, llReg(value), this.mod.translate(to, false), "reg$reg".toStringz);
        this.defReg2(reg, to, llRes);
        return reg;
    }
    override int convert(int reg, BackendType to) {
        RegDefine def() {
            this.regDefines.get(reg).case {
                RegDefine def: return def;
                (:notFound): assert(false);
            }
        }
        auto def = def;
        auto from = def.type;
        bool isInt(BackendType type) {
            return !!type.instanceOf(BackendIntType);
        }
        bool isFloat(BackendType type) {
            return type.instanceOf(BackendFloatType) || type.instanceOf(BackendDoubleType);
        }
        int target = this.nextReg;
        auto llTo = this.mod.translate(to, false);
        mut LLVMValueRef llTarget;
        if (from.isInt && to.isFloat)
            llTarget = LLVMBuildSIToFP(this.builder, llReg(reg), llTo, "reg$target".toStringz);
        else if (from.isFloat && to.isInt)
            llTarget = LLVMBuildFPToSI(this.builder, llReg(reg), llTo, "reg$target".toStringz);
        else if (from.instanceOf(BackendFloatType) && to.instanceOf(BackendDoubleType))
            llTarget = LLVMBuildFPExt(this.builder, llReg(reg), llTo, "reg$target".toStringz);
        else if (from.instanceOf(BackendDoubleType) && to.instanceOf(BackendFloatType))
            llTarget = LLVMBuildFPTrunc(this.builder, llReg(reg), llTo, "reg$target".toStringz);
        else assert(false);
        this.defReg2(target, to, llTarget);
        return target;
    }

    (BackendType[] params, int[] args) patchVariadicParams(BackendFunctionPointerType type, int[] args) {
        if (!type.variadic || type.params.length >= args.length)
            return (type.params, args);
        mut int[] realArgs = args[0 .. type.params.length];
        auto variadicArgs = args[type.params.length .. $];
        mut BackendType[] realParams = type.params;
        for (i, auto reg in variadicArgs) {
            RegDefine def() {
                this.regDefines.get(reg).case {
                    RegDefine def: return def;
                    (:notFound): assert(false);
                }
            }
            auto def = def;
            realParams ~= def.type;
            // variadic floats are promoted to double
            auto arg = args[type.params.length + i];
            if (def.type.instanceOf(BackendFloatType)) {
                auto newArg = this.nextReg;
                auto llDouble = this.mod.translate(new BackendDoubleType, false);
                auto llNewArg = LLVMBuildFPExt(this.builder, llReg(arg), llDouble, "reg$newArg".toStringz);
                this.defReg2(newArg, new BackendDoubleType, llNewArg);
                realArgs ~= newArg;
            } else {
                realArgs ~= arg;
            }
        }
        assert(realParams.length == args.length);
        return (realParams, realArgs);
    }

    void genMemcpy(LLVMValueRef llSourcePtr, LLVMValueRef llTargetPtr, int size) {
        auto id = this.memcpyId++;
        auto llBoolType = LLVMInt1TypeInContext(this.mod.context);
        auto llInt64Type = LLVMInt64TypeInContext(this.mod.context);
        auto llVoidp = LLVMPointerType(LLVMInt8TypeInContext(this.mod.context), 0);
        auto llFalse = LLVMConstInt(llBoolType, false, false);
        auto llSize = LLVMConstInt(llInt64Type, size, false);
        auto llCastSourcePtr = LLVMBuildBitCast(this.builder, llSourcePtr, llVoidp, "memcpy$id.cast1".toStringz);
        auto llCastTargetPtr = LLVMBuildBitCast(this.builder, llTargetPtr, llVoidp, "memcpy$id.cast2".toStringz);
        auto llArgs = [llCastTargetPtr, llCastSourcePtr, llSize, llFalse];
        LLVMBuildCall2(
            this.builder, this.mod.llMemcpyType, this.mod.llMemcpy,
            llArgs.ptr, cast(int) llArgs.length, "\x00".ptr);
    }

    void llRegCopy(BackendType type, LLVMTypeRef llType, int source, LLVMValueRef llTargetPtr) {
        auto def = this.regDefines.reg(source);
        // TODO figure out why it produces segfaults with memcpy
        if (false && def.isTransparentPtr
            && (type.instanceOf(BackendStructType) || type.instanceOf(BackendSpacerType))
        ) {
            genMemcpy(llSourcePtr=def.value, llTargetPtr=llTargetPtr, type.size);
            return;
        }
        LLVMBuildStore(this.builder, llReg(source), llTargetPtr);
    }

    LLVMValueRef llRegToAlloca(BackendType type, int reg) {
        auto def = this.regDefines.reg(reg);
        if (def.isTransparentPtr) return def.value;
        auto llType = this.mod.translate(type, false);
        auto llAlloca = LLVMBuildAlloca(this.entryBuilder, llType, "reg$reg.alloca".toStringz);
        llRegCopy(type, llType, reg, llAlloca);
        return llAlloca;
    }

    int callImpl(BackendType retType, BackendFunctionPointerType fpType, (int | string) target, int[] args) {
        auto patch = patchVariadicParams(fpType, args);
        BackendType[] params = patch.params;
        int[] args = patch.args;
        int reg = this.nextReg;
        auto llRetType = this.mod.translate(retType, true);

        mut LLVMValueRef llRetReg;
        mut LLVMValueRef[] llArgs;
        bool sret = passByMemory(retType);
        if (sret) {
            llRetReg = LLVMBuildAlloca(this.entryBuilder, llRetType, "reg$reg.ret".toStringz);
            llArgs ~= llRetReg;
        }
        for (int i, arg in args) {
            // skip 0-sized parameters
            if (params[i].zeroSize) continue;
            if (auto amd64Type = toAmd64ParamType(params[i])) {
                auto llAlloca = llRegToAlloca(params[i], arg);
                auto llAmd64Type = this.mod.translate(amd64Type, false);
                auto llAmd64PtrType = this.mod.translate(new BackendPointerType(amd64Type, this.mod.platform), false);
                auto llAllocaAsAmd64Ptr = LLVMBuildBitCast(
                    this.builder, llAlloca, llAmd64PtrType, "reg$reg.coerce$i.cast".toStringz);
                llArgs ~= LLVMBuildLoad2(this.builder, llAmd64Type, llAllocaAsAmd64Ptr, "reg$reg.load".toStringz);
            } else if (passByMemory(params[i])) {
                llArgs ~= llRegToAlloca(params[i], arg);
            } else {
                llArgs ~= llReg(arg);
            }
        }

        mut LLVMValueRef llFun;

        target.case {
            string name:
                llFun = LLVMGetNamedFunction(this.mod.module_, name.toStringz);
                if (!llFun) {
                    print("couldn't find target named function $name");
                    assert(false);
                }
            int reg:
                llFun = llReg(reg);
        }

        mut string name = "reg$reg";
        if (sret || retType.size == 0) {
            name = "";
        }

        // TODO lines
        auto llLoc = LLVMDIBuilderCreateDebugLocation(
            LLVMGetModuleContext(this.mod.module_), 0, 0, this.difun, null);
        LLVMSetCurrentDebugLocation2(this.builder, llLoc);

        auto llFuncType = translateFunc(fpType, this.mod.context);
        auto llCall = LLVMBuildCall2(
            this.builder, llFuncType, llFun, llArgs.ptr, cast(int) llArgs.length, name.toStringz);

        if (sret) {
            auto sretAttrKind = LLVMGetEnumAttributeKindForName("sret", 4);
            assert(sretAttrKind != 0);
            auto sretTypeAttr = LLVMCreateTypeAttribute(
                this.mod.context, sretAttrKind, this.mod.translate(retType, true));
            // base-1, first parameter
            LLVMAddCallSiteAttribute(llCall, 1, sretTypeAttr);
        }

        for (int i, param in params) {
            if (passByMemory(param)) {
                auto byvalAttrKind = LLVMGetEnumAttributeKindForName("byval", 5);
                assert(byvalAttrKind != 0);
                auto byvalTypeAttr = LLVMCreateTypeAttribute(
                    this.mod.context, byvalAttrKind, this.mod.translate(param, false));
                // base-1 (0 is return type), + 1 for sret parameter
                int base = 1 + sret;
                LLVMAddCallSiteAttribute(llCall, base + cast(int) i, byvalTypeAttr);
            }
        }

        if (sret) {
            this.defRegTransparentPtr(reg, retType, llRetReg);
        } else if (retType.size > 0) {
            if (auto amd64Type = toAmd64ParamType(retType)) {
                auto llAmd64Type = this.mod.translate(amd64Type, false);
                auto llAlloca = LLVMBuildAlloca(this.entryBuilder, llAmd64Type, "reg$reg.ret.coerce".toStringz);
                LLVMBuildStore(this.builder, llCall, llAlloca);
                auto llRetPtrType = this.mod.translate(new BackendPointerType(retType, this.mod.platform), false);
                auto llAllocaAsRetPtr = LLVMBuildBitCast(
                    this.builder, llAlloca, llRetPtrType, "reg$reg.ret.cast".toStringz);
                this.defRegTransparentPtr(reg, retType, llAllocaAsRetPtr);
            } else
                this.defReg2(reg, retType, llCall);
        }

        return reg;
    }

    override int call(BackendType ret, string name, int[] args) {
        if (!mod.declared(name)) { .print(name ~ " not declared"); assert(false); }
        BackendFunctionPointerType globalType() {
            if (auto type = this.mod.globalType(name).instanceOf(BackendFunctionPointerType))
                return type;
            assert(false);
        }
        auto type = globalType;
        return callImpl(type.ret, type, name, args);
    }

    override int getFuncPtr(BackendType type, string name) {
        return this.defReg(type,
            LLVMGetNamedFunction(this.mod.module_, name.toStringz));
    }

    override int callFuncPtr(BackendType type, int callReg, int[] args) {
        auto backendFpType = type.instanceOf(BackendFunctionPointerType)? else die;

        return callImpl(retType=backendFpType.ret, fpType=backendFpType, callReg, args);
    }

    override int load(BackendType backendType, int source) {
        if (backendType.size == 0) {
            // fake reg
            return this.defReg(backendType, null);
        }
        int reg = this.nextReg;
        auto def = this.regDefines.reg(source);
        if (def.isTemporaryPtr) {
            // load(temporary pointer) = transparent ptr
            this.defRegTransparentPtr(reg, backendType, def.value);
        } else {
            auto llType = this.mod.translate(backendType, false);
            auto llVal = LLVMBuildLoad2(this.builder, llType, llReg(source), "reg$reg".toStringz);
            this.defReg2(reg, backendType, llVal);
        }
        return reg;
    }
    override int staticAlloca(BackendType backendType) {
        auto ptrType = new BackendPointerType(backendType, this.mod.platform);
        if (backendType.size == 0) {
            // nullptr reg
            auto llPtrType = this.mod.translate(ptrType, false);
            return this.defReg(ptrType, LLVMConstNull(llPtrType));
        }
        int reg = this.nextReg;
        auto llType = this.mod.translate(backendType, false);
        auto llAlloca = LLVMBuildAlloca(this.entryBuilder, llType, "reg$reg".toStringz);
        this.defReg2(reg, ptrType, llAlloca);
        if (backendType.size > 0) {
            LLVMBuildStore(this.builder, LLVMConstNull(llType), llAlloca);
        }
        return reg;
    }
    override int toPtr(BackendType backendType, int source) {
        if (llRegIsTransparentPtr(source)) {
            int reg = this.nextReg;
            this.defRegTemporaryPtr(reg, new BackendPointerType(backendType, this.mod.platform), llRegPtr(source));
            return reg;
        }
        return super.toPtr(backendType, source);
    }
    override void markPointerInvariant(int reg) {
        assert(this.regDefines.reg(reg).(mode == :value || mode == :temporaryPtr));
        this.regDefines.regDefines[reg].mode = :temporaryPtr;
    }
    override int field(BackendType backendType, int source, int index) {
        auto backendStructType = backendType.instanceOf(BackendStructType);
        assert(!!backendStructType);

        auto elemType = backendStructType.members[index];

        // fake reg
        if (elemType.size == 0) return this.defReg(elemType, null);

        int reg = this.nextReg;
        auto def = this.regDefines.reg(source);
        auto translatedIndex = [count a in backendStructType.members[0 .. index] where a.size > 0];
        if (def.isTransparentPtr) {
            auto int32Type = LLVMInt32TypeInContext(this.mod.context);
            auto indices = [
                LLVMConstInt(int32Type, 0, false),
                LLVMConstInt(int32Type, translatedIndex, false)];
            auto llStructType = this.mod.translate(backendType, false);
            auto llGep = LLVMBuildGEP2(
                this.builder, llStructType, def.value,
                indices.ptr, cast(int) indices.length, "reg$reg".toStringz);
            this.defRegTransparentPtr(reg, elemType, llGep);
        } else {
            auto llExtract = LLVMBuildExtractValue(this.builder, def.value, translatedIndex, "reg$reg".toStringz);
            assert(!def.isTemporaryPtr);
            this.defReg2(reg, elemType, llExtract);
        }
        return reg;
    }
    override int fieldOffset(BackendType backendType, int source, size_t index) {
        auto backendStructType = backendType.instanceOf(BackendStructType);
        assert(!!backendStructType);

        auto elemType = backendStructType.members[index];
        auto elemPtr = new BackendPointerType(elemType, this.mod.platform);
        if (backendType.size == 0) return this.bitcast(source, elemPtr);

        int reg1 = this.bitcast(source, new BackendPointerType(backendType, this.mod.platform));
        auto def = this.regDefines.reg(reg1);
        int reg2 = this.nextReg;
        auto int32Type = LLVMInt32TypeInContext(this.mod.context);
        auto translatedLength = [count a in backendStructType.members where a.size > 0];
        auto translatedIndex = [count a in backendStructType.members[0 .. index] where a.size > 0];
        LLVMValueRef[] indices() {
            if (translatedIndex == translatedLength) {
                // take address of a zero-size field at the end of the struct
                return [
                    LLVMConstInt(int32Type, 1, false),
                    LLVMConstInt(int32Type, 0, false)];
            }
            return [
                LLVMConstInt(int32Type, 0, false),
                LLVMConstInt(int32Type, translatedIndex, false)];
        }
        auto indices = indices;
        auto llStructType = this.mod.translate(backendType, false);

        auto llGep = LLVMBuildGEP2(
            this.builder, llStructType, llReg(reg1), indices.ptr, cast(int) indices.length, "reg$reg2".toStringz);
        if (def.isTemporaryPtr)
            this.defRegTemporaryPtr(reg2, elemPtr, llGep);
        else
            this.defReg2(reg2, elemPtr, llGep);
        return reg2;
    }
    override int ptrOffset(BackendType backendType, int ptrReg, int offsetReg) {
        if (backendType.size == 0) {
            // what are you doing??
            return ptrReg;
        }

        auto ptrType = new BackendPointerType(backendType, this.mod.platform);

        int reg1 = this.bitcast(ptrReg, ptrType);
        int reg2 = this.nextReg;
        auto int32Type = LLVMInt32TypeInContext(this.mod.context);
        auto indices = [llReg(offsetReg)];
        auto llElemType = this.mod.translate(backendType, false);

        auto llGep = LLVMBuildGEP2(
            this.builder, llElemType, llReg(reg1), indices.ptr, cast(int) indices.length, "reg$reg2".toStringz);
        this.defReg2(reg2, ptrType, llGep);
        return reg2;
    }
    override void store(BackendType type, int targetReg, int valueReg) {
        if (type.size == 0) return;
        auto llType = this.mod.translate(type, false);
        llRegCopy(type, llType, valueReg, llReg(targetReg));
    }
    override void ret(int reg) {
        bool sret = passByMemory(this.ret_);
        if (this.ret_.size == 0) {
            LLVMBuildRetVoid(this.builder);
        } else if (sret) {
            LLVMBuildStore(this.builder, llReg(reg), LLVMGetParam(this.function_, 0));
            LLVMBuildRetVoid(this.builder);
        } else {
            auto amd64Type = toAmd64ParamType(this.ret_);
            if (amd64Type && !amd64Type.same(this.ret_)) {
                auto amd64Type = amd64Type? else die;
                auto llAlloca = llRegToAlloca(this.ret_, reg);
                auto llAmd64Type = this.mod.translate(amd64Type, false);
                auto llAmd64PtrType = this.mod.translate(new BackendPointerType(amd64Type, this.mod.platform), false);
                auto llAllocaAsAmd64Ptr = LLVMBuildBitCast(
                    this.builder, llAlloca, llAmd64PtrType, "reg$reg.ret.cast".toStringz);
                auto llRetVal = LLVMBuildLoad2(
                    this.builder, llAmd64Type, llAllocaAsAmd64Ptr, "reg$reg.ret.load".toStringz);
                LLVMBuildRet(this.builder, llRetVal);
            } else {
                LLVMBuildRet(this.builder, llReg(reg));
            }
        }
        this.blockId += 1;
    }
    override void branch(string label) {
        LLVMBuildBr(this.builder, llLabel(label));
        this.blockId += 1;
    }
    override void testBranch(int reg, string thenLabel, string elseLabel) {
        int testReg = this.nextReg;
        auto lli32 = LLVMInt32TypeInContext(this.mod.context);
        auto llZero = LLVMConstNull(lli32);
        auto llIcmp = LLVMBuildICmp(this.builder, LLVMIntNE, llReg(reg), llZero, "reg$testReg".toStringz);
        LLVMBuildCondBr(this.builder, llIcmp, llLabel(thenLabel), llLabel(elseLabel));
        this.blockId += 1;
    }
    override void switch_(int reg, (int value, string label, bool unlikely)[] targets, string defaultTarget) {
        auto lli32 = LLVMInt32TypeInContext(this.mod.context);
        auto switchInstr = LLVMBuildSwitch(
            this.builder, llReg(reg), llLabel(defaultTarget), cast(int) targets.length);
        mut LLVMMetadataRef[] branchWeightsMetadata;
        branchWeightsMetadata ~= LLVMMDStringInContext2(this.mod.context, "branch_weights", "branch_weights".length);
        branchWeightsMetadata ~= intMetadata(1); // default target (TODO bool unlikely)
        for (target in targets) {
            LLVMAddCase(switchInstr, LLVMConstInt(lli32, target.value, false), llLabel(target.label));
            branchWeightsMetadata ~= intMetadata(1 if target.unlikely else 1000);
        }
        auto prof = LLVMGetMDKindIDInContext(this.mod.context, "prof", cast(int) "prof".length);
        auto node = LLVMMDNodeInContext2(
            this.mod.context, branchWeightsMetadata.ptr, cast(int) branchWeightsMetadata.length);
        LLVMSetMetadata(switchInstr, prof, LLVMMetadataAsValue(this.mod.context, node));
        this.blockId += 1;
    }
    private LLVMMetadataRef intMetadata(int i) {
        return LLVMValueAsMetadata(LLVMConstInt(LLVMInt32TypeInContext(this.mod.context), i, false));
    }
    override int materialize(BackendType backendType, int source) {
        if (llRegIsTransparentPtr(source)) {
            int reg = this.nextReg;
            auto llLoad = llReg(source);
            this.defReg2(reg, backendType, llLoad);
            return reg;
        }
        return source;
    }
    override int phi(BackendType backendType, (string pred, int reg)[] sources) {
        if (backendType.size == 0) {
            // fake reg
            return this.defReg(backendType, null);
        }
        auto phiType = this.mod.translate(backendType, false);
        int reg = this.nextReg;
        auto llPhi = LLVMBuildPhi(this.builder, phiType, "reg$reg".toStringz);
        for (source in sources) {
            auto def = this.regDefines.reg(source.reg);
            if (!def.type.same(backendType)) {
                .print("type violation in phi node: $backendType, but passed $(def.type)");
                assert(false);
            }
            mut auto sourceBlock = llLabel(source.pred);
            mut auto sourceReg = llReg(source.reg);
            LLVMAddIncoming(llPhi, &sourceReg, &sourceBlock, 1);
        }
        this.defReg2(reg, backendType, llPhi);
        return reg;
    }
    override void done() {
        LLVMBuildBr(this.entryBuilder, llLabel("first"));
    }
}

bool isPointer(BackendType type) {
    return type.instanceOf(BackendPointerType) || type.instanceOf(BackendFunctionPointerType);
}
