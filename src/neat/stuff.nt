// TODO distribute into more appropriate modules
module neat.stuff;

// IMPORTANT
// Never import this module in macros! It's too big!
macro import package(compiler).std.macro.hash;
macro import package(compiler).std.macro.listcomprehension;
macro import package(compiler).std.macro.once;
macro import package(compiler).std.macro.quasiquoting;

import backend.base;
import helpers;
import neat.array;
import neat.base;
import neat.bottom;
import neat.class_;
import neat.decl;
import neat.delegate_;
import neat.either;
import neat.enums;
import neat.expr;
import neat.float;
import neat.formatstring;
import neat.function_;
import neat.hash;
import neat.hashmap;
import neat.heap_closures;
import neat.lambda;
import neat.lexer;
import neat.parser;
import neat.pragmas;
import neat.quasiquoting;
import neat.runtime : die;
import neat.statements;
import neat.struct_;
import neat.templ;
import neat.ternary;
import neat.traits;
import neat.tuples;
import neat.types;
import neat.union_;
import neat.unittest_;
import neat.util;
import neat.vectors;
import neat.with_;
import neat.workpool : ReadFileTask;
import package(compiler).std.thread;
import polyhash;

// TODO clear all this up
class DefineClassIntf : FinishedSymbol
{
    (Class | Intf) obj;

    this(this.obj) { }

    override void emit(Generator generator)
    {
        obj.case {
            Class class_: class_.define(generator);
            Intf intf: intf.define(generator);
        }
    }

    override void hash(Hash hash)
    {
        this.obj.case {
            Class class_: {
                // FIXME nested function mangling
                void mangle1(typeof(class_.vtable[0]) entry) {
                    entry.case {
                        ClassMethod method: hash.adds(method.mangle);
                        IntfMethod method: hash.adds(method.mangle);
                        (:baseOffset, size_t offset): hash.addl(offset);
                    }
                }
                // only the actual vtable symbol, the methods are also hashed separately
                [mangle1(method) for method in class_.vtable];
            }
            Intf intf: {
                void mangle2(typeof(intf.vtable[0]) entry) {
                    entry.case {
                        IntfMethod method: hash.adds(method.mangle);
                        (:baseOffset): hash.adds("baseOffset");
                    }
                }
                // only the actual vtable symbol, the methods are also hashed separately
                [mangle2(method) for method in intf.vtable];
            }
        }
    }
}

(nullable ASTSymbol | Error) parseType(Parser parser, LexicalContext lexicalContext)
with (parser.transaction)
{
    mut ASTSymbol current = parser.parseLeafType(lexicalContext)?? else return null;
    while (true) {
        auto from = parser.from;
        if (parser.acceptToken(TokenType.asterisk)) {
            current = new ASTPointer(current, parser.to(from));
            continue;
        }
        with (parser.transaction) {
            string identifier = parser.parseIdentifier;
            if (identifier == "function" || identifier == "delegate") {
                mut bool copyable = true;
                if (parser.acceptToken(TokenType.exclamationmark))
                    copyable = false;
                parser.expectToken(TokenType.lparen)?;
                mut ASTSymbol[] args;
                while (!parser.acceptToken(TokenType.rparen)) {
                    if (args.length) {
                        if (!parser.acceptToken(TokenType.comma))
                            return parser.fail("',' or ')' expected");
                    }
                    auto argType = parser.parseType(lexicalContext)?;

                    args ~= argType? else die;
                }
                if (identifier == "function") {
                    parser.assert_(copyable, "cannot mark function noncopyable")?;
                    current = new ASTFunctionPointer(current, args, parser.to(from));
                } else {
                    current = new ASTDelegate(current, copyable, args, parser.to(from));
                }
                commit;
                continue;
            }
        }

        with (parser.transaction) {
            /**
             * Two kinds of mutable:
             *
             * mut T mut[] foo;
             * foo ~= T(); // mut T[] - the array value is mutable
             * foo[0] = T(); // T mut[] - the array elements are mutable
             */
            bool arrayIsMutable = parser.acceptIdentifier("mut");
            if (parser.acceptToken(TokenType.lsquarebracket)) {
                if (parser.acceptToken(TokenType.rsquarebracket)) {
                    current = new ASTArray(current, arrayIsMutable, parser.to(from));
                    commit;
                    continue;
                }
                // hashmap? might be assignment intro
                auto keyType = parser.parseType(lexicalContext)?? else return null;
                if (!parser.acceptToken(TokenType.rsquarebracket)) {
                    return null;
                }
                current = new ASTHashMap(key=keyType, value=current, parser.to(from));
                commit;
                continue;
            }
        }
        // what about templates that don't contain types? instead of duplicating this,
        // there should be a function to parse an ast symbol and that symbol should
        // be able to compile to a Type (Symbol).
        // But for now, templates only have types.
        // (this will also be needed to have things like Foo.Bar for nested types.)
        with (parser.transaction) {
            auto instanceFrom = parser.from;
            // TODO better way to exclude all the negated operators
            if (parser.acceptToken(TokenType.exclamationmark)
                && !parser.acceptToken(TokenType.equal) && !parser.acceptIdentifier("is"))
            {
                mut ASTSymbol[] templateArgs;
                (void | Error) getTemplateArg(bool short_) {
                    if (short_) {
                        auto from = parser.from;
                        auto templateArg = parser.parseIdentifier;
                        auto locRange = parser.to(from);
                        parser.assert_(templateArg != "", "template argument expected")?;
                        templateArgs ~= lexicalContext.compiler.astIdentifier(templateArg, locRange);
                    } else {
                        auto templateArg = lexicalContext.compiler.parseType(parser, lexicalContext)??
                            else return parser.fail("template argument expected");
                        templateArgs ~= templateArg;
                    }
                }

                if (parser.acceptToken(TokenType.lparen)) {
                    // ( [a [, a]*]? )
                    if (!parser.acceptToken(TokenType.rparen)) {
                        getTemplateArg(false)?;
                        while (!parser.acceptToken(TokenType.rparen)) {
                            parser.expectToken(TokenType.comma)?;
                            getTemplateArg(false)?;
                        }
                    }
                } else {
                    getTemplateArg(true)?;
                }
                current = new ASTTemplateInstance(current, templateArgs, parser.to(from));
                commit;
                continue;
            }
        }
        commit;
        return current;
    }
}

/**
 * Tuples:
 * - (int, float): int and float
 * - (int | float): int or float
 * - (int, int | int): (int and int) or int
 */
(nullable ASTSymbol | Error) parseTupleType(Parser parser, LexicalContext lexicalContext)
with (parser.transaction)
{
    parser.begin;
    auto from = parser.from;
    if (!parser.acceptToken(TokenType.lparen)) {
        parser.revert;
        return null;
    }
    parser.commit;
    mut ASTEitherDeclEntry[] declEntries;
    mut (string name, LocRange locRange, ASTSymbol sym)[] members;
    mut bool failAnnot = false;
    if (parser.acceptIdentifier("fail")) failAnnot = true;
    void flush() {
        assert(members.length > 0);

        if (members.length == 1 && members[0].name == "") {
            declEntries ~= ASTEitherDeclEntry(members[0].locRange, failAnnot, members[0].sym);
        } else {
            declEntries ~= ASTEitherDeclEntry(
                parser.to(from),
                failAnnot,
                new ASTTupleType([(a.name, a.sym) for a in members], parser.to(from)));
        }
        members = [];
        failAnnot = false;
    }
    while (!parser.acceptToken(TokenType.rparen)) {
        if (members.length) {
            mut bool tuplesep, eithersep;
            if (parser.acceptToken(TokenType.comma)) tuplesep = true;
            else if (parser.acceptToken(TokenType.bar)) eithersep = true;
            else {
                // be a bit lenient for (bla bla)
                if (members.length == 1) {
                    return null;
                }
                return parser.to(from).fail("tuple: ',' or '|' expected");
            }
            if (eithersep) {
                flush;
                if (parser.acceptIdentifier("fail")) failAnnot = true;
            }
        }
        auto from = parser.from;
        auto type = parser.parseType(lexicalContext)?;
        if (!type) {
            // (bla bla) still
            if (members.length <= 1) {
                return null;
            }
            return parser.to(from).fail("tuple: type expected");
        }
        string name = parser.parseIdentifier;
        members ~= (name, parser.to(from), type? else die);
    }
    if (parser.acceptToken(TokenType.lcurlybracket) || parser.acceptToken2(TokenType.equal, TokenType.greater)) {
        // oh wait, it's a lambda :(
        return null;
    }

    if (members.empty) {
        return parser.to(from).fail("tuple: members expected");
    }
    flush;
    commit;
    if (declEntries.length == 1) return declEntries[0].symbol;
    return new ASTEitherDecl(declEntries);
}

(nullable ASTSymbol | Error) parseLeafType(Parser parser, LexicalContext lexicalContext)
{
    import package(compiler).std.string : startsWith;

    auto from = parser.from;
    if (parser.acceptIdentifier("nullable")) {
        auto locRange = parser.to(from);
        auto next = parseLeafType(parser, lexicalContext)?;
        return new ASTNullable(next? else die, true, locRange);
    }
    if (parser.acceptIdentifier("nonnullable")) {
        auto locRange = parser.to(from);
        auto next = parseLeafType(parser, lexicalContext)?;
        return new ASTNullable(next? else die, false, locRange);
    }

    {
        auto typeMacroArgs = new TypeMacroArgs(parser, lexicalContext);
        lexicalContext.macroState.applyMacro(typeMacroArgs);
        if (ASTSymbol ret = typeMacroArgs.astType?) return ret;
    }

    // must be before any () parsing for types we may add.
    if (auto symbol = parser.parseTupleType(lexicalContext)?) return symbol;

    with (parser.transaction) {
        if (parser.acceptIdentifier("Vector") && parser.acceptToken(TokenType.lparen)) {
            auto element = lexicalContext.compiler.parseType(parser, lexicalContext)??
                else return parser.fail("element type expected");
            parser.expectToken(TokenType.comma)?;
            auto count = lexicalContext.compiler.parseExpression(parser, lexicalContext)?
                .(that? else return parser.fail("number expected"));
            parser.expectToken(TokenType.rparen)?;
            commit;
            return new ASTVectorType(element, count, parser.to(from));
        }

        if (parser.acceptIdentifier("typeof"))
        {
            parser.expectToken(TokenType.lparen)?;
            auto expr = lexicalContext.compiler.parseExpression(parser, lexicalContext)??
                else return parser.fail("expression expected");
            parser.expectToken(TokenType.rparen)?;
            commit;
            return new ASTTypeof(expr, parser.to(from));
        }

        if (parser.acceptToken(TokenType.colon)) {
            string symbolIdentifier = parser.parseIdentifier;
            if (symbolIdentifier != "") {
                commit;
                return new ASTSymbolIdentifier(symbolIdentifier);
            }
        }
    }
    with (parser.transaction) {
        bool quoted = parser.acceptToken(TokenType.dollar);
        string identifier = parser.parseIdentifier;

        if (identifier == "" || parser.isKeyword(identifier)) {
            return null;
        }
        commit;

        if (quoted) {
            if (identifier == "stmt") {
                // avoid `$stmt var;` colliding with var declaration syntax.
                return null;
            }
            auto subIdentifier = new ASTIdentifier(identifier, false, parser.to(from));
            auto token = lexicalContext.allocQuoteToken(subIdentifier, QuoteTokenCategory.symbol)?;
            return new ASTSymbolQuote(lexicalContext.quoteScope, token, parser.to(from));
        }

        auto loc = __RANGE__;
        if (identifier == "long")
            return once new ASTIdentifier("long", false, loc);
        if (identifier == "int")
            return once new ASTIdentifier("int", false, loc);
        if (identifier == "short")
            return once new ASTIdentifier("short", false, loc);
        if (identifier == "char")
            return once new ASTIdentifier("char", false, loc);
        if (identifier == "ubyte")
            return once new ASTIdentifier("ubyte", false, loc);
        if (identifier == "bool")
            return once new ASTIdentifier("bool", false, loc);
        if (identifier == "void")
            return once new ASTIdentifier("void", false, loc);
        if (identifier == "float")
            return once new ASTIdentifier("float", false, loc);
        if (identifier == "double")
            return once new ASTIdentifier("double", false, loc);
        if (identifier == "nullptr_t")
            return once new ASTIdentifier("nullptr_t", false, loc);
        if (identifier == "bottom")
            return once new ASTIdentifier("bottom", false, loc);

        return lexicalContext.compiler.astIdentifier(identifier, parser.to(from));
    }
}

class FuncPtrCall : Expression
{
    Expression funcPtr;

    Expression[] args;

    LocRange locRange;

    this(this.funcPtr, this.args, this.locRange=__CALLER__) {
        this.type = this.funcPtr.type.instanceOf(FunctionPointer).ret;
        // we take over the returned value
        this.info = ExprInfo(Lifetime.gifted);
    }

    override int emit(Generator output)
    {
        FunctionPointer type = this.funcPtr.type.instanceOf(FunctionPointer)? else die;

        if (type.params.length != this.args.length) {
            print("expected $(type.params.length) args, not $(this.args.length)");
            print("(this is a compiler error, that should have been caught beforehand)");
            assert(false);
        }

        auto regs = new int mut[](this.args.length);
        for (i, arg in this.args) {
            regs[i] = arg.emit(output);
        }
        return output.fun.callFuncPtr(
            type.emit(output.platform), this.funcPtr.emit(output), regs.freeze);
    }

    override void hash(Hash hash) {
        hash.adds("FuncPtrCall");
        funcPtr.hash(hash);
        hash.addl(args.length);
        [arg.hash(hash) for arg in args];
    }

    override string repr() { return "($(funcPtr.repr))(" ~ [join with ", " a.repr for a in args] ~ ")"; }
}

class WrapExpression : Expression
{
    nullable Statement pre;
    Expression value;
    nullable Statement post;

    this(this.pre, this.value, this.post) {
        this.type = value.type;
        this.info = value.info;
    }

    override int emit(Generator generator)
    {
        if (pre) pre.emit(generator);
        int result = value.emit(generator);
        if (post) post.emit(generator);
        return result;
    }

    override void hash(Hash hash) {
        hash.adds("WrapExpression");
        if (pre) pre.hash(hash);
        else hash.adds("null");
        value.hash(hash);
        if (post) post.hash(hash);
        else hash.adds("null");
    }

    override string repr() {
        if (pre && post) return "wrap($(pre.repr); $(value.repr); $(post.repr))";
        if (pre) return "wrap($(pre.repr); $(value.repr); -)";
        if (post) return "wrap(-; $(value.repr); $(post.repr))";
        return value.repr;
    }
}

/**
 * This type is a bit risky.
 * Because result is returned after post() is called,
 * `WrapReference` can leak the location of a value that
 * has no references. As such, it should only be used when
 * `reference` doesn't yield an address managed by `pre`/`post`.
 */
class WrapReference : Reference
{
    nullable Statement pre;
    Reference reference;
    nullable Statement post;

    this(this.pre, this.reference, this.post) {
        this.type = reference.type;
        this.info = reference.info;
        this.mutable = reference.mutable;
    }

    override int emit(Generator output)
    {
        int reg = this.emitLocation(output);

        return output.fun.load(this.type.emit(output.platform), reg);
    }

    override int emitLocation(Generator output)
    {
        if (pre) pre.emit(output);
        int result = reference.emitLocation(output);
        if (post) post.emit(output);
        return result;
    }

    override void hash(Hash hash) {
        hash.adds("WrapReference");
        if (pre) pre.hash(hash);
        else hash.adds("null");
        reference.hash(hash);
        if (post) post.hash(hash);
        else hash.adds("null");
    }

    override string repr() {
        if (pre && post) return "wrapRef($(pre.repr); $(reference.repr); $(post.repr))";
        if (pre) return "wrapRef($(pre.repr); $(reference.repr); -)";
        if (post) return "wrapRef(-; $(reference.repr); $(post.repr))";
        return reference.repr;
    }
}

(Expression | Error) call(Context context, ASTSymbol astTarget,
    ASTArgument[] astArgs, LocRange locRange, bool autoCall)
{
    if (auto astIdentifier = astTarget.instanceOf(ASTIdentifier)) {
        auto targetName = astIdentifier.name_;
        // built-ins
        // TODO __borrow, __leak, __take too
        if (targetName == "__hash") {
            locRange.assert(astArgs.length == 1, () => "__hash() expects one parameter")?;
            return hash(astArgs[0].sym, context, locRange);
        }
        if (targetName == "__moveEmplace") {
            locRange.assert(astArgs.length == 2, () => "__moveEmplace() expects two parameters")?;
            auto source = astArgs[0].sym.compile(context)?.beExpressionImplCall(context, astArgs[0].locRange)?;
            auto dest = astArgs[1].sym.compile(context)?.beExpressionImplCall(context, astArgs[1].locRange)?;
            auto source = expectImplicitConvertTo(context, source, dest.type, astArgs[0].locRange)?;
            return new StatementExpression(
                moveEmplace(context, source=source, target=dest, locRange)?,
                new VoidExpression,
                ExprInfo(Lifetime.none),
            );
        }
        if (targetName == "__copyEmplace") {
            locRange.assert(astArgs.length == 2, () => "__copyEmplace() expects two parameters")?;
            auto source = astArgs[0].sym.compile(context)?.beExpressionImplCall(context, astArgs[0].locRange)?;
            auto dest = astArgs[1].sym.compile(context)?.beExpressionImplCall(context, astArgs[1].locRange)?;
            auto source = expectImplicitConvertTo(context, source, dest.type, astArgs[0].locRange)?;
            return new StatementExpression(
                copyEmplace(context, source=source, target=dest, locRange)?,
                new VoidExpression,
                ExprInfo(Lifetime.none),
            );
        }
    }
    context.assert2(!!context.namespace, locRange, "namespace not set; cannot call here")?;
    if (!autoCall) {
        auto callMacroArgs = once new CallMacroArgs;
        callMacroArgs.set(astTarget, astArgs, context, locRange);
        context.macroState.applyMacro(callMacroArgs);
        if (auto transformed = callMacroArgs.transformed?) return transformed;

        /// Direct implementation of `foo.bar(baz)`.
        /// Reduces need for `LateSymbol`.
        if (auto memberAccess = astTarget.instanceOf(ASTMemberBase)) {
            auto base = memberAccess.base.compile(context)?;
            auto name = memberAccess.member.name(context.warmContext);
            if (auto type = base.instanceOf(Type)) {
                auto protection = type.protectionAt(context.namespace);
                if (auto ret = type.callMember(
                        context, null, name, astArgs, protection, memberAccess.locRange)?)
                    return ret;
            } else if (auto baseExpr = base.isExpressionImplCall(context, locRange)?) {
                auto protection = baseExpr.type.protectionAt(context.namespace);
                if (auto ret = baseExpr.type.callMember(
                        context, baseExpr, name, astArgs, protection, memberAccess.locRange)?)
                    return ret;
            }
        }
    }

    // This IFTI specialcasing is very skeevy
    mut uninitialized Symbol target;
    mut (:none | ASTSymbol[]) templateArgs = :none;
    bool iftiMode() return templateArgs != :none;

    if (auto astInstance = astTarget.instanceOf(ASTTemplateInstance)) {
        auto decl = astInstance.templateDecl.compile(context)?;
        if (auto scopeDecl = decl.instanceOf(ScopeBoundTemplateDecl)) {
            if (scopeDecl.latent.decl.eponymousFun(context.warmContext)) {
                target = decl;
                templateArgs = astInstance.types;
            }
        }
    }

    if (!iftiMode) {
        target = astTarget.compile(context)?;
        // TODO figure out how to fall through to this if ifti fails.
        if (!autoCall) {
            if (auto type_ = target.instanceOf(Type)) {
                if (auto ret = type_.call(context, locRange, astArgs)?)
                    return ret;
            }
            if (auto expr = target.instanceOf(Expression)) {
                if (auto ret = expr.type.callExpr(context, locRange, expr, astArgs)?)
                    return ret;
            }
        }
    }

    if (auto super_ = target.instanceOf(Super)) {
        target = super_.resolve(context)?;
    }

    if (auto overload = target.instanceOf(Overload)) {
        // TODO transpose macro!
        auto possibleCalls = [callResolved(context, target, astArgs, templateArgs, locRange, autoCall)?
            for target in overload.parts];
        auto matches = possibleCalls.pickMatches;
        // TODO this should also allow for classes of errors like wrong number of parameters - to be
        // *reported*, but still allow another overload to match.
        auto perfectMatches = [a for a in matches where a.quality == CallQuality.match];
        if (perfectMatches.length == 1) return perfectMatches[0].expr;
        locRange.assert(perfectMatches.length == 0, () => "multiple possible targets for call: $(overload.repr)")?;
        if (matches.length == 1) return matches[0].expr; // one matched with conversion
        locRange.assert(matches.length == 0, () => "multiple possible targets for call: $(overload.repr)")?;
        locRange.assert(false, () => "no overload matched call: $(overload.repr)")?;
    }

    callResolved(context, target, astArgs, templateArgs, locRange, autoCall)?.case {
        (Expression expr, CallQuality quality): return expr;
        (:argCastError, Error err): return err;
        (:mismatch, Error err): return err;
    }
}

// TODO: find a better way to metaprogram this!
(Expression expr, CallQuality quality)[] pickMatches(
    (Expression, CallQuality | :mismatch, Error | :argCastError, Error)[] args)
{
    mut (Expression expr, CallQuality quality)[] ret;
    for (arg in args) arg.case {
        (Expression, CallQuality) match: ret ~= match;
        (:argCastError, Error): {} // TODO report errors better
        (:mismatch, Error): {}
    }
    return ret;
}

(Expression, CallQuality | (:mismatch, Error) | (:argCastError, Error) | Error) callResolved(
    Context context, mut Symbol target, ASTArgument[] astArgs, (ASTSymbol[] | :none) astTemplateArgs,
    LocRange locRange, bool autoCall)
{
    if (auto templ = target.instanceOf(ScopeBoundTemplateDecl)) {
        ASTSymbol[] astStubArgs = astTemplateArgs.case(ASTSymbol[] sym: sym, :none: null);
        Type[] stubArgs = [a.compile(context)?.beType(a.locRange)? for a in astStubArgs];
        auto args = [
            arg.sym.compile(context)?.beExpressionImplCall(context, locRange)?
            for arg in astArgs];
        Type[] argTypes = [arg.type for arg in args];
        auto templateDecl = templ.latent.decl;
        if (auto astFun = templateDecl.eponymousFun(context.warmContext)) {
            context.pushErrorLoc(locRange);
            auto inferTemplateArgs = .inferTemplateArgs(
                templateDecl, stubArgs, astFun.params, argTypes, context.errorStack);
            context.popErrorLoc;
            Type[] inferredTypes = inferTemplateArgs.case((:resolveError, Error err): return (:mismatch, err));
            // Some types, like Lambda, generate different types every time they're compiled.
            // So repackage the args we just compiled.
            auto repackagedArgs = [
                ASTArgument(new ASTSymbolHelper(arg), astArgs[i].name, astArgs[i].locRange)
                for i, arg in args];
            auto instance = templ.instantiate(context, locRange, inferredTypes)?;
            auto callExpr = call(context, new ASTSymbolHelper(instance), repackagedArgs, locRange, autoCall)?;

            return (callExpr, CallQuality.match);
        } else {
            return locRange.fail("cannot call: not a template function");
        }
    }

    astTemplateArgs.case {
        ASTSymbol[]: return locRange.fail("cannot instantiate non-template");
        :none: {}
    }

    mut nullable Statement pre, post;
    (Expression[] | Error) addLifetime(Expression[] args) {
        auto result = new Expression mut[](args.length);
        for (i in 0 .. args.length) {
            mut Expression arg = args[i];
            if (arg.info.lifetime == Lifetime.gifted) {
                auto temp = new PairedTemporaryExpr(arg.type, Lifetime.none, context.getUniqueId);
                // no copy() because we're taking ownership.
                auto set = new InitializeTemporaryExprStatement(temp, arg);
                // as we take it over, we have to clean up the gifted reference
                if (auto destructor = arg.type.endLifetime(context, temp)) {
                    pre = sequence2(pre, set);
                    post = sequence(destructor, post);
                    arg = temp;
                }
            } else if (arg.info.lifetime == Lifetime.ephemeral) {
                auto temp = new PairedTemporaryExpr(arg.type, Lifetime.none, context.getUniqueId);
                // copy! as it's ephemeral, we have no idea when it will disappear; it might
                // even be during the call!
                auto set = new InitializeTemporaryExprStatement(temp, arg.copy(context, astArgs[i].locRange)?);
                // as we copied, we have to clean up our reference.
                if (auto destructor = arg.type.endLifetime(context, temp)) {
                    pre = sequence2(pre, set);
                    post = sequence(destructor, post);
                    arg = temp;
                }
            }
            result[i] = arg;
        }
        return result.freeze;
    }
    WrapExpression wrap(Expression call) {
        return new WrapExpression(pre, call, post);
    }

    if (auto lateSym = target.instanceOf(LateSymbol)) {
        mut CallQuality quality = CallQuality.match;
        auto result = lateSym.resolve(context);
        auto funcPtr = result.funcPtr;

        if (auto setup = result.setup) pre = sequence2(pre, setup);
        if (auto teardown = result.teardown) post = sequence(teardown, post);

        mut Expression[] args;

        if (auto funcPtr = funcPtr.type.instanceOf(FunctionPointer)) {
            auto result = validateCall(
                context, funcPtr.params[1 .. $], astArgs, "function pointer", variadic=false, locRange
            )?.case(
                (:argCastError, Error err): return (:argCastError, err),
                (:mismatch, Error err): return (:mismatch, err));
            args = result.args.addLifetime?;
            quality = result.quality;
        } else {
            return locRange.fail("function reference or funcptr expected? but is '$(funcPtr.type.repr)'");
        }
        mut Expression[] combinedArgs;
        combinedArgs ~= result.firstArg;
        combinedArgs ~= args;
        auto fpCall = new FuncPtrCall(funcPtr, combinedArgs, locRange);

        return (wrap(fpCall), quality);
    }

    if (auto fundecl = target.instanceOf(FunctionDeclaration)) {
        auto result = validateCall(context, fundecl.params, astArgs, "", variadic=fundecl.variadic, locRange)?
            .case(
                (:argCastError, Error err): return (:argCastError, err),
                (:mismatch, Error err): return (:mismatch, err));
        return (wrap(new Call(fundecl, result.args.addLifetime?, locRange)), result.quality);
    }
    if (autoCall) return (:mismatch, locRange.fail("cannot call"));
    nullable Expression expr = target.instanceOf(Expression);
    // TODO
    // auto funcptr = expr?.type.instanceOf(FunctionPointer).else(null);
    auto funcptr = expr.case(Expression e: e.type.instanceOf(FunctionPointer));
    if (expr && funcptr) {
        auto result = validateCall(context, funcptr.params, astArgs, "", variadic=false, locRange)?.case(
            (:argCastError, Error err): return (:argCastError, err),
            (:mismatch, Error err): return (:mismatch, err));
        return (wrap(new FuncPtrCall(expr? else die, result.args.addLifetime?, locRange)), result.quality);
    }
    mut nullable Delegate nestedfuncptr;
    if (expr) nestedfuncptr = expr.type.instanceOf(Delegate);
    if (expr && nestedfuncptr) {
        auto expr = expr? else die;
        auto params = [Parameter.fromType(type) for type in nestedfuncptr.params];
        auto result = validateCall(context, params, astArgs, "", variadic=false, locRange)?.case(
            (:argCastError, Error err): return (:argCastError, err),
            (:mismatch, Error err): return (:mismatch, err));
        // TODO cache delegate
        auto funcPtr = new DelegateFuncPtr(expr);
        auto thisPtr = new DelegateDataPtr(expr);
        mut Expression[] combinedArgs;
        combinedArgs ~= thisPtr;
        combinedArgs ~= result.args.addLifetime?;
        return (wrap(new FuncPtrCall(funcPtr, combinedArgs, locRange)), result.quality);
    }
    return locRange.fail("cannot call $(target.repr)");
}

/**
 * Implements IFTI.
 */
(Type[] | :resolveError, Error err) inferTemplateArgs(
    ASTTemplateDecl templateDecl, Type[] stubArgs, ASTParameter[] astParams, Type[] args, LocRange[] errorStack)
{
    mut (Type | :unknown)[string] assignments;

    for (i, param in templateDecl.typeParameterNames) {
        if (i < stubArgs.length) assignments[param] = stubArgs[i];
        else assignments[param] = :unknown;
    }

    if (args.length > astParams.length) return (:resolveError, new Error(errorStack, "too many arguments"));
    (void | Error) tryInfer(ASTSymbol sym, Type type) {
        // print("tryInfer($(sym.repr), $(type.repr))");
        if (auto ident = sym.instanceOf(ASTIdentifier)) if (!ident.moduleLevel) {
            if (!assignments.has(ident.name_)) return;
            assignments[ident.name_] = assignments[ident.name_].case(
                :unknown: type,
                Type existing: existing.mergeTypes(type).case(:failure: return new Error(
                    errorStack ~ sym.locRange, "incompatible types '$(existing.repr)' and '$(type.repr)'")));
            return;
        }
        if (auto astNullable = sym.instanceOf(ASTNullable)) if (astNullable.nullify) {
            if (auto classType = type.instanceOf(ClassType)) if (classType.zeroInitializable) {
                return tryInfer(astNullable.next, classType.makeNotNullable);
            }
            if (auto intfType = type.instanceOf(IntfType)) if (intfType.zeroInitializable) {
                return tryInfer(astNullable.next, intfType.makeNotNullable);
            }
            return;
        }
        if (auto astDelegate = sym.instanceOf(ASTDelegate)) {
            if (auto delegate_ = type.instanceOf(Delegate)) {
                if (astDelegate.params.length != delegate_.params.length)
                    return new Error(errorStack ~ sym.locRange, "parameter count doesn't match");
                if (astDelegate.copyable != delegate_.copyable)
                    return new Error(errorStack ~ sym.locRange, "'!' doesn't match");
                tryInfer(astDelegate.ret, delegate_.ret)?;
                for (i, param in astDelegate.params) {
                    tryInfer(param, delegate_.params[i])?;
                }
            }
        }
        if (auto astArray = sym.instanceOf(ASTArray)) {
            if (auto arrayType = type.instanceOf(Array)) {
                return tryInfer(astArray.elementType, arrayType.elementType);
            }
            return;
        }
        return;
    }
    for (i, arg in args) {
        auto astParamType = astParams[i].type;
        tryInfer(astParamType, arg).case(Error err: return (:resolveError, err));
    }

    mut Type[] inferredTemplateArgs;
    for (param in templateDecl.typeParameterNames) {
        assignments[param].case {
            // FIXME "return not found" without the {}
            :unknown: {
                return (:resolveError, new Error(
                    errorStack, "failed to infer template parameter '$param'"));
            }
            Type t: inferredTemplateArgs ~= t;
        }
    }

    return inferredTemplateArgs;
}

// TODO can we use util.TypeMerger here?
(Type | fail :failure) mergeTypes(Type first, Type second) {
    if (first.same(second)) return first;
    // TODO conversion
    return :failure;
}

class ASTCall : ASTSymbol
{
    ASTSymbol target;

    ASTArgument[] args;

    this(this.target, this.args, this.locRange=__CALLER__) { }

    override (Expression | Error) compile(Context context)
    {
        mut ASTSymbol target = this.target;
        /**
         * UFCS rewriting:
         * foo.bar(baz)
         * => bar(foo, baz)
         */
        if (auto astMember = target.instanceOf(ASTMember)) {
            auto base = astMember.base.compile(context)?;
            if (auto target = astMember.checkUfcs(context, base)?) {
                // rewrite foo.bar(baz) to bar(foo, baz)
                auto args = [ASTArgument(astMember.base, "", astMember.locRange)] ~ this.args;
                return (new ASTCall(target, args, this.locRange)).compile(context);
            }
            // rebuild AST with compiled base
            target = new ASTMember(
                new ASTSymbolHelper(base, astMember.base.locRange), astMember.member, astMember.locRange);
        }
        /**
         * UFCS rewriting:
         * foo.bar!baz(whee)
         * => bar!baz(foo, whee)
         */
        else if (auto astInstance = target.instanceOf(ASTTemplateInstance)) {
            if (auto astMember = astInstance.templateDecl.instanceOf(ASTMember)) {
                auto base = astMember.base.compile(context)?;
                if (auto target = astMember.checkUfcs(context, base)?) {
                    auto reinstance = new ASTTemplateInstance(target, astInstance.types, astInstance.locRange);
                    auto args = [ASTArgument(astMember.base, "", astMember.locRange)] ~ this.args;
                    return (new ASTCall(reinstance, args, this.locRange)).compile(context);
                }
                // rebuild AST with compiled base
                auto rebuildAstMember = new ASTMember(
                    new ASTSymbolHelper(base, astMember.base.locRange), astMember.member, astMember.locRange);
                target = new ASTTemplateInstance(rebuildAstMember, astInstance.types, astInstance.locRange);
            }
        }

        return call(context, target, this.args, this.locRange, false)?;
    }

    override string repr() {
        return this.target.repr ~ "(" ~ [join with ", " a.sym.repr for a in this.args] ~ ")";
    }
}

(ASTArgument[] | Error) parseArgumentList(ParserImpl parser, LexicalContext lexicalContext)
{
    mut ASTArgument[] args;
    while (!parser.acceptToken(TokenType.rparen))
    {
        if (args.length > 0)
            parser.expectToken(TokenType.comma)?;
        // foo(a, b, c, )
        if (parser.acceptToken(TokenType.rparen)) break;

        auto from = parser.from;
        mut string name;
        with (parser.transaction) {
            string n = parser.parseIdentifier;
            if (n.length > 0 && parser.acceptToken2Not2(TokenType.equal, TokenType.equal, TokenType.greater)) {
                commit;
                name = n;
            }
        }
        ASTSymbol arg = parser.parseExpression(lexicalContext)??
            else return parser.to(from).fail("expression expected");
        args ~= ASTArgument(arg, name, parser.to(from));
    }
    return args;
}

(nullable ASTCall | Error) parseCall(ParserImpl parser, LexicalContext lexicalContext, ASTSymbol base)
with (parser.transaction)
{
    auto from = parser.from;
    if (!parser.acceptToken(TokenType.lparen))
        return null;
    mut ASTArgument[] args = parser.parseArgumentList(lexicalContext)?;
    commit;
    return new ASTCall(base, args, parser.to(from));
}

class ASTIndexAccess : ASTSymbol
{
    ASTSymbol base;

    ASTSymbol index;

    this(this.base, this.index, this.locRange=__CALLER__) { }

    override (Expression | Error) compile(Context context)
    {
        auto base = this.base.compile(context)?.beExpressionImplCall(context, this.locRange)?;
        return base.type.index(context, base, index=this.index, this.locRange)??
            else this.locRange.fail("$(base.type.repr) does not permit index access");
    }

    override (nullable Statement | Error) assign(Context context, Expression value) {
        auto base = this.base.compile(context)?.beExpressionImplCall(context, this.locRange)?;
        checkAssignmentQuarantine(context, this.locRange, base.type, value.type)?;
        return base.type.indexAssignment(context, base=base, index=index, value, this.locRange)? else null;
    }

    override string repr() => "$base[$index]";
}

class ASTArraySlice : ASTSymbol
{
    ASTSymbol array;

    ASTSymbol lower;

    ASTSymbol upper;

    this(this.array, this.lower, this.upper, this.locRange=__CALLER__) { }

    override (Symbol | Error) compile(Context context)
    {
        Type sizeT = context.nativeWordType;
        auto array = this.array.compile(context)?.beExpressionImplCall(context, this.locRange)?;
        auto arrayTemp = new PairedTemporaryExpr(array.type, Lifetime.none, context.getUniqueId);
        auto initTemp = new InitializeTemporaryExprStatement(arrayTemp, array);
        auto context = context.withNamespace(
            context.compiler.exprAlias(context.namespace, "__array", arrayTemp));
        auto slice = new ArraySlice(
            arrayTemp,
            expectImplicitConvertTo(
                context,
                this.lower.compile(context)?.beExpressionImplCall(context, this.locRange)?,
                sizeT, this.locRange)?,
            expectImplicitConvertTo(
                context,
                this.upper.compile(context)?.beExpressionImplCall(context, this.locRange)?,
                sizeT, this.locRange)?,
            this.locRange, context.platform);
        return new StatementExpression(initTemp, slice, array.info);
    }
}

(nullable ASTSymbol | Error) parseIndex(ParserImpl parser, LexicalContext lexicalContext, ASTSymbol base)
with (parser.transaction)
{
    auto from = parser.from;
    if (!parser.acceptToken(TokenType.lsquarebracket))
        return null;
    ASTSymbol index = parseExpression(parser, lexicalContext)??
        else return parser.to(from).fail("index expected");
    parser.expectToken(TokenType.rsquarebracket)?;
    commit;
    if (auto iota = index.instanceOf(ASTIota)) {
        return new ASTArraySlice(base, iota.from, iota.to, parser.to(from));
    }
    return new ASTIndexAccess(base, index, parser.to(from));
}

(nullable Symbol | Error) accessMember(
    Context context, Symbol base, string member, LocRange locRange, bool allowUndefined)
{
    if (!context.namespace) return null;

    if (auto type = base.instanceOf(Type)) {
        auto protection = type.protectionAt(context.namespace);
        return type.accessMember(context, null, member, protection, locRange);
    }

    if (auto super_ = base.instanceOf(Super)) {
        return super_.lookup(context, member, locRange);
    }

    mut Expression baseExpr = base.beExpressionImplCall(context, locRange)?;
    while (baseExpr.type.instanceOf(Pointer)) {
        baseExpr = new Dereference(baseExpr);
    }

    auto protection = baseExpr.type.protectionAt(context.namespace);
    if (auto field = baseExpr.type.accessMember(context, baseExpr, member, protection, locRange)?)
        return field;

    if (allowUndefined) return null;
    return locRange.fail("$(baseExpr.type.repr): no such field '$member'");
}

class ASTMember : ASTMemberBase
{
    override (Symbol | Error) compile(Context context)
    {
        /**
         * UFCS rewriting
         * foo.bar
         * => bar(foo)
         */
        auto base = this.base.compile(context)?;
        if (auto target = checkUfcs(context, base)?) {
            // bar(foo)
            auto args = [ASTArgument(new ASTSymbolHelper(base, this.base.locRange), "", this.locRange)];
            return (new ASTCall(target, args, this.locRange)).compile(context);
        }

        auto name = this.member.name(context.warmContext);
        if (auto ret = accessMember(context, base, name, this.locRange, false)?) {
            return ret;
        }
        return this.locRange.fail("Member '$(name)' not found");
    }

    override (nullable Statement | Error) assign(Context context, Expression value) {
        auto base = this.base.compile(context)?.beExpressionImplCall(context, this.locRange)?;
        auto protection = base.type.protectionAt(context.namespace);
        auto memberName = this.member.name(context.warmContext);
        checkAssignmentQuarantine(context, this.locRange, base.type, value.type)?;
        return base.type.assignMember(context, base, memberName, value, protection, this.locRange)?;
    }
}

(nullable ASTMember | Error) parseMember(Parser parser, LexicalContext lexicalContext, ASTSymbol base)
{
    parser.begin;
    // don't accept '..' or '.(': conflicting syntax
    if (parser.acceptToken2(TokenType.dot, TokenType.dot)
        || parser.acceptToken2(TokenType.dot, TokenType.lparen)
        || !parser.acceptToken(TokenType.dot))
    {
        parser.revert;
        return null;
    }
    auto from = parser.from;
    auto name = parser.parseIdentifierSymbol(lexicalContext)??
        else return parser.fail("member expected");
    parser.commit;
    return new ASTMember(base, name, parser.to(from));
}

class ParenPropertyNamespace : Namespace
{
    Expression frame;

    Symbol value;

    this(this.parent, this.frame, this.value) { this.isContextScope = parent.isContextScope; }

    override (nullable Symbol | Error) lookup(
        string name, Context context, LookupReason reason, LocRange locRange)
    {
        if (name == "that") {
            mut Symbol result = value;
            if (auto latent = this.value.instanceOf(LatentSymbol)) {
                result = latent.resolve(context.framePointer, context.frameDepth, locRange)?;
            }
            if (auto result = result.instanceOf(Expression)) {
                assert(result.info.lifetime != Lifetime.gifted);
                if (result.info.lifetime != Lifetime.ephemeral) return result;
                // Ephemeral 'that', usually a temporization of a gifted expr: leak our caller a reference.
                auto copiedRes = new PairedTemporary(result.type, Lifetime.gifted, context.getUniqueId);
                auto initCopy = new UninitializeTemporaryStatement(copiedRes);
                auto fillCopy = new AssignStatement(copiedRes, result.copy(context, locRange)?, locRange);
                return new StatementExpression(sequence(initCopy, fillCopy), copiedRes, false);
            }
            return result;
        }
        if (auto ret = accessMember(
            context.withFramePointer(this.frame, :none), value, name, locRange, allowUndefined=true)?)
        {
            return ret;
        }

        if (this.parent) return this.parent.lookup(name, context, reason, locRange);
        return null;
    }

    override string repr() => "ParenPropertyNamespace";
}

class ASTParenPropertyExpression : ASTSymbol
{
    ASTSymbol base;

    ASTSymbol prop;

    this(this.base, this.prop, this.locRange=__CALLER__) { }

    override (Symbol | Error) compile(Context context) {
        auto sym = this.base.compile(context)?;
        if (auto type = sym.instanceOf(Type)) {
            // Type.() accesses static members
            auto context = context.withNamespace(
                new WithTypeNamespace(context.namespace, type, this.locRange));
            return this.prop.compile(context)?.beExpressionImplCall(context, this.locRange);
        }
        auto baseExpr = sym.beExpressionImplCall(context, this.locRange)?;
        (Expression | Error) do1(Expression baseExpr) {
            assert(!!context.framePointer);
            auto context = context.withNamespace(
                new ParenPropertyNamespace(context.namespace, context.framePointer? else die, baseExpr));
            return this.prop.compile(context)?.beExpressionImplCall(context, this.locRange);
        }
        return context.compiler.consume(context, baseExpr, &do1);
    }

    override string repr() {
        return "$(this.base.repr).($(this.prop.repr))";
    }
}

(nullable ASTParenPropertyExpression | Error) parseParenPropertyExpression(
    Parser parser, LexicalContext lexicalContext, ASTSymbol base
) {
    parser.begin;
    auto from = parser.from;
    // don't accept '..'
    if (parser.acceptToken2(TokenType.dot, TokenType.dot)
        || !parser.acceptToken(TokenType.dot)
        || !parser.acceptToken(TokenType.lparen))
    {
        parser.revert;
        return null;
    }
    auto sym = parseTupleBody(parser, lexicalContext, allowOneSized=true, from)??
        else return parser.fail("expression or tuple expected");
    parser.commit;
    return new ASTParenPropertyExpression(base, sym, parser.to(from));
}

class ASTPropagateFailureExpr : ASTSymbol
{
    ASTSymbol base;

    this(this.base, this.locRange=__CALLER__) { }

    override (Symbol | Error) compile(Context context) {
        (Expression | Error) base() {
            auto base = this.base.compile(context)?.beExpressionImplCall(context, this.locRange)?;
            if (auto eitherIntf = base.type.instanceOf(CanTreatAsEither)) {
                if (auto eitherExpr = eitherIntf.toEitherType(context, base)?)
                    return eitherExpr;
            }
            if (auto classType = base.type.instanceOf(ClassType)) if (classType.class_.errorclass) {
                // hack: create a placeholder one-entry Either type so we can strip out the class so bottom remains.
                return new EitherExpr(new Either([(false, base.type)]), base, 0);
            }
            return base;
        }
        auto base = base?;
        auto either = base.type.instanceOf(Either);
        context.assert2(!!either, this.locRange, "base of '?' must be sumtype")?;
        mut ASTEitherCaseExprCase[] cases;
        mut bool anyNonlocalExits = false;
        for (k, v in either.types) {
            ASTSymbol expr() {
                auto a = new ASTIdentifier("a", false);
                if (v.fail) {
                    anyNonlocalExits = true;
                    return new ASTReturn(a, this.locRange);
                }
                if (auto class_ = v.type.instanceOf(ClassType)) if (class_.class_.errorclass) {
                    anyNonlocalExits = true;
                    return new ASTReturn(a, this.locRange);
                }
                if (v.type.instanceOf(SymbolIdentifierType)?.name == "else") {
                    anyNonlocalExits = true;
                    return new ASTBreakElse(this.locRange);
                }
                if (v.type.instanceOf(NullPointer)) {
                    anyNonlocalExits = true;
                    return new ASTBreakElse(this.locRange);
                }
                return a;
            }
            cases ~= ASTEitherCaseExprCase(
                this.locRange,
                new ASTSymbolHelper(v.type),
                "a",
                fail=v.fail,
                expr=expr,
            );
        }
        context.assert2(anyNonlocalExits, this.locRange, "'?' had no effect")?;
        auto caseExpr = new ASTEitherCaseExpr(__RANGE__, new ASTSymbolHelper(base), cases);
        caseExpr.singleUse = true;
        context.pushErrorLoc(this.locRange);
        auto ret = caseExpr.compile(context);
        context.popErrorLoc;
        return ret;
    }

    override string repr() { return this.base.repr ~ "?"; }
}

(nullable ASTSymbol | Error) parsePropagate(Parser parser, LexicalContext context, ASTSymbol left)
{
    auto from = parser.from;
    if (!parser.acceptToken(TokenType.questionmark)) {
        return null;
    }
    return new ASTPropagateFailureExpr(left, parser.to(from));
}

(nullable ASTSymbol | Error) parseProperties(ParserImpl parser, LexicalContext lexicalContext)
{
    mut (:inc | :dec | :none) preincdec = :none, postincdec = :none;
    auto fromPre = parser.from;
    if (parser.acceptToken2(TokenType.minus, TokenType.minus)) preincdec = :dec;
    else if (parser.acceptToken2(TokenType.plus, TokenType.plus)) preincdec = :inc;
    auto toPre = parser.to(fromPre);

    mut ASTSymbol current = parseExpressionBase(parser, lexicalContext)?? else return null;

    while (true) {
        if (ASTSymbol instanceOf = parser.parseInstanceOf(lexicalContext, current)?) {
            current = instanceOf;
            continue;
        }
        auto macroArgs = new ParsePropertyArgs(parser, lexicalContext, current);

        (void | Error) doMacro() {
            lexicalContext.macroState.applyMacro(macroArgs);
            macroArgs.result?;
        }
        parser.verifyTransactions("macro parse rule imbalance", &doMacro)?;

        if (ASTSymbol result = macroArgs.result?) {
            current = result;
            continue;
        }

        if (ASTSymbol caseExpr = parser.parseCaseExpr(lexicalContext, current)?) {
            current = caseExpr;
            continue;
        }
        if (ASTSymbol call = parser.parseCall(lexicalContext, current)?) {
            current = call;
            continue;
        }
        if (ASTSymbol propagateExpr = parser.parsePropagate(lexicalContext, current)?) {
            current = propagateExpr;
            continue;
        }
        if (ASTSymbol prop = parser.parseParenPropertyExpression(lexicalContext, current)?) {
            current = prop;
            continue;
        }
        if (ASTSymbol memberAccess = parser.parseMember(lexicalContext, current)?) {
            current = memberAccess;
            continue;
        }
        if (ASTSymbol indexAccess = parser.parseIndex(lexicalContext, current)?) {
            current = indexAccess;
            continue;
        }
        if (ASTSymbol templateInstance = parser.parseTemplateInstantiation(lexicalContext, current)?) {
            current = templateInstance;
            continue;
        }
        break;
    }
    auto fromPost = parser.from;
    if (parser.acceptToken2(TokenType.minus, TokenType.minus)) postincdec = :dec;
    else if (parser.acceptToken2(TokenType.plus, TokenType.plus)) postincdec = :inc;
    auto toPost = parser.to(fromPost);
    if (preincdec != :none && postincdec != :none)
        return toPost.fail("cannot have both pre- and post-increment operator");
    current = preincdec.case(
        :inc: new ASTPrePostIncDec((:pre, :inc), current, toPre),
        :dec: new ASTPrePostIncDec((:pre, :dec), current, toPre),
        :none: current);
    current = postincdec.case(
        :inc: new ASTPrePostIncDec((:post, :inc), current, toPost),
        :dec: new ASTPrePostIncDec((:post, :dec), current, toPost),
        :none: current);
    return current;
}

class ASTDereference : ASTSymbol
{
    ASTSymbol base;

    this(this.base, this.locRange=__CALLER__) { }

    override (Symbol | Error) compile(Context context)
    {
        auto ptr = this.base.compile(context)?.beExpression(this.locRange)?;
        this.locRange.assert(!!ptr.type.instanceOf(Pointer),
            () => "*expr: not a pointer, but a $(ptr.type.repr)")?;
        return new Dereference(ptr);
    }
}

class ASTReference : ASTSymbol
{
    ASTSymbol base;

    this(this.base, this.locRange=__CALLER__) { }

    override (Expression | Error) compile(Context context)
    {
        auto base = this.base.compile(context)?;
        // &function
        if (Function fun = base.instanceOf(Function))
            return new FunctionReference(fun);
        if (LateSymbol lateSym = base.instanceOf(LateSymbol)) {
            auto result = lateSym.resolve(context);
            auto firstArgCopy = result.firstArg.type.copy(context, result.firstArg, this.locRange)?;
            auto dg = new DelegateExpr(result.funcPtr, firstArgCopy, copyable=lateSym.refcounted);
            this.locRange.assert(result.teardown is null,
                () => "cannot take address: reference base requires cleanup")?;
            return new WrapExpression(result.setup, dg, result.teardown);
        }
        Reference baseRef = base.beExpression(this.locRange)?
            .instanceOf(Reference)? else return locRange.fail("&expr: expr not a reference");

        return new ReferenceExpression(baseRef);
    }
}

(nullable ASTSymbol | Error) parseExpressionLeaf(ParserImpl parser, LexicalContext lexicalContext)
{
    auto from = parser.from;
    // The parser.begin/commit/revert in this function does nothing.
    // Leave it in anyway - otherwise, you can cause stack overflow by
    // just repeatedly spamming * or &.
    parser.begin;
    if (parser.acceptToken(TokenType.asterisk)) {
        ASTSymbol next = parseExpressionLeaf(parser, lexicalContext)??
            else return parser.to(from).fail("expression expected");
        parser.commit;

        return new ASTDereference(next, parser.to(from));
    }
    if (parser.acceptToken(TokenType.ampersand)) {
        ASTSymbol next = parseExpressionLeaf(parser, lexicalContext)??
            else return parser.to(from).fail("expression expected");
        parser.commit;

        return new ASTReference(next, parser.to(from));
    }
    if (parser.acceptIdentifier("new")) {
        // new &nestfun
        if (parser.acceptToken(TokenType.ampersand)) {
            auto name = parser.parseIdentifier;
            parser.to(from).assert(name != "", () => "identifier expected")?;
            parser.commit;
            ASTSymbol next = new ASTIdentifier(name, moduleLevel=false, parser.to(from));
            return new ASTNewReference(next, parser.to(from));
        }
        if (auto result = parser.parseLambdaExpression(lexicalContext, heapAlloc=true)?) {
            parser.commit;
            return result;
        }
        auto type = parser.parseType(lexicalContext)??
            else return parser.to(from).fail("'new': type expected");
        parser.commit;

        mut ASTArgument[] args;
        if (parser.acceptToken(TokenType.lparen))
        {
            args = parseArgumentList(parser, lexicalContext)?;
        }

        return new ASTNewExpression(type, args, parser.to(from));
    }
    if (parser.acceptIdentifier("sizeof")) {
        parser.commit;
        parser.expectToken(TokenType.lparen)?;
        parser.begin;
        mut nullable ASTSymbol sym = lexicalContext.compiler.parseType(parser, lexicalContext)?;
        if (!sym || !parser.acceptToken(TokenType.rparen)) {
            parser.revert;
            parser.begin;
            sym = lexicalContext.compiler.parseExpression(parser, lexicalContext)?;
            parser.to(from).assert(!!sym, () => "expression expected")?;
            parser.expectToken(TokenType.rparen)?;
        }
        parser.commit;

        return new ASTSizeOf(sym? else die);
    }
    if (parser.acceptIdentifier("cast")) {
        parser.expectToken(TokenType.lparen)?;
        ASTSymbol target = parser.parseType(lexicalContext)??
            else return parser.to(from).fail("expression expected");
        parser.expectToken(TokenType.rparen)?;
        ASTSymbol value = parseExpressionLeaf(parser, lexicalContext)??
            else return parser.to(from).fail("expression expected");
        parser.commit;

        return new ASTCastExpr(target, value, parser.to(from));
    }
    parser.revert;
    if (auto trait = parser.parseTrait(lexicalContext)?) {
        return trait;
    }
    if (auto builtin = parser.parseBuiltin(lexicalContext)?) {
        return builtin;
    }
    if (auto lambda = parser.parseLambdaExpression(lexicalContext, heapAlloc=false)?) {
        return lambda;
    }
    if (auto tuple = parser.parseTupleExpression(lexicalContext)?) {
        return tuple;
    }
    if (auto nestfun = parser.parseNestedFunctionExpr(lexicalContext)?) {
        return nestfun;
    }
    if (auto sym = parseBreakCont(parser, lexicalContext)?)
        return sym;
    if (auto ret = parseReturn(parser, lexicalContext)?) {
        return ret;
    }
    parser.begin;
    if (parser.acceptToken(TokenType.exclamationmark)) {
        ASTSymbol next = parser.parseExpressionLeaf(lexicalContext)??
            else return parser.to(from).fail("expression expected");
        parser.commit;

        return new ASTNegation(next, parser.to(from));
    }
    if (parser.acceptToken2Not(TokenType.minus, TokenType.minus)) {
        ASTSymbol next = parser.parseExpressionLeaf(lexicalContext)??
            else return parser.to(from).fail("expression expected");
        parser.commit;

        return new ASTBinaryOp("-", new ASTNumberLiteral(0, parser.to(from)), next, parser.to(from));
    }
    parser.revert;
    if (auto expr = parseProperties(parser, lexicalContext)?)
        return expr;
    return null;
}

(string text, int size | fail :error, string) processChar(string text) {
    assert(!text.empty);
    if (text.front != '\\') {
        return (text[0 .. 1], 1);
    }
    if (text.length == 1)
        return (:error, "expected control character");
    char ctl = text[1];
    // TODO use char literals
    if (ctl == 'r') {
        return ("\r", 2);
    } else if (ctl == '$') {
        return ("\$", 2);
    } else if (ctl == 'n') {
        return ("\n", 2);
    } else if (ctl == 't') {
        return ("\t", 2);
    } else if (ctl == '"') {
        return ("\"", 2);
    } else if (ctl == '\'') {
        return ("'", 2);
    } else if (ctl == '\\') {
        return ("\\", 2);
    } else if (ctl == '0') {
        return ("\x00", 2); // TODO \0
    } else if (ctl == 'x') {
        if (text.length < 4) return (:error, "expected two-digit hex code");
        char ch1 = text[2], ch2 = text[3];
        (int | fail :error, string) decodeHex(char ch) {
            if (ch >= '0' && ch <= '9')
                return ch - '0';
            if (ch >= 'a' && ch <= 'f')
                return ch + 10 - 'a';
            if (ch >= 'A' && ch <= 'F')
                return ch + 10 - 'A';
            return (:error, "unknown hex digit '" ~ ch ~ "'");
        }
        return ("" ~ cast(char) (decodeHex(ch1)? * 16 + decodeHex(ch2)?), 4);
    } else {
        return (:error, "unknown control sequence \\$ctl");
    }
}

(string | (:error, string msg)) cleanup(mut string s) {
    mut string ret;
    while (!s.empty) {
        processChar(s).case {
            (:error, string msg):
                return (:error, msg);
            (string text, int size):
                ret ~= text;
                s = s[size .. $];
        }
    }
    return ret;
}

(ASTSymbol | Error) parseCharLiteral(
    Parser parser, LexicalContext lexicalContext)
{
    if (parser.hard_eof)
        return parser.fail("expected character, got end of file");

    auto from = parser.from;
    auto res = parser.acceptTokenStr(TokenType.charLiteral)
        .case(:none: return parser.fail("character expected"))
        .processChar
        .case((:error, string msg): return parser.fail(msg));
    if (!parser.acceptToken(TokenType.singleQuote))
        return parser.fail("closing quote expected");
    auto locRange = parser.to(from);
    return new ASTCharLiteral(res.text.front, locRange);
}

(ASTSymbol | Error) parseStringLiteral(ParserImpl parser, LexicalContext lexicalContext, TokenType literalToken)
{
    auto from = parser.from;
    if (parser.acceptToken(literalToken))
        return new ASTStringLiteral("", parser.to(from));
    mut string str = parser.acceptTokenStr(TokenType.stringLiteral)
        .case(:none: return parser.fail("lexer error: string literal should be here"));
    mut ASTSymbol[] parts;
    if (literalToken == TokenType.doubleQuote) {
        str = str.cleanup.case((:error, string msg): return parser.fail(msg));
    }
    parts ~= new ASTStringLiteral(str, parser.to(from));
    while (parser.acceptToken(TokenType.formatQuoteStart)) {
        if (parser.acceptToken(TokenType.lparen)) {
            auto litFrom = parser.from;
            ASTSymbol expr = parser.parseExpression(lexicalContext)??
                else return parser.to(litFrom).fail("Expression expected.");
            if (!parser.acceptToken(TokenType.rparen))
                return parser.fail("closing ')' expected");
            parts ~= expr;
        } else {
            auto varFrom = parser.from;
            auto var = parser.parseIdentifier;
            parser.to(varFrom).assert(var != "", () => "Identifier expected.")?;
            parts ~= new ASTIdentifier(var, moduleLevel=false, parser.to(varFrom));
        }
        auto from = parser.from;
        mut string str = parser.acceptTokenStr(TokenType.stringLiteral)
            .case(:none: continue);
        if (literalToken == TokenType.doubleQuote) {
            str = str.cleanup.case((:error, string msg): return parser.fail(msg));
        }
        parts ~= new ASTStringLiteral(str, parser.to(from));
    }
    if (!parser.acceptToken(literalToken))
        return parser.fail("closing quote expected");

    if (parts.length == 1) {
        if (auto literal = parts[0].instanceOf(ASTStringLiteral))
            return literal;
    }

    return new ASTFormatString(parts, parser.to(from));
}

(nullable ASTSymbol | Error) parseBuiltin(ParserImpl parser, LexicalContext lexicalContext)
with (parser.transaction)
{
    auto from = parser.from;
    mut uninitialized (:borrow | :take | :leak) op;
    if (parser.acceptIdentifier("__borrow")) op = :borrow;
    else if (parser.acceptIdentifier("__take")) op = :take;
    else if (parser.acceptIdentifier("__leak")) op = :leak;
    else return null;
    parser.expectToken(TokenType.lparen)?;
    auto fromSource = parser.from;
    auto source = parser.parseExpression(lexicalContext)??
        else return parser.to(fromSource).fail("expression expected");
    parser.expectToken(TokenType.rparen)?;
    commit;
    if (op == :borrow)
        return new ASTOverrideLifetime(source, Lifetime.lexical, parser.to(from));
    if (op == :take)
        return new ASTOverrideLifetime(source, Lifetime.gifted, parser.to(from));
    if (op == :leak)
        return new ASTLeakExpr(source, parser.to(from));
    assert(false);
}

// i++, i--, ++i, --i
class ASTPrePostIncDec : ASTSymbol
{
    ASTSymbol target;

    ((:pre | :post) when, (:inc | :dec) what) op;

    this(this.op, this.target, this.locRange=__CALLER__) { }

    override (Symbol | Error) compile(Context context) {
        auto target = target.compile(context)?.beExpressionImplCall(context, locRange)?;
        auto refTarget = target.instanceOf(Reference)?
            else return locRange.fail("cannot " ~ op.when.case((:pre): "pre", (:post): "post") ~ "-" ~
                op.what.case((:inc): "inc", (:dec): "dec") ~ "rement non-reference target");
        locRange.assert(
            refTarget.mutable,
            () => "cannot " ~ op.when.case((:pre): "pre", (:post): "post") ~ "-" ~
            op.what.case((:inc): "inc", (:dec): "dec") ~ "rement non-mutable target")?;
        (nullable Expression | Error) do_(Expression refptr) {
            auto context = context.withNamespace(
                context.compiler.exprAlias(context.namespace, "ref_", context.compiler.dereference(refptr)));

            return op.when.case(
                (:pre): op.what.case(
                    (:inc): context.compiler.$expr ({ ref_ += 1; ref_; }),
                    (:dec): context.compiler.$expr ({ ref_ -= 1; ref_; })
                ),
                (:post): op.what.case(
                    (:inc): context.compiler.$expr ({ auto ret = ref_; ref_ += 1; ret; }),
                    (:dec): context.compiler.$expr ({ auto ret = ref_; ref_ -= 1; ret; })))
                .compile(context)?.beExpression?;
        }
        auto refptr = context.compiler.reference(refTarget);
        return context.compiler.exprWithTemporaryExpr(context.getUniqueId, refptr, &do_)?? else die;
    }

    override string repr() {
        auto opText = op.what.case((:inc): "++", (:dec): "--");
        return op.when.case((:pre): opText ~ target.repr, (:post): target.repr ~ opText);
    }
}

// the AST of a LocRange literal recreating the passed loc.
class ASTLocRangeExpr : ASTSymbol
{
    override (Symbol | Error) compile(Context context) {
        return context.compiler.locRangeExpr(context, this.locRange);
    }
    override string repr() => "__RANGE__";
}

(nullable ASTSymbol | Error) parseExpressionBase(ParserImpl parser, LexicalContext lexicalContext)
{
    {
        auto args = new ParseExpressionBaseArgs(parser, lexicalContext);
        lexicalContext.macroState.applyMacro(args);
        if (ASTSymbol ret = args.symbol?) return ret;
    }
    if (auto destroy_ = parseDestroy(parser, lexicalContext)?) return destroy_;
    parser.begin;
    parser.strip;
    auto loc = parser.loc;
    auto from = parser.from;
    if (parser.acceptToken(TokenType.dot)) {
        // .name is module level
        string name = parser.parseIdentifier;
        if (name.length) {
            parser.commit;
            return new ASTIdentifier(name, true, parser.to(from));
        }
    }
    parser.revert;
    string name = parser.parseIdentifier;
    if (name.length) {
        if (name == "__RANGE__") {
            parser.pinned = true;
            return new ASTLocRangeExpr(parser.to(from));
        }
        if (name == "__CALLER__") {
            return new ASTCallerExpr(parser.to(from));
        }
        if (name == "super") return new ASTSuper(parser.to(from));
        return new ASTIdentifier(name, false, parser.to(from));
    }
    // $foo, foo
    if (auto sym = parser.parseLeafIdentifierSymbol(lexicalContext)?)
        return sym;
    if (parser.acceptToken(TokenType.dollar))
        return new ASTArrayLength(parser.to(from));
    {
        parser.begin;
        if (parser.acceptToken(TokenType.colon)) {
            string symbolIdentifier = parser.parseIdentifier;
            if (symbolIdentifier != "") {
                parser.commit;
                return new ASTSymbolIdentifier(symbolIdentifier, parser.to(from));
            }
        }
        parser.revert;
    }
    parseFloat(parser).case {
        Error err: return err;
        (:failure): {}
        (:success, double d):
            return new ASTDoubleLiteral(d);
        (:success, float f):
            return new ASTFloatLiteral(f);
    }
    parseNumber(parser).case {
        Error err: return err;
        (:failure): {}
        (:success, long l, bool withBasePrefix):
            // 0x8000_0000 to 0xffff_ffff are parsed as weird syntax for negative ints.
            mut long oneBigger = 0x1_0000; oneBigger *= 0x1_0000; // TODO 0x1_0000_0000
            if (withBasePrefix && l > 0x7fff_ffff && l < oneBigger) {
                return new ASTNumberLiteral(l - oneBigger, parser.to(from));
            }
            return new ASTNumberLiteral(l, parser.to(from));
    }
    if (parser.acceptToken(TokenType.singleQuote)) {
        return parseCharLiteral(parser, lexicalContext);
    }
    if (parser.acceptToken(TokenType.doubleQuote)) {
        return parseStringLiteral(parser, lexicalContext, TokenType.doubleQuote);
    }
    if (parser.acceptToken(TokenType.backtick)) {
        return parseStringLiteral(parser, lexicalContext, TokenType.backtick);
    }
    if (auto statementExpr = parseStatementExpr(parser, lexicalContext)?)
        return statementExpr;
    if (parser.acceptToken(TokenType.lparen)) {
        nullable ASTSymbol result = parseExpression(parser, lexicalContext)?;

        parser.expectToken(TokenType.rparen)?;
        return result? else die;
    }
    if (auto result = parseArrayLiteral(parser, lexicalContext)?)
        return result;
    return null;
    /*return parser.fail("Base expression expected.");*/
}

(ASTSymbol | Error) parseBitAnd(ParserImpl parser, LexicalContext lexicalContext, mut ASTSymbol left, int myLevel)
{
    while (true)
    {
        parser.begin;
        auto from = parser.from;
        if (parser.acceptToken2Not(TokenType.ampersand, TokenType.ampersand))
        {
            parser.commit;
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp("&", left, right, parser.to(from));
        }
        else
        {
            parser.revert;
            return left;
        }
    }
}

(ASTSymbol | Error) parseBitXor(ParserImpl parser, LexicalContext lexicalContext, mut ASTSymbol left, int myLevel)
{
    while (true)
    {
        parser.begin;
        auto from = parser.from;
        if (parser.acceptToken(TokenType.circumflex))
        {
            parser.commit;
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp("^", left, right, parser.to(from));
        }
        else
        {
            parser.revert;
            return left;
        }
    }
}

(ASTSymbol | Error) parseBitOr(ParserImpl parser, LexicalContext lexicalContext, mut ASTSymbol left, int myLevel)
{
    while (true)
    {
        parser.begin;
        auto from = parser.from;
        if (parser.acceptToken2Not(TokenType.bar, TokenType.bar))
        {
            parser.commit;
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp("|", left, right, parser.to(from));
        }
        else
        {
            parser.revert;
            return left;
        }
    }
}

(ASTSymbol | Error) parseBitShift(ParserImpl parser, LexicalContext lexicalContext, mut ASTSymbol left, int myLevel)
{
    while (true)
    {
        auto from = parser.from;
        if (parser.acceptToken2(TokenType.smaller, TokenType.smaller))
        {
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp("<<", left, right, parser.to(from));
        }
        else if (parser.acceptToken3(TokenType.greater, TokenType.greater, TokenType.greater))
        {
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp(">>>", left, right, parser.to(from));
        }
        else if (parser.acceptToken2(TokenType.greater, TokenType.greater))
        {
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp(">>", left, right, parser.to(from));
        }
        else return left;
    }
}

(ASTSymbol | Error) parseAddSubCat(ParserImpl parser, LexicalContext lexicalContext, mut ASTSymbol left, int myLevel)
{
    while (true)
    {
        auto from = parser.from;
        if (parser.acceptToken2Not(TokenType.plus, TokenType.plus))
        {
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp("+", left, right, parser.to(from));
        }
        else if (parser.acceptToken2Not(TokenType.minus, TokenType.minus))
        {
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp("-", left, right, parser.to(from));
        }
        else if (parser.acceptToken(TokenType.tilde))
        {
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp("~", left, right, parser.to(from));
        }
        else return left;
    }
}

(ASTSymbol | Error) parseMulDiv(ParserImpl parser, LexicalContext lexicalContext, mut ASTSymbol left, int myLevel)
{
    while (true)
    {
        auto from = parser.from;
        if (parser.acceptToken(TokenType.asterisk))
        {
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp("*", left, right, parser.to(from));
        }
        else if (parser.acceptToken(TokenType.slash))
        {
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp("/", left, right, parser.to(from));
        }
        else if (parser.acceptToken(TokenType.percent))
        {
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp("%", left, right, parser.to(from));
        }
        else return left;
    }
}

(ASTSymbol | Error) parseBoolAnd(ParserImpl parser, LexicalContext lexicalContext, mut ASTSymbol left, int myLevel)
{
    while (true)
    {
        auto from = parser.from;
        if (parser.acceptToken2(TokenType.ampersand, TokenType.ampersand))
        {
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp("&&", left, right, parser.to(from));
        } else return left;
    }
}

(ASTSymbol | Error) parseBoolOr(ParserImpl parser, LexicalContext lexicalContext, mut ASTSymbol left, int myLevel)
{
    while (true)
    {
        auto from = parser.from;
        if (parser.acceptToken2(TokenType.bar, TokenType.bar))
        {
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp("||", left, right, parser.to(from));
        } else return left;
    }
}

// a .. b
class ASTIota : ASTSymbol
{
    ASTSymbol from;

    ASTSymbol to;

    this(this.from, this.to, this.locRange=__CALLER__) { }

    override (Expression | Error) compile(Context context)
    {
        // TODO static if (is(typeof))
        auto from = this.from.compile(context)?.beExpressionImplCall(context, this.from.locRange)?;
        auto to = this.to.compile(context)?.beExpressionImplCall(context, this.to.locRange)?;
        ASTSymbol astFrom = new ASTSymbolHelper(from), astTo = new ASTSymbolHelper(to);

        ASTSymbol iotaValue() {
            if (from.type.same(once new Integer) && to.type.same(once new Integer)) {
                return context.compiler.$expr ({
                    import package(compiler).std.range.iota : IntIota;
                    IntIota($astFrom, $astTo);
                });
            }
            return context.compiler.$expr ({
                import package(compiler).std.range.iota : Iota;
                Iota($astFrom, $astTo);
            });
        }

        return iotaValue.compile(context)?.beExpression?;
    }
}

(ASTSymbol | Error) parseIota(ParserImpl parser, LexicalContext lexicalContext, ASTSymbol left, int myLevel)
{
    auto from = parser.from;
    if (parser.acceptToken2(TokenType.dot, TokenType.dot))
    {
        ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

        return new ASTIota(left, right, parser.to(from));
    }
    return left;
}

(ASTSymbol | Error) parseComparison(ParserImpl parser, LexicalContext lexicalContext, ASTSymbol left, int myLevel)
{
    auto from = parser.from;
    if (parser.acceptToken2(TokenType.equal, TokenType.equal))
    {
        auto locRange = parser.to(from);
        ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

        return new ASTBinaryOp("==", left, right, locRange);
    }
    if (parser.acceptToken2(TokenType.exclamationmark, TokenType.equal)) // same as !(a == b)
    {
        auto locRange = parser.to(from);
        ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

        return new ASTNegation(new ASTBinaryOp("==", left, right, locRange), locRange);
    }
    if (parser.acceptIdentifier("is"))
    {
        auto locRange = parser.to(from);
        ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

        return new ASTBinaryOp("is", left, right, locRange);
    }
    with (parser.transaction) {
        if (parser.acceptToken(TokenType.exclamationmark) && parser.acceptIdentifier("is"))
        {
            commit;
            auto locRange = parser.to(from);
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            return new ASTNegation(new ASTBinaryOp("is", left, right, locRange), locRange);
        }
    }
    if (parser.acceptToken2(TokenType.greater, TokenType.equal))
    {
        auto locRange = parser.to(from);
        ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

        return new ASTBinaryOp(">=", left, right, locRange);
    }
    if (parser.acceptToken2Not(TokenType.greater, TokenType.greater))
    {
        auto locRange = parser.to(from);
        ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

        return new ASTBinaryOp(">", left, right, locRange);
    }
    if (parser.acceptToken2(TokenType.smaller, TokenType.equal))
    {
        auto locRange = parser.to(from);
        ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

        return new ASTBinaryOp("<=", left, right, locRange);
    }
    if (parser.acceptToken2Not(TokenType.smaller, TokenType.smaller))
    {
        auto locRange = parser.to(from);
        ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

        return new ASTBinaryOp("<", left, right, locRange);
    }
    return left;
}

(ASTSymbol | Error) parseArithmetic(ParserImpl parser, LexicalContext lexicalContext, mut ASTSymbol left, int level)
{
    // & ^ <<>> | */ +- <> && ||
    if (level <= 9) left = parseBitAnd(parser, lexicalContext, left, 9)?;
    if (level <= 8) left = parseBitXor(parser, lexicalContext, left, 8)?;
    if (level <= 7) left = parseBitShift(parser, lexicalContext, left, 7)?;
    if (level <= 6) left = parseBitOr(parser, lexicalContext, left, 6)?;
    if (level <= 5) left = parseMulDiv(parser, lexicalContext, left, 5)?;
    if (level <= 4) left = parseAddSubCat(parser, lexicalContext, left, 4)?;
    if (level <= 3) left = parseIota(parser, lexicalContext, left, 3)?;
    if (level <= 2) left = parseComparison(parser, lexicalContext, left, 2)?;
    if (level <= 1) left = parseBoolAnd(parser, lexicalContext, left, 1)?;
    if (level <= 0) left = parseBoolOr(parser, lexicalContext, left, 0)?;
    return left;
}

(ASTSymbol | Error) expectArithmetic(ParserImpl parser, LexicalContext lexicalContext, int level)
{
    auto leaf = parseExpressionLeaf(parser, lexicalContext)??
        else return parser.fail("Expression leaf expected");

    return parseArithmetic(parser, lexicalContext, leaf, level);
}

(nullable ASTSymbol | Error) parseArithmeticExpr(ParserImpl parser, LexicalContext lexicalContext) {
    auto leaf = parseExpressionLeaf(parser, lexicalContext)?.case(null: return null);
    return parseArithmetic(parser, lexicalContext, leaf, 0);
}

/**
 * Ternary expressions have two forms:
 * - foo if bar else baz: ternary if
 * - foo else baz: short ternary if :)
 *   - In this case, the condition is held to be true.
 *     So the else block can only be hit via breakelse.
 */
(nullable ASTSymbol | Error) parseTernaryOp(ParserImpl parser, LexicalContext lexicalContext) {
    with (parser.transaction) {
        auto from = parser.from;
        auto base = parseArithmeticExpr(parser, lexicalContext)?.case(null: return null);
        mut nullable ASTSymbol test = null;
        if (parser.acceptIdentifier("if")) {
            test = parseArithmeticExpr(parser, lexicalContext)?;
            if (!test) {
                commit;
                return base;
            }
        }
        if (!parser.acceptIdentifier("else")) {
            if (test)
                return parser.fail("'else' expected");
            commit;
            return base;
        }
        auto else_ = parseExpression(parser, lexicalContext)?
            .case(null: return parser.fail("'else' expression expected"));
        commit;
        return new ASTTernaryIf(test=test, then=base, else_=else_, parser.to(from));
    }
}

(nullable ASTSymbol | Error) parseExpression(ParserImpl parser, LexicalContext lexicalContext) {
    return parseTernaryOp(parser, lexicalContext);
}

class ASTReturn : ASTSymbol
{
    ASTSymbol value;

    this(this.value, this.locRange=__CALLER__) { }

    override (Symbol | Error) compile(Context context)
    {
        mut Expression expr = this.value.compile(context)?.beExpressionImplCall(context, this.locRange)?;
        Returnable returnable = findParent!Returnable(context.namespace)? else die;
        Type ret = returnable.mergeReturn(context, expr, this.locRange)?;

        ret.checkQuarantine(context, this.locRange, (:returningFrom, returnable))?;

        /**
         * - save the value
         * - unwind stack
         * - ret the saved value
         */
        // special magic because ArrayLiteral can be casted where tmp(ArrayLiteral) can not
        bool exprIsTypeSensitive = !!expr.instanceOf(ArrayLiteral);
        if (exprIsTypeSensitive) {
            // implconv upfront
            expr = expectImplicitConvertTo(context, expr, ret, this.locRange)?;
        }
        auto temp = new PairedTemporaryExpr(expr.type, Lifetime.none, context.getUniqueId);
        auto init = new InitializeTemporaryExprStatement(temp, expr.take(context, this.value.locRange)?);
        Statement returnStmt = unwindScope(context, findParent!FunctionScope(context.namespace), init)?;
        // Only implconv after we've taken the expr!
        // We often implconv to a wider sumtype on return. This way we can .take the narrower expr.
        auto temp = expectImplicitConvertTo(context, temp, ret, this.locRange)?;
        Statement returnStmt = sequence(returnStmt, new ReturnStatement(temp, this.locRange));
        // no need for stack cleanup after a return.
        return new StatementExpression(returnStmt, new UnreachableExpr, gifted=false);
    }

    override string repr() { return "return $(value.repr)"; }
}

// the return expression of "return;"
class ASTVoidExpression : ASTSymbol
{
    this(this.locRange=__CALLER__) { }

    override (Expression | Error) compile(Context context) { return once new VoidExpression; }
}

(nullable ASTReturn | Error) parseReturn(ParserImpl parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from;
    string identifier = parser.parseIdentifier;
    if (identifier != "return") {
        parser.revert;
        return null;
    }
    mut uninitialized ASTSymbol expr;
    // peek
    parser.begin;
    // TODO acceptExprTerminator
    if (parser.acceptToken(TokenType.semicolon)
        || parser.acceptToken(TokenType.comma)
        || parser.acceptToken(TokenType.rparen))
    {
        // return;
        parser.revert;
        expr = new ASTVoidExpression(parser.to(from));
    } else {
        parser.revert;
        if (auto expr_ = parseExpression(parser, lexicalContext)?) {
            expr = expr_;
        } else return parser.fail("expression or semicolon expected");
    }
    parser.commit;
    return new ASTReturn(expr, parser.to(from));
}

(Statement | Error) unwindScope(Context context, nullable Namespace target, Statement body_)
{
    mut Statement result = body_;
    mut nullable Namespace current = context.namespace;
    while (current && current !is target) {
        if (auto unwindable = current.instanceOf(Unwindable)) {
            result = sequence(result, unwindable.unwind(context)?);
        }
        if (auto declHolder = current.instanceOf(DeclarationHolder)) {
            if (declHolder.freeOnExit) {
                auto var = declHolder.access(context);
                auto type = var.type;
                if (auto destroy = type.endLifetime(context, var)) {
                    result = sequence(result, destroy);
                }
            }
        }
        current = current.parent;
    }
    return result;
}

(Expression | Error) pickEither(
    Context context, Either either, Expression source, Type extractType, LocRange locRange)
{
    mut ASTEitherCaseExprCase[] cases;
    for (k, v in either.types) {
        // return out all types that aren't the extract type
        bool return_ = !v.type.same(extractType);
        ASTSymbol expr() {
            auto a = new ASTIdentifier("a", false);
            if (return_) return new ASTReturn(a);
            return a;
        }
        cases ~= ASTEitherCaseExprCase(
            __RANGE__,
            new ASTSymbolHelper(v.type),
            "a",
            fail=v.fail,
            expr=expr);
    }

    auto case_ = new ASTEitherCaseExpr(__RANGE__, new ASTSymbolHelper(source), cases);

    context.pushErrorLoc(locRange);
    auto ret = case_.compile(context);
    context.popErrorLoc;
    return ret;
}

private Type typeWithoutFail(Either source)
{
    if ([count a in source.types where !a.fail] == 1) {
        return [first a.type for a in source.types where !a.fail];
    }
    return new Either([a for a in source.types where !a.fail]);
}

class InfoExpression : Expression
{
    Expression base;

    this(this.base, this.info) { this.type = base.type; }

    override int emit(Generator output) { return base.emit(output); }
    // TODO hash ExprInfo
    override void hash(Hash hash) { hash.adds("InfoExpression"); base.hash(hash); }
    override string repr() return "cast($(info.repr)) $(base.repr)";
}

Type makeNotNullable(Type type) {
    if (auto classType = type.instanceOf(ClassType))
        return classType.makeNotNullable;
    else if (auto intfType = type.instanceOf(IntfType))
        return intfType.makeNotNullable;
    else assert(false);
}

class ASTIfStatement : ASTStatement
{
    (ASTSymbol | ASTVarDeclStatement | ASTVarExtractDeclStatement) test;

    ASTStatement then;

    nullable ASTStatement else_;

    bool letMode;

    this(this.test, this.then, this.else_, this.letMode, this.locRange=__CALLER__) { }

    override (StatementCompileResult | Error) compile(Context context)
    {
        mut nullable Statement prelude; // var decl statement
        mut nullable Expression test;
        mut nullable Statement epilog; // either decl value assignment
        auto ifLabel = context.getLabel;
        auto ifLabelNamespace = new LabelIfScope(ifLabel, hasElse=!!this.else_, context.namespace);
        auto context = context.withNamespace(ifLabelNamespace);
        mut auto testSucceedsNamespace = context.namespace;
        this.test.case {
            ASTSymbol symbol: {
                assert(!letMode);
                // TODO pick assignment
                test = symbol.compile(context)?.beExpressionImplCall(context, this.locRange)?;
            }
            ASTVarDeclStatement vardecl: {
                auto initial = vardecl.initial.compile(context)?.beExpressionImplCall(context, vardecl.locRange)?;
                // TODO
                // auto declType = vardecl.type?.compile(context)?.beType(vardecl.type.locRange).else(null);
                mut nullable Type declType;
                if (vardecl.type)
                    declType = vardecl.type.compile(context)?.beType(vardecl.type.locRange)?;

                // `if (Foo var = some nullable Foo)`:
                //   - cache `some`, test for nullness, then declare Foo var.
                if (!letMode && initial.type.zeroInitializable && context.compiler.isClassType(initial.type)
                    && (!declType || !declType.zeroInitializable && context.compiler.isClassType(declType? else die)))
                {
                    Type notNullableType = initial.type.makeNotNullable;
                    auto tempInitial = new PairedTemporaryExpr(
                        initial.type, initial.info.lifetime, context.getUniqueId);
                    auto initTemp = new InitializeTemporaryExprStatement(tempInitial, initial);

                    prelude = initTemp;
                    // don't worry about memory management - we're just doing a null test.
                    test = new InfoExpression(tempInitial, ExprInfo(Lifetime.permanent));

                    auto actualVarDecl = new ASTVarDeclStatement(
                        vardecl.name, mutable=vardecl.mutable, infer=false, uninitialized=false,
                        type=new ASTSymbolHelper(declType if declType else notNullableType),
                        initial=new ASTSymbolHelper(new PointerCast(notNullableType, tempInitial)),
                        vardecl.locRange);
                    auto pair = actualVarDecl.compile(context)?;
                    epilog = pair.statement;
                    testSucceedsNamespace = pair.namespace;
                } else {
                    auto name = vardecl.name.(that? else die).name(context.warmContext);
                    auto pair = vardecl.compile(context)?;
                    prelude = pair.statement;
                    testSucceedsNamespace = pair.namespace;
                    if (letMode) {
                        test = new BoolLiteral(true);
                    } else {
                        auto var = testSucceedsNamespace.lookup(
                                name, context, LookupReason.identifier, this.locRange)?? else die
                            .beExpression(this.locRange)?;
                        // TODO lookup() that handles the stackframe thing
                        test = var.beExpressionImplCall(context, this.locRange)?;
                    }
                }
            }
            ASTVarExtractDeclStatement extractdecl: {
                assert(!letMode);
                return extractdecl.locRange.fail(
                    "This syntax is disabled at the moment until I figure out what to use it for.");
                // if (auto var <- expr) where expr is (nullable T, fail)
                // validate source is Either
                // TODO extract interface
                auto source = extractdecl.source.compile(context)?
                    .beExpressionImplCall(context, extractdecl.locRange)?;
                auto sourceType = source.type.instanceOf(Either)?
                    else return extractdecl.locRange.fail(
                        "source of <- decl must be sumtype, not $(source.type.repr)");
                // FIXME check lifetime here
                auto tempSource = new PairedTemporaryExpr(source.type, source.info.lifetime, context.getUniqueId);
                auto initTemp = new InitializeTemporaryExprStatement(tempSource, source);
                // check expected type
                auto remainingType = typeWithoutFail(sourceType);
                mut Type testedType = remainingType;
                if (remainingType.zeroInitializable && context.compiler.isClassType(remainingType)) {
                    testedType = remainingType.makeNotNullable;
                }
                if (!extractdecl.infer) {
                    auto declType = extractdecl.type.compile(context)?.beType(extractdecl.locRange)?;
                    extractdecl.locRange.assert(
                        declType.same(testedType),
                        () => "expected $(declType.repr), but got $(testedType.repr)")?;
                }

                auto value = pickEither(context, sourceType, tempSource, remainingType, extractdecl.locRange)?;
                prelude = initTemp;
                // ignore lifetime, it's just a null check
                test = new InfoExpression(value, ExprInfo(Lifetime.permanent));

                auto actualVarDecl = new ASTVarDeclStatement(
                    extractdecl.name, mutable=extractdecl.mutable, infer=false, uninitialized=false,
                    type=new ASTSymbolHelper(testedType),
                    initial=new ASTSymbolHelper(new PointerCast(testedType, value)),
                    extractdecl.locRange);
                auto pair = actualVarDecl.compile(context)?;
                epilog = pair.statement;
                testSucceedsNamespace = pair.namespace;
            }
        }
        auto testSucceedsContext = context.withNamespace(testSucceedsNamespace);
        auto thenPair = this.then.compile(testSucceedsContext)?;
        // TODO make unwindScope take two namespaces
        auto thenPairContext = testSucceedsContext.withNamespace(thenPair.namespace);
        Statement then = unwindScope(thenPairContext, context.namespace, thenPair.statement)?;
        mut nullable Statement else_;
        if (this.else_) {
            auto elsePair = this.else_.compile(context)?;
            auto elsePairContext = context.withNamespace(elsePair.namespace);
            else_ = unwindScope(elsePairContext, context.namespace, elsePair.statement)?;
        }

        auto test = truthy(context, test? else die, this.locRange)?;
        auto ifStmt = new IfStatement(ifLabel, test, sequence2(epilog, then), else_, this.locRange);

        return StatementCompileResult(sequence2(prelude, ifStmt), context.namespace);
    }
}

(nullable ASTIfStatement | Error) parseIf(ParserImpl parser, LexicalContext lexicalContext, LocRange from)
{
    bool letMode = parser.acceptIdentifier("let");
    mut uninitialized (ASTSymbol | ASTVarDeclStatement | ASTVarExtractDeclStatement) test;
    auto locRange = parser.to(from);
    parser.expectToken(TokenType.lparen)?;
    auto vardecl = parseVarDecl(parser, lexicalContext, requireInitializer=true)?;
    if (auto vardecl = vardecl)
        test = vardecl;
    else {
        locRange.assert(!letMode, "let () expected a variable declaration")?;
        auto varextractdecl = parseVarExtractDecl(parser, lexicalContext)?;
        if (auto varextractdecl = varextractdecl) test = varextractdecl;
        else {
            test = parseExpression(parser, lexicalContext)?? else die;
        }
    }
    parser.expectToken(TokenType.rparen)?;
    ASTStatement thenStmt = parseStatement(parser, lexicalContext)?;
    mut nullable ASTStatement elseStatement;
    if (parser.acceptIdentifier("else"))
    {
        elseStatement = parseStatement(parser, lexicalContext)?;
    }
    return new ASTIfStatement(test, thenStmt, elseStatement, letMode, locRange);
}

(nullable ASTSymbol | Error) parseBreakCont(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from;
    string identifier = parser.parseIdentifier;
    if (identifier == "break") {
        parser.commit;
        return new ASTBreak(parser.to(from));
    }
    if (identifier == "continue") {
        parser.commit;
        return new ASTContinue(parser.to(from));
    }
    if (identifier == "breakelse") {
        parser.commit;
        return new ASTBreakElse(parser.to(from));
    }
    parser.revert;
    return null;
}

class ASTScopeStatement : ASTStatement
{
    ASTStatement[] statements;

    this(this.statements, this.locRange=__CALLER__) { }

    override (StatementCompileResult | Error) compile(Context context)
    {
        auto statements = new Statement mut[](this.statements.length);
        mut auto subContext = context;
        for (i, statement in this.statements) {
            auto pair = statement.compile(subContext)?;

            subContext = subContext.withNamespace(pair.namespace);
            statements[i] = pair.statement;
        }
        return StatementCompileResult(
            unwindScope(subContext, context.namespace, new SequenceStatement(statements.freeze))?,
            context.namespace); // scope ends here
    }
}

// just a bunch of statements after each other
// (used for int a, b)
class ASTSequenceStatement : ASTStatement
{
    ASTStatement[] statements;

    this(this.statements, this.locRange=__CALLER__) { }

    override (StatementCompileResult | Error) compile(Context context)
    {
        auto statements = new Statement mut[](this.statements.length);
        mut auto subContext = context;
        for (i, statement in this.statements) {
            auto pair = statement.compile(subContext)?;

            subContext = subContext.withNamespace(pair.namespace);
            statements[i] = pair.statement;
        }
        // not a scope!
        return StatementCompileResult(new SequenceStatement(statements.freeze), subContext.namespace);
    }

    override string repr() => "{ " ~ [join a.repr for a in this.statements] ~ "}";
}

(nullable ASTScopeStatement | Error) parseScope(ParserImpl parser, LexicalContext lexicalContext)
{
    // This is not necessary, but ensures we get an error instead of segfault if we just spam brackets.
    parser.begin;
    auto from = parser.from;
    if (!parser.acceptToken(TokenType.lcurlybracket)) {
        parser.revert;
        return null;
    }
    mut ASTStatement[] statements;
    while (!parser.acceptToken(TokenType.rcurlybracket))
    {
        (void | Error) appendStmt() {
            statements ~= parseStatement(parser, lexicalContext)?;
        }
        parser.verifyTransactions("scope statement parse rule imbalance", &appendStmt)?;
    }
    parser.commit;
    return new ASTScopeStatement(statements, parser.to(from));
}

(nullable ASTStatement | Error) parseAssignment(ParserImpl parser, LexicalContext lexicalContext)
{
    parser.begin;
    ASTSymbol lhs = parseExpressionLeaf(parser, lexicalContext)?? else ({
        parser.revert;
        return null;
    });
    auto from = parser.from;
    mut string operator;
    if (parser.acceptToken(TokenType.equal)) { }
    else if (parser.acceptToken2(TokenType.plus, TokenType.equal))
        operator = "+";
    else if (parser.acceptToken2(TokenType.minus, TokenType.equal))
        operator = "-";
    else if (parser.acceptToken2(TokenType.asterisk, TokenType.equal))
        operator = "*";
    else if (parser.acceptToken2(TokenType.slash, TokenType.equal))
        operator = "/";
    else if (parser.acceptToken2(TokenType.tilde, TokenType.equal))
        operator = "~";
    else if (parser.acceptToken2(TokenType.ampersand, TokenType.equal))
        operator = "&";
    else if (parser.acceptToken2(TokenType.bar, TokenType.equal))
        operator = "|";
    else if (parser.acceptToken2(TokenType.circumflex, TokenType.equal))
        operator = "^";
    else if (parser.acceptToken2(TokenType.percent, TokenType.equal))
        operator = "%";
    else if (parser.acceptToken3(TokenType.ampersand, TokenType.ampersand, TokenType.equal))
        operator = "&&";
    else if (parser.acceptToken3(TokenType.bar, TokenType.bar, TokenType.equal))
        operator = "||";
    else {
        parser.revert;
        return null;
    }
    ASTSymbol expr = parseExpression(parser, lexicalContext)??
        else return parser.fail("expression expected");
    parser.commit;
    if (operator.length) {
        return new ASTOpAssignStatement(lhs, operator, expr, parser.to(from));
    }
    return new ASTAssignStatement(lhs, expr, parser.to(from));
}

class ASTOpAssignStatement : ASTStatement
{
    ASTSymbol left;

    string op;

    ASTSymbol right;

    this(this.left, this.op, this.right, this.locRange=__CALLER__) { }

    override (StatementCompileResult | Error) compile(Context context)
    {
        auto fallback = new ASTAssignStatement(left, new ASTBinaryOp(op, left, right, locRange), locRange);

        Expression left = this.left.compile(context)?.beExpressionImplCall(context, left.locRange)?;
        Expression right = this.right.compile(context)?.beExpressionImplCall(context, right.locRange)?;
        if (op == "~") {
            if (auto rLeft = left.instanceOf(Reference)) {
                this.locRange.assert(
                    rLeft.mutable, () => "target of assignment must be mutable: $(left.repr)")?;
                if (auto leftArray = left.type.instanceOf(Array)) {
                    // special performance optimization for a ~= b
                    if (auto converted = implicitConvertTo(context, right, leftArray.elementType, this.locRange)?) {
                        return StatementCompileResult(
                            arrayCatAssign(context, rLeft, converted, this.locRange)?,
                            context.namespace);
                    }
                    return StatementCompileResult(
                        arrayCatAssign(context, rLeft, right, this.locRange)?,
                        context.namespace);
                }
            }
        }
        return fallback.compile(context);
    }
}

class ASTAssignStatement : ASTStatement
{
    ASTSymbol target;

    ASTSymbol value;

    this(this.target, this.value, this.locRange=__CALLER__) {}

    override (StatementCompileResult | Error) compile(Context context) {
        Expression value = this.value.compile(context)?.beExpressionImplCall(context, this.value.locRange)?;

        if (auto stmt = this.target.assign(context, value)?) {
            return StatementCompileResult(stmt, context.namespace);
        }

        Symbol target = this.target.compile(context)?;
        Reference targetref = target.instanceOf(Reference)?
            else return this.locRange.fail("target of assignment must be a reference");
        this.locRange.assert(targetref.mutable, () => "target of assignment must be mutable: $(targetref.repr)")?;
        auto type = targetref.type;
        auto value = expectImplicitConvertTo(context, value, type, this.locRange)?;

        /**
         * Order is important here.
         *
         * 1. temporize the RHS. (NO copy ctor!)
         * 2. temporize the old LHS.
         * 3. overwrite the LHS with the temporized RHS. (copy here)
         * 4. destroy the old LHS value.
         *
         * Why this order? Evaluating the RHS might change the LHS address
         * (consider: *f() = *g() - in that case, g() is more likely to
         * invalidate f() than the other way around).
         * Also, the RHS may just *be* the LHS, as in "s = s;"
         * Hence we need to temporize the RHS.
         * The address of LHS is temporized so that the destructor call
         * doesn't lead to a double evaluation.
         * The old LHS value is rescued so that more complex versions of
         * "s = s" don't leave the references in "s" abandoned between
         * endLifetime and moveInto. In other words, since s_2 may depend on s_1,
         * their lifetimes need to overlap.
         *
         * But man, what an ugly-ass dataflow...
         */

        auto compiler = context.compiler;
        (nullable Statement | Error) do1(Expression tmpValue) {
            (nullable Statement | Error) do2(Expression tmpLhsPtr) {
                auto tmpLhs = compiler.dereference(tmpLhsPtr);

                (nullable Statement | Error) do3(Expression oldLhs) {
                    auto reassign = compiler.move(context, tmpLhs, tmpValue, this.value.locRange)?;
                    auto cleanup = oldLhs.type.endLifetime(context, oldLhs);

                    return sequence(reassign, cleanup);
                }
                return compiler.stmtWithTemporaryExpr(context.getUniqueId, tmpLhs, &do3);
            }
            return compiler.stmtWithTemporaryExpr(context.getUniqueId, compiler.reference(targetref), &do2);
        }
        return StatementCompileResult(
            compiler.stmtWithTemporaryExpr(context.getUniqueId, value, &do1)?? else die,
            context.namespace);
    }

    override string repr() { return "$(target.repr) = $(value.repr); "; }
}

class ASTVarDeclStatement : ASTStatement
{
    nullable ASTIdentifierSymbol name;

    bool mutable;

    bool infer;

    bool uninitialized;

    nullable ASTSymbol type;

    nullable ASTSymbol initial;

    this(this.name, this.mutable, this.infer, this.uninitialized,
        this.type, this.initial, this.locRange=__CALLER__)
    {
        assert(!uninitialized || mutable);
        assert(infer == !type);
        assert(!infer || initial);
        assert(!uninitialized || !initial);
    }

    override (StatementCompileResult | Error) compile(Context context)
    {
        mut nullable Type type;
        if (this.type) type = this.type.compile(context)?.beType(this.locRange)?;
        auto name = this.name.case(null: "", ASTIdentifierSymbol sym: sym.name(context.warmContext));
        if (this.initial)
        {
            mut auto initial = this.initial.compile(context)?.beExpressionImplCall(context, this.locRange)?;
            if (this.infer) {
                assert(!type);
                type = initial.type;
            } else {
                assert(!!type);
                initial = expectImplicitConvertTo(context, initial, type? else die, this.locRange)?;
            }
            auto type = type? else die;

            // If the initial value is lexical, ie. a non-mutable variable or parameter,
            // we know its lifetime will dominate ours.
            // If we too are lexical, then we can just borrow it.
            bool borrow = initial.info.lifetime == Lifetime.lexical && !this.mutable;

            auto decl = new VariableDeclaration(
                context.namespace, name, context, type, mut=this.mutable, borrowed=borrow, hidden=false);
            auto assign = decl.initialize(context, initial, this.locRange)?;

            return StatementCompileResult(assign, decl);
        }
        else if (this.uninitialized)
        {
            auto type = type? else die;
            auto decl = new VariableDeclaration(
                context.namespace, name, context, type, mut=this.mutable, borrowed=false, hidden=false);
            auto assign = decl.initialize(context, new NullExpr(type), this.locRange)?;

            // Still zero-init.
            return StatementCompileResult(assign, decl);
        }
        else
        {
            auto type = type? else die;
            if (!type.zeroInitializable) {
                return this.locRange.fail(
                    "Cannot declare $(name) without initializer: $(type.repr) is not zero-initializable");
            }
            auto decl = new VariableDeclaration(
                context.namespace, name, context, type, mut=this.mutable, borrowed=false, hidden=false);
            auto assign = decl.initialize(context, new NullExpr(type), this.locRange)?;

            return StatementCompileResult(assign, decl);
        }
    }

    override string repr() {
        if (type)
            if (initial) return "$(type.repr) $name = $(initial.repr); ";
            else return "$(type.repr) $name; ";
        else
            if (initial) return "auto $name = $(initial.repr); ";
            else return "auto $name; ";
    }
}

(nullable ASTVarDeclStatement | Error) parseVarInitialization(
    ParserImpl parser, LexicalContext lexicalContext, bool infer, bool mutable, bool uninitialized,
    nullable ASTSymbol type, string operator, bool requireInitializer)
{
    parser.begin;
    mut nullable ASTSymbol initial;
    auto from = parser.from;
    mut nullable ASTIdentifierSymbol name;
    bool accept() {
        if (operator == "=") return parser.acceptToken(TokenType.equal);
        if (operator == "<-") return parser.acceptToken2(TokenType.smaller, TokenType.minus);
        assert(false);
    }
    // <- is not as ambiguous as =
    if ((infer || operator == "<-") && accept())
    {
        initial = parseExpression(parser, lexicalContext)?;
        if (!initial) return parser.fail("variable initializer expected");
    }
    else
    {
        if (auto ident = parser.parseIdentifierSymbol(lexicalContext)?) {
            if (reserved(ident)) {
                parser.revert;
                return null;
            }
            name = ident;
        } else {
            parser.revert;
            return null;
        }
        if (infer) {
            if (!accept()) {
                parser.revert;
                return null;
            }
            initial = parseExpression(parser, lexicalContext)?;
            if (!initial) return parser.fail("variable initializer expected");
        }
        else if (accept()) {
            initial = parseExpression(parser, lexicalContext)?;
            if (!initial) return parser.fail("variable initializer expected");
        } else {
            // FIXME this is very hacky
            if (operator == "=" && parser.acceptToken2(TokenType.smaller, TokenType.minus)) {
                // recognize that we're failing to parse a <- instead of ==
                // FIXME check for both here instead of passing a parameter
                parser.revert;
                return null;
            }
        }
    }
    if (requireInitializer && !initial) {
        parser.revert;
        return null;
    }
    parser.commit;
    return new ASTVarDeclStatement(name, mutable=mutable, infer=infer,
                                   uninitialized=uninitialized, type, initial, parser.to(from));
}

(nullable ASTVarDeclStatement | Error) parseVarDecl(ParserImpl parser, LexicalContext lexicalContext,
    bool requireInitializer)
{
    parser.begin;
    mut bool infer = false;
    mut bool mutable = false;
    mut bool uninitialized = false;
    mut nullable ASTSymbol type;
    if (parser.acceptIdentifier("mut")) mutable = true;
    if (parser.acceptIdentifier("uninitialized")) uninitialized = true;
    if (parser.acceptIdentifier("auto")) {
        infer = true;
    } else {
        type = parser.parseType(lexicalContext)?;
        if (!type)
        {
            if (mutable) infer = true;
            else {
                parser.revert;
                return null;
            }
        }
    }
    auto decl = parseVarInitialization(
        parser, lexicalContext, infer, mutable, uninitialized, type, "=", requireInitializer)?;
    if (!decl) {
        parser.revert;
        return null;
    }
    parser.commit;
    return decl;
}

// TODO merge with parseVarDecl
(nullable ASTStatement | Error) parseMultiVarDecl(ParserImpl parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from;
    mut bool infer = false;
    mut bool mutable = false;
    mut bool uninitialized = false;
    mut nullable ASTSymbol type;
    if (parser.acceptIdentifier("mut")) mutable = true;
    if (parser.acceptIdentifier("uninitialized")) uninitialized = true;
    if (parser.acceptIdentifier("auto")) {
        infer = true;
    } else {
        type = parser.parseType(lexicalContext)?;
        if (!type)
        {
            parser.revert;
            return null;
        }
    }
    mut ASTStatement[] decls;
    while (true) {
        if (decls.length) parser.expectToken(TokenType.comma)?;
        auto decl = parseVarInitialization(parser, lexicalContext, infer, mutable, uninitialized, type, "=", false)?;
        if (auto decl = decl) {
            decls ~= decl;
        } else {
            auto decl2 = parseVarInitialization(
                parser, lexicalContext, infer, mutable, uninitialized, type, "<-", false)?;
            if (auto decl2 = decl2) {
                decls ~= extractFromVarDecl(decl2);
            } else {
                parser.assert_(decls.length == 0, "couldn't parse continuing variable declaration")?;
                parser.revert;
                return null;
            }
        }
        if (parser.acceptToken(TokenType.semicolon)) break;
    }
    parser.commit;
    return new ASTSequenceStatement(decls, parser.to(from));
}

/**
 * auto a <- foo;
 * int i <- find(...);
 */
class ASTVarExtractDeclStatement : ASTStatement
{
    nullable ASTIdentifierSymbol name;

    bool mutable;

    bool infer;

    nullable ASTSymbol type;

    ASTSymbol source;

    this(this.name, this.mutable, this.infer, this.type, this.source, this.locRange=__CALLER__)
    {
        assert(!!source);
        assert(infer == !type);
    }

    override (StatementCompileResult | Error) compile(Context context)
    {
        return this.locRange.fail(
            "This syntax is disabled at the moment until I figure out what to use it for.");
        auto source = this.source.compile(context)?.beExpressionImplCall(context, this.locRange)?;
        nullable Either sourceType = source.type.instanceOf(Either);
        if (!sourceType) {
            // either can also turn nullables into non-nullables
            // TODO do we really want that? really?
            if (context.compiler.isClassType(source.type) && source.type.zeroInitializable) {
                return compileObjectDenullFallback(context, source);
            }
        }
        auto sourceType = sourceType?
            else return context.fail(this.locRange, "Source type for extract decl must be sumtype");

        mut uninitialized Type type;
        if (this.type) type = this.type.compile(context)?.beType(this.locRange)?;
        else type = typeWithoutFail(sourceType);

        bool inTargetType(Type source) {
            if (auto either = type.instanceOf(Either))
                return [any a.type.same(source) for a in either.types];
            return type.same(source);
        }

        auto name = this.name.case(null: "", ASTIdentifierSymbol sym: sym.name(context.warmContext));
        auto decl = new VariableDeclaration(
            context.namespace, name, context, type, mut=this.mutable, borrowed=false, hidden=false);
        auto astType = new ASTSymbolHelper(type);

        mut ASTEitherCaseExprCase[] cases;
        for (i, entry in sourceType.types) {
            auto sourceMemberType = entry.type;
            bool return_ = !sourceMemberType.inTargetType;
            // auto expr = (context.compiler.$expr return a) if return_
            //     else context.compiler.$expr ({ $astType x = a; x; });
            auto expr = new ASTReturn(new ASTIdentifier("a", false)) if return_
                else context.compiler.$expr ({ $astType x = a; x; });
            cases ~= ASTEitherCaseExprCase(
                locRange=this.locRange,
                type=new ASTSymbolHelper(sourceMemberType),
                identifier="a",
                fail=entry.fail,
                expr=expr);
        }

        auto switch_ = new ASTEitherCaseExpr(this.locRange, this.source, cases);
        auto switchExpr = switch_.compile(context)?.beExpression?;
        auto initStmt = decl.initialize(context, switchExpr, switch_.locRange)?;
        return StatementCompileResult(initStmt, decl);
    }

    (StatementCompileResult | Error) compileObjectDenullFallback(Context context, Expression source) {
        mut uninitialized Type type;
        if (this.type) type = this.type.compile(context)?.beType(this.locRange)?;
        else type = source.type.makeNotNullable;
        assert(type.same(source.type.makeNotNullable));

        auto astSource = new ASTSymbolHelper(source);
        auto astType = new ASTSymbolHelper(type);
        auto initial = context.compiler.$expr ({
            mut uninitialized $astType result;
            if (auto a = $astSource) result = a;
            else return null;
            result;
        });
        auto name = this.name.case(null: "", ASTIdentifierSymbol sym: sym.name(context.warmContext));
        auto decl = new VariableDeclaration(
            context.namespace, name, context, type, mut=this.mutable, borrowed=false, hidden=false);

        context.pushErrorLoc(this.locRange);
        auto initialExpr = initial.compile(context)?.beExpression(initial.locRange)?;
        auto initStmt = decl.initialize(context, initialExpr, initial.locRange)?;
        auto ret = StatementCompileResult(initStmt, decl);
        context.popErrorLoc;
        return ret;
    }

    /*
    FIXME: static in class
    static ASTVarExtractDeclStatement fromVarDecl(ASTVarDeclStatement decl)
    {
        return new ASTVarExtractDeclStatement(
            name=decl.name, auto_=decl.infer, type=decl.type,
            source=decl.initial, locRange=decl.locRange);
    }
    */
}

ASTVarExtractDeclStatement extractFromVarDecl(ASTVarDeclStatement decl)
{
    return new ASTVarExtractDeclStatement(
        name=decl.name, mutable=decl.mutable, infer=decl.infer, type=decl.type,
        source=decl.initial? else die, locRange=decl.locRange);
}

(nullable ASTVarExtractDeclStatement | Error) parseVarExtractDecl(ParserImpl parser, LexicalContext lexicalContext)
{
    parser.begin;
    mut bool infer = false;
    mut bool mutable = false;
    mut nullable ASTSymbol type;
    // TODO
    // if (parser.acceptIdentifier("mut")) mutable = true;
    if (parser.acceptIdentifier("auto")) {
        infer = true;
    } else {
        type = parser.parseType(lexicalContext)?;
        if (!type)
        {
            if (mutable) infer = true;
            else {
                parser.revert;
                return null;
            }
        }
    }
    auto decl = parseVarInitialization(
        parser, lexicalContext, infer, mutable, uninitialized=false, type, "<-", requireInitializer=true
    )?? else ({
        parser.revert;
        return null;
    });
    parser.commit;
    return extractFromVarDecl(decl);
}

class ASTNestedFunctionDeclStatement : ASTStatement
{
    // Multiple functions in sequence can mutual-recurse.
    ASTSymbolDeclaration[] astFuns;

    this(this.astFuns) { }

    override (StatementCompileResult | Error) compile(Context context)
    {
        mut Namespace allFunsNamespace = context.namespace;
        mut LatentNestedFunction[] latents;
        for (astFun in this.astFuns) {
            auto fun = astFun.compileSymbol(context)?;
            auto latent = fun.instanceOf(LatentNestedFunction)? else die;

            allFunsNamespace = new SymbolAlias(allFunsNamespace, latent.fun.name, latent);
            latents ~= latent;
        }
        // Actually enable mutual nested recursion.
        for (i, latent in latents) {
            latent.fun.parent = allFunsNamespace;
            latent.fun.resetMangleCache;
        }
        return StatementCompileResult(new NoopStatement, allFunsNamespace);
    }

    override string repr() => "declare [" ~ [join with ", " fun.name.repr for fun in astFuns] ~ "]";
}

(nullable ASTNestedFunctionDeclStatement | Error) parseNestedFunctionDecls(
    Parser parser, LexicalContext lexicalContext)
{
    mut ASTSymbolDeclaration[] funs;
    // TODO while (auto x = y)
    while (true) {
        if (auto fun = parseFunction(parser, lexicalContext)?)
            funs ~= fun.instanceOf(ASTSymbolDeclaration)? else die;
        else break;
    }
    if (!funs.empty)
        return new ASTNestedFunctionDeclStatement(funs);
    return null;
}

class ASTNestedFunctionDeclExpr : ASTSymbol
{
    ASTParameter[] params;

    ASTStatement stmt;

    MacroState macroState;

    this(this.params, this.stmt, this.macroState, this.locRange=__CALLER__) {}

    override (Symbol | Error) compile(Context context) {
        string name = "__nested_literal_$(this.locRange.from.row)_$(context.getLabel)";
        auto nameSym = context.compiler.astIdentifier(name);
        auto fun = new ASTFunction(
            nameSym, :auto_, this.params, isDeclaration=false,
            this.locRange, this.stmt, this.macroState, comment=null);

        auto resolvedFun = fun.compileSymbol(context)?
            .instanceOf(LatentNestedFunction)?
            .resolve(context.framePointer, context.frameDepth, this.locRange)?
            else die;
        auto astSym = new ASTSymbolHelper(resolvedFun);
        auto astRef = new ASTReference(astSym, this.locRange);
        return astRef.compile(context);
    }

    override string repr() { return "ASTNestedFunctionDeclExpr((...) $(stmt.repr)).repr"; }
}

(nullable ASTNestedFunctionDeclExpr | Error) parseNestedFunctionExpr(
    Parser parser, LexicalContext lexicalContext)
{
    with (parser.transaction) {
        if (!parser.acceptToken(TokenType.lparen)) {
            return null;
        }
        auto from = parser.from;
        auto params = parseParameterList(parser, lexicalContext, variadic=false, thisAssignment=false)
            .case(Error err: return null);

        // Require `() => val` or `() { ... }`.
        // Otherwise the parsing gets into weird loops around `()` expressions.
        parser.begin;
        bool looksLikeLambda = parser.acceptToken(TokenType.lcurlybracket)
            || parser.acceptToken2(TokenType.equal, TokenType.greater);
        parser.revert;
        if (!looksLikeLambda) return null;
        commit;

        assert(!params.variadic);
        (ASTParameter | Error) pick((ASTParameter | ASTThisAssignment) value) {
            value.case {
                ASTParameter p: return p;
                ASTThisAssignment a: return parser.fail("cannot have this-assignment in nested function literal");
            }
        }
        auto params = [pick(entry)? for entry in params.params];
        ASTStatement stmt = lexicalContext.compiler.parseStatement(parser, lexicalContext)?;
        auto locRange = parser.to(from);
        return new ASTNestedFunctionDeclExpr(params, stmt, lexicalContext.macroState, locRange);
    }
}

class ASTWhile : ASTStatement
{
    ASTSymbol cond;

    ASTStatement body_;

    this(this.cond, this.body_, this.locRange=__CALLER__) { }

    override (StatementCompileResult | Error) compile(Context context)
    {
        auto label = context.getLabel;
        auto loopContext = context.withNamespace(new LabelLoopScope(label, context.namespace));
        auto condExpr = this.cond.compile(loopContext)?
            .beExpressionImplCall(context, this.locRange)?
            .truthy2(context, this.locRange)?;
        auto bodyPair = this.body_.compile(loopContext)?;
        auto bodyPairContext = loopContext.withNamespace(bodyPair.namespace);
        auto bodyStmt = unwindScope(bodyPairContext, context.namespace, bodyPair.statement)?;

        return StatementCompileResult(
            new Loop(label, null, condExpr, bodyStmt, null, this.locRange),
            context.namespace);
    }
}

(nullable ASTWhile | Error) parseWhile(ParserImpl parser, LexicalContext lexicalContext, LocRange from)
{
    parser.expectToken(TokenType.lparen)?;
    ASTSymbol cond = parseExpression(parser, lexicalContext)??
        else return parser.fail("while condition expected");
    parser.expectToken(TokenType.rparen)?;
    ASTStatement body_ = parseStatement(parser, lexicalContext)?;

    return new ASTWhile(cond, body_, parser.to(from));
}

class ASTStatementExpression : ASTSymbol
{
    ASTStatement[] statements;

    ASTSymbol expr;

    this(this.statements, this.expr, this.locRange=__CALLER__) {
        for (statement in this.statements)
            assert(!!statement);
        assert(!!expr);
    }

    override (Expression | Error) compile(Context context) {
        mut Context context = context;
        auto baseNamespace = context.namespace;
        auto statements = new Statement mut[](this.statements.length);
        for (i, statement in this.statements) {
            auto result = statement.compile(context)?;

            statements[i] = result.statement;
            context = context.withNamespace(result.namespace);
        }
        auto resultValue = this.expr.compile(context)?.beExpressionImplCall(context, locRange)?;
        auto resultType = resultValue.type;

        auto temp = new PairedTemporaryExpr(resultType, Lifetime.none, context.getUniqueId);

        (Statement | Error) initEscapeValue() {
            if (resultValue.info.lifetime == Lifetime.gifted)
                return new InitializeTemporaryExprStatement(temp, resultValue);
            return new InitializeTemporaryExprStatement(temp, resultValue.copy(context, this.locRange)?);
        }

        auto sequence = new SequenceStatement(statements.freeze ~ initEscapeValue?);
        // unwind variables declared in the ({ })
        auto stmtExpr = unwindScope(context, baseNamespace, sequence)?;

        return new StatementExpression(stmtExpr, temp, true);
    }
}

// ({ ...; ...; })
// value of last expression is value of statement expression
(nullable ASTStatementExpression | Error) parseStatementExpr(ParserImpl parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from;
    if (!parser.acceptToken2(TokenType.lparen, TokenType.lcurlybracket)) {
        parser.revert;
        return null;
    }
    parser.commit;
    mut ASTStatement[] statements;
    while (!parser.acceptToken2(TokenType.rcurlybracket, TokenType.rparen)) {
        (void | Error) appendStatement() {
            statements ~= parseStatement(parser, lexicalContext)?;
        }
        parser.verifyTransactions("statement parse rule imbalance", &appendStatement)?;
    }
    if (statements.length == 0) return parser.fail("expected at least one statement");

    if (auto exprStmt = statements[$ - 1].instanceOf(ASTExprStatement))
        return new ASTStatementExpression(statements[0 .. $ - 1], exprStmt.value, parser.to(from));

    return parser.fail("last statement in statement expression must be an expression");
}

class ASTForLoop : ASTStatement
{
    ASTStatement declareLoopVar;

    ASTSymbol condition;

    ASTStatement step;

    ASTStatement body_;

    this(this.declareLoopVar, this.condition, this.step, this.body_, this.locRange=__CALLER__) { }

    override (StatementCompileResult | Error) compile(Context context)
    {
        auto declPair = this.declareLoopVar.compile(context)?;
        auto forScope = context.withNamespace(declPair.namespace);
        Expression condition = this.condition.compile(forScope)?.beExpressionImplCall(context, this.locRange)?;
        auto stepPair = this.step.compile(forScope)?;

        string label = context.getLabel;
        Namespace declScope = new LabelLoopScope(label, forScope.namespace);
        Context breakContScope = forScope.withNamespace(declScope);
        auto bodyPair = this.body_.compile(breakContScope)?;

        return StatementCompileResult(
            new Loop(label, declPair.statement, condition, bodyPair.statement, stepPair.statement, this.locRange),
            context.namespace);
    }
}

(nullable ASTForLoop | Error) parseFor(ParserImpl parser, LexicalContext lexicalContext, LocRange from)
{
    parser.expectToken(TokenType.lparen)?;
    ASTVarDeclStatement varDecl = parseVarDecl(parser, lexicalContext, requireInitializer=false)??
        else return parser.fail("loop declaration expected");
    parser.expectToken(TokenType.semicolon)?;
    ASTSymbol condition = parseExpression(parser, lexicalContext)??
        else return parser.fail("loop condition expected");
    parser.expectToken(TokenType.semicolon)?;
    ASTStatement step = parseForStep(parser, lexicalContext)??
        else return parser.fail("loop step expected");
    parser.expectToken(TokenType.rparen)?;
    ASTStatement body_ = parseStatement(parser, lexicalContext)?;

    return new ASTForLoop(varDecl, condition, step, body_, parser.to(from));
}

/**
 * Parse a statement that indicates to the quoter that an ASTStatement variable should be inserted.
 */
(nullable ASTStatementQuote | Error) parseStatementQuote(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from;
    if (!parser.acceptToken(TokenType.dollar) || !parser.acceptIdentifier("stmt")) {
        parser.revert;
        return null;
    }
    parser.commit;
    auto variable = parser.parseIdentifier;
    if (!variable.length) return parser.fail("ASTStatement variable expected");
    auto variableSym = new ASTIdentifier(variable, false);
    parser.expectToken(TokenType.semicolon)?;
    auto token = lexicalContext.allocQuoteToken(variableSym, QuoteTokenCategory.statement)?;
    return new ASTStatementQuote(lexicalContext.quoteScope, token, parser.to(from));
}

/**
 * As above, but this time the quote is allowed to resolve to any ASTSymbol.
 * TODO: Better name?
 */
(nullable ASTSymbol | Error) parseLeafIdentifierSymbol(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from;
    bool quoted = parser.acceptToken(TokenType.dollar);
    auto fromIdent = parser.from;
    auto ident = parser.parseIdentifier;
    if (ident.empty) {
        parser.revert;
        return null;
    }
    parser.commit;
    auto locIdent = parser.to(fromIdent);
    auto astIdent = new ASTIdentifier(ident, moduleLevel=false, locIdent);
    if (!quoted) return astIdent;
    auto token = lexicalContext.allocQuoteToken(astIdent, QuoteTokenCategory.symbol)?;
    return new ASTSymbolQuote(lexicalContext.quoteScope, token, parser.to(from));
}

(ExtForVarDecl | fail :fail | Error) parseExtForVarDecl(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from;
    if (parser.acceptIdentifier("auto")) {
        auto ident = parser.parseIdentifierSymbol(lexicalContext)?? else ({
            parser.revert;
            return :fail;
        });
        parser.commit;
        // (auto i in 0..10)
        return (:auto_, parser.to(from), ident);
    }
    {
        auto ident = parseIdentifierSymbol(parser, lexicalContext)?? else ({
            parser.revert;
            return :fail;
        });
        parser.begin;
        // peek ahead
        if (parser.acceptToken(TokenType.comma)
            || parser.acceptIdentifier("in")
            || parser.acceptToken2(TokenType.smaller, TokenType.minus))
        {
            // (i in 0..10)
            parser.revert; // revert peek
            parser.commit; // commit identifier
            return (:none, parser.to(from), ident);
        }
        parser.revert; // revert failed peek
        parser.revert; // revert identifier parse
        parser.begin;
    }
    // (int i in 0..10)
    auto type = parser.parseType(lexicalContext)?? else ({
        parser.revert;
        return :fail;
    });
    auto ident = parseIdentifierSymbol(parser, lexicalContext)?? else ({
        parser.revert;
        return :fail;
    });
    parser.commit;
    return (type, parser.to(from), ident);
}

class ASTExtForLoop : ASTStatement
{
    ASTSymbol source;

    ExtForVarDecl var1;

    (ExtForVarDecl | :none) var2;

    ASTStatement body_;

    this(this.source, this.var1, this.var2, this.body_, this.locRange=__CALLER__) { }

    override (StatementCompileResult | Error) compile(Context context)
    {
        auto source = this.source.compile(context)?.beExpressionImplCall(context, locRange)?;
        auto compiler = context.compiler;
        auto astSource = new ASTSymbolHelper(source);

        ASTIdentifierSymbol fix(ASTIdentifierSymbol name) => name;

        if (auto arrayType = source.type.instanceOf(Array)) {
            auto valueMatch = var2.case(ExtForVarDecl a: a, (:none): var1);
            ASTIdentifierSymbol var1name = var1.name;
            auto keyIdent = var2.case(
                ExtForVarDecl a: var1.name.fix,
                (:none): compiler.astIdentifier("__loopvar"));
            ASTSymbol loopType = var2.case(
                ExtForVarDecl a: var1.type.case(
                    (:auto_): compiler.astIdentifier("size_t"),
                    (:none): compiler.astIdentifier("size_t"),
                    ASTSymbol type: type),
                (:none): compiler.astIdentifier("size_t"));

            auto valueIdent = valueMatch.name.fix;
            ASTStatement declIdentifier() {
                if (!arrayType.mutableElements) {
                    return valueMatch.type.case(
                        (:auto_): compiler.$stmt auto $valueIdent = __borrow(__source.ptr[$keyIdent]); ,
                        (:none): compiler.$stmt auto $valueIdent = __borrow(__source.ptr[$keyIdent]); ,
                        ASTSymbol type: compiler.$stmt $type $valueIdent = __borrow(__source.ptr[$keyIdent]); );
                }
                return valueMatch.type.case(
                    (:auto_): compiler.$stmt auto $valueIdent = __source.ptr[$keyIdent]; ,
                    (:none): compiler.$stmt auto $valueIdent = __source.ptr[$keyIdent]; ,
                    ASTSymbol type: compiler.$stmt $type $valueIdent = __source.ptr[$keyIdent]; );
            }
            ASTStatement loop = compiler.$stmt {
                auto __source = $astSource;
                for (mut $loopType $keyIdent = 0; $keyIdent < __source.length; $keyIdent += 1) {
                    $stmt declIdentifier;
                    $stmt body_;
                }
            };
            return loop.compile(context);
        }
        if (var2 != :none) {
            // for (var1, var2 in
            ASTIdentifierSymbol index = var1.name.fix;
            ExtForVarDecl value() {
                var2.case {
                    ExtForVarDecl a: return a;
                    (:none): assert(false);
                }
            }
            auto valueSym = value.name.fix;
            auto valueType = value.type;

            ASTStatement declIdentifier = valueType.case(
                (:auto_): compiler.$stmt auto $valueSym = __source.front; ,
                (:none): compiler.$stmt auto $valueSym = __source.front; ,
                ASTSymbol type: compiler.$stmt $type $valueSym = __source.front; );
            ASTStatement rangeLoop = compiler.$stmt {
                mut size_t $index = 0;
                for (mut auto __source = $astSource; !__source.empty; __source = __source.next) {
                    $stmt declIdentifier;
                    $stmt body_;
                    $index = $index + 1;
                }
            };
            return rangeLoop.compile(context);
        }
        auto valueSym = var1.name.fix;

        ASTStatement declIdentifier = var1.type.case(
            (:auto_): compiler.$stmt auto $valueSym = __source.front; ,
            (:none): compiler.$stmt auto $valueSym = __source.front; ,
            ASTSymbol type: compiler.$stmt $type $valueSym = __source.front; );
        ASTStatement rangeLoop = compiler.$stmt {
            for (mut auto __source = $astSource; !__source.empty; __source = __source.next) {
                $stmt declIdentifier;
                $stmt body_;
            }
        };
        context.pushErrorLoc(this.locRange);
        auto ret = rangeLoop.compile(context);
        context.popErrorLoc;
        return ret;
    }
}

// This is a placeholder for proper range semantics.
(nullable ASTStatement | Error) parseExtFor(ParserImpl parser, LexicalContext lexicalContext, LocRange from)
{
    parser.begin;
    parser.expectToken(TokenType.lparen)?;
    auto compiler = lexicalContext.compiler;
    // TODO: parseExtForVarDecl(...).discard((:fail): { parser.revert; return null; });
    auto match1 = parseExtForVarDecl(parser, lexicalContext);
    mut uninitialized ExtForVarDecl match1decl;
    match1.case {
        (:fail): {
            parser.revert;
            return null;
        }
        Error e: { parser.revert; return e; }
        ExtForVarDecl decl: {
            match1decl = decl;
        }
    }
    mut bool keyValueLoop = false;
    mut uninitialized ExtForVarDecl match2decl;
    if (parser.acceptToken(TokenType.comma)) {
        parseExtForVarDecl(parser, lexicalContext).case {
            (:fail): {
                parser.revert;
                return null;
            }
            Error e: { parser.revert; return e; }
            ExtForVarDecl decl: {
                match2decl = decl;
            }
        }
        keyValueLoop = true;
    }
    if (parser.acceptToken2(TokenType.smaller, TokenType.minus)) {
        print("warn: $(parser.to(from).repr(lexicalContext.compiler.fileIdTable)): use 'in'");
    } else if (!parser.acceptIdentifier("in")) {
        parser.revert;
        return null;
    }
    auto source = parseExpression(parser, lexicalContext)??
        else return parser.fail("expression expected");
    // array loop, for (i, k in array)
    parser.expectToken(TokenType.rparen)?;
    auto body_ = parseStatement(parser, lexicalContext)?;
    parser.commit;

    if (keyValueLoop) {
        return new ASTExtForLoop(source, match1decl, match2decl, body_, parser.to(from));
    }
    return new ASTExtForLoop(source, match1decl, :none, body_, parser.to(from));
}

class ASTDestroy : ASTSymbol
{
    ASTSymbol target;

    this(this.target, this.locRange=__CALLER__) { }

    override (Expression | Error) compile(Context context) {
        auto expr = this.target.compile(context)?.beExpressionImplCall(context, locRange)?;
        auto stmt = destroy(context, expr, this.locRange);
        if (!stmt) return once new VoidExpression;
        return new StatementExpression(stmt, once new VoidExpression, false);
    }
}

// manually end lifetime of a value
(nullable ASTSymbol | Error) parseDestroy(ParserImpl parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from;
    if (!parser.acceptIdentifier("__destroy")) {
        parser.revert;
        return null;
    }
    parser.expectToken(TokenType.lparen)?;
    nullable ASTSymbol target = parseExpression(parser, lexicalContext)?;
    if (!target) return parser.fail("expression expected");
    parser.expectToken(TokenType.rparen)?;
    parser.commit;

    return new ASTDestroy(target? else die, parser.to(from));
}

class ASTStaticIfStatement : ASTStatement
{
    ASTSymbol cond;
    ASTStatement then;
    ASTStatement else_;
    this(this.cond ,this.then, this.else_, this.locRange=__CALLER__) { }
    override (StatementCompileResult | Error) compile(Context context) {
        auto tern = staticTruthy(context, this.cond);

        tern.case {
            bool b: {
                if (b) return this.then.compile(context);
                else return this.else_.compile(context);
            }
            (:unknown): {
                return this.locRange.fail("cannot statically evaluate condition: "
                    ~ this.cond.repr);
            }
            Error err: return err;
        }
        assert(false);
    }
}

(nullable ASTStaticIfStatement | Error) parseStaticIfStmt(
    ParserImpl parser, LexicalContext lexicalContext, bool version_, LocRange from)
{
    mut uninitialized ASTSymbol cond;
    if (version_) {
        parser.expectToken(TokenType.lparen)?;
        string versionStr = parser.parseIdentifier;
        parser.expectToken(TokenType.rparen)?;
        auto versionSym = lexicalContext.compiler.astStringLiteral(versionStr);
        cond = new ASTTrait("versionSet", [versionSym]);
    } else {
        // static if
        parser.expectToken(TokenType.lparen)?;
        cond = parser.parseExpression(lexicalContext)??
            else return parser.fail("static if condition expected");
        parser.expectToken(TokenType.rparen)?;
    }

    mut ASTStatement[] then, else_;
    if (parser.acceptToken(TokenType.lcurlybracket)) {
        while (!parser.acceptToken(TokenType.rcurlybracket)) {
            then ~= parser.parseStatement(lexicalContext)?;
        }
    } else {
        then ~= parser.parseStatement(lexicalContext)?;
    }
    if (parser.acceptIdentifier("else")) {
        if (parser.acceptToken(TokenType.lcurlybracket)) {
            while (!parser.acceptToken(TokenType.rcurlybracket)) {
                else_ ~= parser.parseStatement(lexicalContext)?;
            }
        } else {
            else_ ~= parser.parseStatement(lexicalContext)?;
        }
    }
    return new ASTStaticIfStatement(
        cond,
        new ASTSequenceStatement(then),
        new ASTSequenceStatement(else_),
        parser.to(from));
}

(nullable ASTDeclaration | Error) parseDeclaration(ParserImpl parser, LexicalContext lexicalContext) {
    parser.begin;
    auto from = parser.from;
    parseImportStatement(parser, lexicalContext)?.case {
        (:none): {}
        ASTImportStatement importStmt:
            parser.commit;
            parser.to(from).assert(!importStmt.isMacroImport, () => "can't import macro in function")?;
            auto pool = lexicalContext.compiler.workPool;
            auto id = importStmt.repr(lexicalContext.pak.name);
            auto task = new ImportTask(id, lexicalContext, importStmt, lexicalContext.moduleParseTaskId);
            auto import_ = new ASTImport(importStmt, (pool, task));

            pool.queue(task);
            return import_;
    }
    parser.revert;
    if (auto aliasDecl = parseAliasDecl(parser, lexicalContext)?) {
        return aliasDecl;
    }
    if (auto structDecl = parseStructDecl(parser, lexicalContext)?) {
        return structDecl;
    }
    if (auto unionDecl = parseUnionDecl(parser, lexicalContext)?) {
        return unionDecl;
    }
    if (auto templateDecl = parseTemplateDecl(parser, lexicalContext)?) {
        return templateDecl;
    }
    return null;
}

/**
 * Parse "the sort of thing that can be in the step of a for loop".
 * This category only exists for the benefit of providing C developers with the familiar for loop step.
 * In C, `i = i + 1` is an expression, but in Neat it's a statement. So this category is a weird chimera,
 * because what it actually describes is 'syntax elements that are expressions in C'.
 */
(nullable ASTStatement | Error) parseForStep(ParserImpl parser, LexicalContext lexicalContext)
{
    if (auto stmt = parseAssignment(parser, lexicalContext)?)
        return stmt;
    if (auto expr = parseExpression(parser, lexicalContext)?) {
        return new ASTExprStatement(expr, expr.locRange);
    }
    return null;
}

(ASTStatement | Error) parseStatement(ParserImpl parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from;
    auto keyword = parser.parseIdentifier;
    if (keyword == "if") {
        parser.commit;
        return parseIf(parser, lexicalContext, from);
    }
    if (keyword == "while") {
        parser.commit;
        return parseWhile(parser, lexicalContext, from);
    }
    if (keyword == "with") {
        parser.commit;
        return parseWithStatement(parser, lexicalContext, from);
    }
    if (keyword == "static" && parser.acceptIdentifier("if")) {
        parser.commit;
        return parseStaticIfStmt(parser, lexicalContext, version_=false, from);
    }
    if (keyword == "version") {
        parser.commit;
        return parseStaticIfStmt(parser, lexicalContext, version_=true, from);
    }
    if (keyword == "for") {
        parser.commit;
        if (ASTStatement stmt = parseExtFor(parser, lexicalContext, from)?) {
            return stmt;
        }
        return parseFor(parser, lexicalContext, from);
    }
    parser.revert;
    if (ASTStatement stmt = parseScope(parser, lexicalContext)?)
        return stmt;
    if (ASTDeclaration decl = parseDeclaration(parser, lexicalContext)?)
        return new ASTDeclarationStatement(decl);
    if (ASTStatement stmt = parseNestedFunctionDecls(parser, lexicalContext)?)
        return stmt;
    if (ASTStatement stmt = parseStatementQuote(parser, lexicalContext)?)
        return stmt;
    if (ASTStatement stmt = parseMultiVarDecl(parser, lexicalContext)?)
        return stmt;
    if (ASTStatement stmt = parseEitherCaseStmt(parser, lexicalContext)?)
        return stmt;
    {
        auto args = new ParseStatementArgs(parser, lexicalContext);
        lexicalContext.macroState.applyMacro(args);
        if (ASTStatement ret = args.statement?) return ret;
    }
    if (ASTStatement stmt = parseForStep(parser, lexicalContext)?) {
        parser.expectToken(TokenType.semicolon)?;
        return stmt;
    }
    return parser.fail("statement expected");
}

class ModuleEntry
{
    string name;

    Symbol value;

    this(this.name, this.value) { }
}

class ASTVersion
{
    string name;

    ASTModuleEntry[] then, else_;

    this(this.name, this.then, this.else_) { }
}

struct ASTModuleEntry
{
    Protection protection;

    (ASTExternFunction | ASTExternVariable
        | ASTDeclaration | ASTUnitTest
        | ASTPragma | ASTVersion
    ) symbol;
}

class ASTModule : ASTModuleBase
{
    string name;

    Package pak;

    string path;

    string moduleParseTaskId;

    mut MacroState macroState;

    // separated from this module with a divergent macro state
    // because we hit a macro declaration
    nullable ASTModule parent;

    int depth; // count from parent = null

    mut ASTModuleEntry[] entries;

    mut ASTDeclaration[string] symbolAliases;

    LocRange locRange;

    this(this.name, this.pak, this.path, this.moduleParseTaskId, this.macroState, this.locRange, this.parent) {
        if (this.parent) this.depth = this.parent.depth + 1;
        this.mangledName = mangleModuleName(this.name, this.pak, this.depth);
    }

    override void addAliasDecl(string name, Protection protection, ASTSymbol target)
    {
        auto nameSym = new ASTIdentifier(name, false);
        auto decl = new ASTAliasDecl(nameSym, target);
        this.entries ~= ASTModuleEntry(protection, decl);
        if (this.symbolAliases.has(name)) {
            print("add alias decl $name: duplicate");
            assert(false);
        }
        this.symbolAliases[name] = decl;
    }

    override nullable ASTSymbol getSymbolAlias(string name) {
        if (this.symbolAliases.has(name)) {
            auto decl = this.symbolAliases[name];
            if (auto alias_ = decl.instanceOf(ASTAliasDecl)) {
                return alias_.target;
            }
        }
        return null;
    }

    override void addEntry(Protection protection, (ASTExternFunctionBase | ASTPragmaBase | ASTDeclaration) target) {
        this.entries ~= ASTModuleEntry(
            protection,
            target.case(
                ASTExternFunctionBase a: a.instanceOf(ASTExternFunction)? else die,
                ASTPragmaBase a: a.instanceOf(ASTPragma)? else die),
        );
    }
}

string mangleModuleName(string name, Package pak, int depth)
{
    // TODO non-nullable by default
    assert(!!pak);
    mut string mangledName;
    // mangledName = [(a == '.') ? '_' : a for a in name];
    for (i in 0 .. name.length) {
        if (name[i .. i + 1] == ".") mangledName ~= "_";
        else mangledName ~= name[i .. i + 1];
    }
    mut string patchedPakName;
    if (pak.name == "compiler") patchedPakName = "compiler$(itoa(__GENERATION__))";
    else patchedPakName = pak.name;

    string combined = "$(patchedPakName)_module_$mangledName";

    if (depth) return "$(combined)_d$depth";
    return combined;
}

struct Nothing { }

class NotYetResolvedSymbol : PendingSymbol
{
    Resolver resolver;

    int index;

    LocRange locRange;

    this(this.resolver, this.index, this.locRange=__CALLER__) { }

    override (Symbol | Error) resolve() {
        auto entry = resolver.entries[index];
        if (auto resolution = entry.resolution?) {
            return resolution;
        }
        return locRange.fail("Dependency cycle while resolving $(entry.name).");
    }
    override void hash(Hash hash) {
        auto entry = resolver.entries[index];
        entry.resolution.case {
            nullable Symbol sym:
                if (auto sym = sym) {
                    // TODO do we need to handle the other possible symbols?
                    if (auto type = sym.instanceOf(Type)) {
                        type.hash(hash);
                        return;
                    }
                }
            Error err:
                return;
        }
        hash.adds("pending");
        hash.addl(index);
    }
    override string repr() return "TODO NotYetResolvedSymbol";
    override bool mayCallImplicit() => false;
}

struct ResolvingModuleEntry
{
    string name;

    Protection protection;

    bool resolving;

    (nullable Symbol | Error) resolution;

    (ASTFunction | ASTClassDecl | ASTIntfDecl | ASTStructDecl | ASTAliasDecl | ASTUnitTest | Nothing) symbol;

    bool shouldEmit() {
        symbol.case {
            // Avoid double emitting alias targets.
            ASTAliasDecl decl: return false;
            default: return true;
        }
    }
}

class Resolver
{
    mut ResolvingModuleEntry mut[] entries;

    mut size_t[][string] index;

    this() { }

    void add(
        string name,
        Protection protection,
        (ASTFunction | ASTClassDecl | ASTIntfDecl | ASTStructDecl | ASTAliasDecl | ASTUnitTest) astSymbol)
    {
        index[name] = index.get(name, []) ~ this.entries.length;
        this.entries ~= ResolvingModuleEntry(name, protection, false, null, astSymbol);
    }

    void register(string name, Protection protection, Symbol symbol)
    {
        int hit = cast(int) [first i for i in this.index.get(name, []) else -1];
        if (hit == -1) {
            index[name] = [this.entries.length];
            this.entries ~= ResolvingModuleEntry(name, protection, resolving=false, symbol, Nothing());
            return;
        }
        entries[hit].resolution = symbol;
    }

    (nullable Symbol | Error) lookup(Context context, LocRange locRange, string name, Protection protection)
    {
        bool allowed(Protection entry) {
            if (protection == Protection.public_)
                return entry == Protection.public_;
            return true;
        }
        int[] hits = [cast(int) i for i in index.get(name, []) where allowed(entries[i].protection)];
        if (hits.empty) return null;
        // TODO figure out what do here if we have more than one
        if (hits.length == 1 && this.entries[hits[0]].resolving) {
            return new NotYetResolvedSymbol(this, hits[0], locRange);
        }
        for (hit in hits) {
            resolve(context, locRange, hit)?;
        }

        (Symbol | Error) get(int hit) {
            // FIXME when can this be null??
            mut auto ret = this.entries[hit].resolution?? else die;
            if (auto latent = ret.instanceOf(LatentSymbol)) {
                // we're at global scope; no frame pointer will be applied.
                assert(!context.framePointer);
                ret = latent.resolve(null, :none, locRange)?;
            }
            return ret;
        }

        mut Symbol[] syms = [get(hit)? for hit in hits];
        if (syms.length == 1) return syms[0];
        return new Overload(syms);
    }

    (void | Error) resolve(Context context, LocRange locRange, int i)
    {
        if (this.entries[i].resolution.case(Error err: true, nullable Symbol sym: !sym)) {
            if (this.entries[i].resolving)
            {
                return locRange.fail("Dependency cycle while resolving $(this.entries[i].name).");
            }
            this.entries[i].resolving = true;
            // TODO ASTSymbolDeclaration now combines many of those
            this.entries[i].resolution = this.entries[i].symbol.case(
                // TODO compile function statement immediately too
                ASTFunction fun: fun.compileSymbol(context).case(
                    Symbol sym: sym.instanceOf(FunctionDeclaration)? else die,
                    Error err: err),
                ASTUnitTest ut: ut.compile(context),
                ASTClassDecl decl: decl.compileSymbol(context),
                ASTIntfDecl decl: decl.compileSymbol(context),
                ASTStructDecl struct_: struct_.compileSymbol(context),
                ASTAliasDecl decl: decl.target.compile(context),
                Nothing _: ({ assert(false); cast(Symbol) null; }));
            this.entries[i].resolving = false;
        }
    }

    (void | Error) resolveAll(Context context)
    {
        for (i in 0 .. this.entries.length) {
            resolve(context, __RANGE__, cast(int) i)?;
        }
    }
}

class Module : ModuleBase
{
    // whenever macro state changes, we begin a new submodule
    // when this happens, this member references the previous module.
    nullable Module parentModule;

    Resolver resolver;

    mut (FinishedSymbol | Symbol)[] anonymousEntries;

    // filled in by compile()
    mut FinishedSymbol[] finishedSymbols;

    LocRange locRange;

    // Inert imports have no lookup effect, they solely define a module dependency
    mut (Module mod, (:inert|:private_|:public_) visibility, string[] symbols)[] imports;

    // so we can make a CompilationTask->ParseAstModuleTask dep
    string moduleParseTaskId;

    this(this.name, this.mangledName, this.locRange, this.parentModule, this.moduleParseTaskId) {
        this.isContextScope = false;
        this.resolver = new Resolver;
    }

    void add(
        string name, Protection protection,
        (ASTFunction | ASTClassDecl | ASTIntfDecl | ASTStructDecl | ASTAliasDecl | ASTUnitTest) symbol)
    {
        this.resolver.add(name, protection, symbol);
    }

    override void track((Symbol | FinishedSymbol) symbol)
    {
        this.anonymousEntries ~= symbol;
    }

    void register(string name, Protection protection, Symbol symbol)
    {
        this.resolver.register(name, protection, symbol);
    }

    override void addImport(ModuleBase module_, bool public_, string[] symbols) {
        auto module_ = module_.instanceOf(Module)? else die;
        // TODO error?
        // TODO merge symbols?
        if ([any a.mod.mangledName == module_.mangledName for a in this.imports])
            return;
        if (public_)
            this.imports ~= (module_, :public_, symbols);
        else
            this.imports ~= (module_, :private_, symbols);
    }

    override void addModuleDependency(ModuleBase module_) {
        string[] empty;
        // TODO , [])
        this.imports ~= (module_.instanceOf(Module)? else die, :inert, empty);
    }

    override string mangle() { return this.mangledName; }

    void walkModules(bool delegate!(Module) cb)
    {
        if (this.parentModule)
            this.parentModule.walkModules(cb);
        if (!cb(this)) return;
        [import_.mod.walkModules(cb) for import_ in imports];
    }

    override (void | Error) compile(Context context)
    {
        auto context = context.withCompilingModule(this);

        this.resolver.resolveAll(context)?;

        (void | Error) walkSymbols((void | Error) delegate!((Symbol | FinishedSymbol)) dg) {
            for (entry in this.resolver.entries) {
                if (entry.shouldEmit) {
                    dg(entry.resolution?? else die)?;
                }
            }
            // must be a regular for loop so we can add entries during iteration
            for (mut int i = 0; i < this.anonymousEntries.length; i += 1) {
                dg(anonymousEntries[i])?;
            }
        }

        (void | Error) resolveClassIntf((Symbol | FinishedSymbol) sym) {
            sym.case {
                Symbol sym: {
                    if (auto classType = sym.instanceOf(ClassType)) {
                        classType.class_.resolve(context)?;
                    }
                    if (auto intfType = sym.instanceOf(IntfType)) {
                        intfType.intf.resolve(context)?;
                    }
                }
                FinishedSymbol sym: { }
            }
        }

        assert(finishedSymbols.length == 0);
        (void | Error) compileSymbol((Symbol | FinishedSymbol) symbol) {
            symbol.case {
                Symbol symbol: {
                    if (Function fun = symbol.instanceOf(Function)) {
                        finishedSymbols ~= fun.compile(context)?;
                    }
                    if (IntfType intfType = symbol.instanceOf(IntfType)) {
                        finishedSymbols ~= new DefineClassIntf(intfType.intf);
                    }
                    if (ClassType classType = symbol.instanceOf(ClassType)) {
                        finishedSymbols ~= new DefineClassIntf(classType.class_);
                        for (method in classType.class_.methods)
                            finishedSymbols ~= method.compile(context)?;
                    }
                }
                FinishedSymbol symbol:
                    finishedSymbols ~= symbol;
            }
        }

        /**
         * TODO
         * This is hacky as heck.
         * It's written by just poking things until it works.
         * Work out a saner way.
         */
        walkSymbols(&resolveClassIntf)?;
        walkSymbols(&compileSymbol)?;
    }

    void emit(Generator generator)
    {
        if (!generator.once(mangle))
            return;

        assert(!generator.fun);

        [symbol.emit(generator) for symbol in this.finishedSymbols];
    }

    // TODO merge import search with lookup()
    (nullable Symbol | Error) lookupPublic(Context context, LocRange locRange, string name)
    {
        // not counting imports (non-transitive)
        if (auto ret = this.resolver.lookup(context, locRange, name, Protection.public_)?) return ret;
        // transitive public import search
        for (import_ in this.imports) {
            // FIXME !=
            if (!import_.visibility.case((:inert): false, (:private_): false, (:public_): true))
                continue;
            // TODO yet another import class? struct? we've written this line three times now...
            auto importMod = import_.mod;
            assert(!!importMod);
            if (!import_.symbols.length || [any a == name for a in import_.symbols]) {
                if (Symbol entry = importMod.lookupPublic(context, locRange, name)?)
                    return entry;
            }
        }
        if (this.parentModule)
            return this.parentModule.lookupPublic(context, locRange, name);
        return null;
    }

    override (nullable Symbol | Error) lookup(
        string name, Context context, LookupReason reason, LocRange locRange)
    {
        if (!!context.framePointer) {
            print("error: lookup with frame propagated to Module");
            assert(false);
        }

        this.resolver.lookup(context, locRange, name, Protection.private_).case {
            nullable Symbol sym: if (sym) return sym;
            Error error: return error;
        }
        for (import_ in this.imports) {
            // FIXME !=
            if (import_.visibility.case((:inert): true, (:private_): false, (:public_): false))
                continue;
            auto importMod = import_.mod;
            assert(!!importMod);
            if (!import_.symbols.length || [any a == name for a in import_.symbols]) {
                if (auto sym = importMod.lookupPublic(context, locRange, name)?) return sym;
            }
        }
        assert(!this.parent);
        if (this.parentModule)
            return this.parentModule.lookup(name, context, reason, locRange);
        return null;
    }
}

class ASTExternVariable
{
    ASTSymbol type;

    string name;

    LocRange locRange;

    this(this.type, this.name, this.locRange=__CALLER__) { }

    (ExternCVariable | Error) compile(Context context)
    {
        return new ExternCVariable(this.type.compile(context)?.beType(locRange)?, this.name, threadlocal=false);
    }
}

class ASTExternFunction : ASTExternFunctionBase
{
    ASTSymbol ret;

    ASTParameter[] params;

    bool variadic;

    LocRange retLocRange;

    this(this.name, this.ret, this.params, this.variadic, this.retLocRange) { }

    (FunctionDeclaration | Error) compile(Context context)
    {
        auto params = [.compile(param, context)? for param in this.params];
        auto decl = new FunctionDeclaration(this.name, this.ret.compile(context)?.beType(this.retLocRange)?, params);
        decl.variadic = this.variadic;

        return decl;
    }

    override string repr() {
        string reprParam(ASTParameter param) {
            if (param.name.length == 0) return param.type.repr;
            return param.type.repr ~ " " ~ param.name;
        }
        return "extern(C) $(ret.repr) $name(" ~ [join with ", " reprParam(param) for param in params] ~ ")";
    }
}

(ASTExternFunction | ASTExternVariable | :none | Error) parseExtern(ParserImpl parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from;
    if (!parser.acceptIdentifier("extern"))
    {
        parser.revert;
        return :none;
    }
    parser.commit;
    parser.expectToken(TokenType.lparen)?;
    if (parser.parseIdentifier != "C")
        return parser.fail("calling convention expected");
    parser.expectToken(TokenType.rparen)?;
    auto retFrom = parser.from;
    auto type = parser.parseType(lexicalContext)?? else die;
    auto retLocRange = parser.to(retFrom);
    string name = parser.parseIdentifier;
    if (!name.length) return parser.fail("identifier expected");
    if (parser.acceptToken(TokenType.lparen)) {
        auto paramList = parseParameterList(parser, lexicalContext, variadic=true, thisAssignment=false)?;
        ASTParameter pick((ASTParameter | ASTThisAssignment) value) {
            value.case {
                ASTParameter p: return p;
                ASTThisAssignment a: assert(false);
            }
        }
        auto params = [pick(entry) for entry in paramList.params];
        parser.expectToken(TokenType.semicolon)?;
        return new ASTExternFunction(name, type, params=params, variadic=paramList.variadic, retLocRange);
    } else {
        parser.expectToken(TokenType.semicolon)?;
        return new ASTExternVariable(type, name, parser.to(from));
    }
}

string moduleToFile(string module_)
{
    mut string modulePath;
    for (i in 0 .. module_.length) {
        if (module_[i .. i + 1] == ".") modulePath ~= "/";
        else modulePath ~= module_[i .. i + 1];
    }
    return modulePath ~ ".nt";
}

(string, Package | Error) findFileInPackage(string filename, Package pak, LocRange locRange)
{
    string fileInPackage = pak.path ~ "/" ~ filename;
    if (exists(fileInPackage)) {
        // print(filename ~ " in package '" ~ pak.name ~ "'");
        return (fileInPackage, pak);
    }
    // print(filename ~ " not in package '" ~ pak.name ~ "'");
    for (dep in pak.deps) {
        string fileInDep = dep.path ~ "/" ~ filename;

        if (exists(fileInDep)) {
            // print(filename ~ " in dep package '" ~ dep.name ~ "' of '" ~ pak.name ~ "'");
            return (fileInDep, dep);
        }
        // print(filename ~ " not in dep package '" ~ dep.name ~ "' of '" ~ pak.name ~ "'");
    }
    return locRange.fail("cannot find file '$filename' in package '$(pak.name)' or dependencies");
}

// TODO rewrite this once we have a std.path
(string, Package) findResidualFilename(string filename, Package[] packages)
{
    import package(compiler).std.file : realpath;

    // TODO split then check
    if (!exists(filename)) {
        print("file '$filename' could not be found!");
        assert(false);
    }
    string realFilename = realpath(filename);
    // scan packages in reverse order, so that latter arguments override earlier ones
    for (mut int i = cast(int) packages.length - 1; i >= 0; i -= 1) {
        auto package_ = packages[i];
        string path = package_.path;
        if (realFilename.length >= path.length
            && realFilename[0 .. path.length] == path) {
            // print("file " ~ filename ~ " found as " ~ realFilename[path.length + 1 .. $] ~ " in " ~ package_.name);
            return (realFilename[path.length + 1 .. $], package_);
        }
    }
    for (package_ in packages) {
        print(": $(package_.path)");
    }
    print("file '$filename' is not in folder of any package");
    assert(false);
}

class ImportNamespace : Namespace
{
    Module module_;

    string[] symbols;

    this(this.parent, this.module_, this.symbols) {
        this.isContextScope = this.parent.isContextScope;
    }

    override (nullable Symbol | Error) lookup(
        string name, Context context, LookupReason reason, LocRange locRange)
    {
        if (!symbols.length || [any symbol == name for symbol in symbols]) {
            auto sym = module_.lookupPublic(
                context.withFramePointer(null, :none),
                locRange,
                name)?;
            if (sym) return sym;
        }
        return this.parent.lookup(name, context, reason, locRange);
    }

    override string repr() => "ImportNamespace($(module_.name)) > $(parent.repr)";
}

class AstCompileTask : ITask
{
    string id_;
    ASTModule astModule;
    mut (:none | Module | Error) result;

    ColdContext coldContext;

    this(this.id_, this.astModule, this.coldContext) {
        this.result = :none;
    }

    override string id() => id_;
    override bool fresh() => true;

    (Module | Error) module_() {
        result.case {
            Module m: return m;
            Error error: return error;
            (:none): assert(false);
        }
    }

    override void run(WorkPoolBase workPool) {
        this.coldContext.modulePreProcessor.process(astModule);

        this.result = compileModule(
            astModule, this.coldContext, true);
        this.result.case {
            Module m: m.mangledName;
            Error error: {}
            (:none): {}
        }
    }
}

// Classes do double duty for both module-level and statement-level imports
class ASTImport : ASTDeclaration
{
    ASTImportStatement statement;

    // running in the background
    (WorkPoolBase pool, ImportTask task | ASTModule) moduleSource;

    (ASTModule | Error) module_() {
        this.moduleSource.case {
            (WorkPoolBase pool, ImportTask task): {
                // if the task was not prequeued (ie. an import in a version()),
                // queue it now.
                pool.queue(task);
                pool.dependency(provider=task.id, consumer=:current);
                return pool.wait(task.id).instanceOf(ImportTask)?.module_ else die;
            }
            ASTModule mod: return mod;
        }
    }

    this(this.statement, this.moduleSource) { }

    override (Namespace | Error) compile(Context context) {
        auto id = context.compiler.queueModuleCompilation(context, this.module_?);
        auto module_ = context.compiler.getCompiledModule(id)?.instanceOf(Module)? else die;
        auto namespace = new ImportNamespace(context.namespace, module_, this.statement.symbols);
        auto contextModule = findParent!Module(context.namespace);

        contextModule.addModuleDependency(module_);

        return namespace;
    }
}

class ImportTask : ImportModuleBaseTask
{
    string id_;

    LexicalContext lexicalContext;

    ASTImportStatement import_;

    string moduleParseTaskId;

    mut (ASTModule | :none | Error) result;

    this(this.id_, this.lexicalContext, this.import_, this.moduleParseTaskId) {
        this.result = :none;
    }

    override string id() => id_;
    override bool fresh() => true;

    override (ASTModule | Error) module_() {
        result.case {
            ASTModule mod: return mod;
            Error err: return err;
            (:none): assert(false);
        }
    }

    override void run(WorkPoolBase workPool) {
        workPool.dependency(provider=id_, consumer=moduleParseTaskId);

        void seterror(Error error) { this.result = error; }
        import neat.macrocache : loadMacroCache;
        auto cached = loadMacroCache(id_).case(Error e: return seterror(e));
        if let (auto cached = cached.case(:missing: breakelse)) {
            // add "fake" bom from cache
            auto bom = cached.bom;
            for (key in bom.keys) {
                lexicalContext.compiler.workPool.addBomItem(key, bom[key]);
            }

            auto macroState = new MacroState;
            for (entry in cached.records) {
                neat_runtime_dlcall(entry.soname, entry.fnname, macroState);
                macroState.records ~= entry;
            }

            // fake macro import module, will only be used for its macro state
            // TODO: (ASTModule | MacroState | ...) result;
            this.result = new ASTModule(name="", new Package(name="cachestub", "", []),
                path="", moduleParseTaskId="", macroState=macroState, locRange=__RANGE__,
                parent=null);
            return;
        }
        this.result = this.lexicalContext.resolveImport(import_).case(
            ASTModuleBase base: base.instanceOf(ASTModule)? else die,
            Error err: err);
        if (import_.isMacroImport) {
            import neat.macrocache : saveMacroCache;
            auto bom = lexicalContext.compiler.workPool.bom(id_);
            if let (auto records = module_.case(Error: breakelse).macroState.records) {
                saveMacroCache(id, bom, records).case(Error e: return seterror(e));
            }
        }
    }
}

extern(C) void neat_runtime_dlcall(string soname, string name, void* arg);

(ASTImportStatement | :none | Error) parseImportStatement(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from;
    bool isMacroImport = parser.acceptIdentifier("macro");
    if (!parser.acceptIdentifier("import")) {
        parser.revert;
        return :none;
    }

    mut uninitialized (
        :normal, string name, string pak |
        :macro_, ASTModuleBase module_ |
        :macroTask, ImportModuleBaseTask task) target;
    parser.commit;

    auto macroArgs = new ParseImportArgs(parser, lexicalContext);
    lexicalContext.macroState.applyMacro(macroArgs);
    if (macroArgs.done) {
        target = macroArgs.getModule(lexicalContext.compiler)?.case(
            ASTModuleBase module_: (:macro_, module_),
            ImportModuleBaseTask task: (:macroTask, task));
    } else {
        mut string pak;
        if (parser.acceptIdentifier("package"))
        {
            parser.expectToken(TokenType.lparen)?;
            pak = parser.parseIdentifier;
            parser.expectToken(TokenType.rparen)?;
            parser.expectToken(TokenType.dot)?;
        }

        string modname = parser.parseModuleName?;
        target = (:normal, modname, pak);
    }

    mut string[] symbols;
    if (!isMacroImport && parser.acceptToken(TokenType.colon)) {
        (string | Error) expectIdentifier(Parser parser) {
            auto ident = parser.parseIdentifier;
            parser.assert_(ident.length > 0, "identifier expected")?;
            return ident;
        }
        // : [symbol] [, symbol]* ,? ;
        symbols ~= parser.expectIdentifier?;
        while (parser.acceptToken(TokenType.comma)) {
            if (parser.peekToken(TokenType.semicolon)) { break; }
            symbols ~= parser.expectIdentifier?;
        }
    }
    parser.expectToken(TokenType.semicolon)?;
    return new ASTImportStatement(target, isMacroImport, symbols, parser.to(from));
}

(string | Error) parseModuleName(Parser parser) {
    mut string ret;
    while (true) {
        ret ~= parser.parseIdentifier;
        if (!parser.acceptToken(TokenType.dot)) break;
        ret ~= ".";
    }
    return ret;
}

(nullable ASTModule | Error) parseMacroContinuation(CompilerBase compiler, ParserImpl parser, ParserHelper helper, ASTModule astModule)
{
    parser.begin;
    auto from = parser.from;
    if (!parser.acceptIdentifier("macro") || !parser.acceptToken(TokenType.lparen))
    {
        parser.revert;
        return null;
    }
    parser.commit;
    string identifier = parser.parseIdentifier;
    parser.expectToken(TokenType.rparen)?;
    parser.expectToken(TokenType.semicolon)?;

    auto newMacroState = astModule.macroState.dup;
    newMacroState.records ~= helper.proxyCall(astModule, identifier, newMacroState, parser.to(from))?;

    auto subModule = new ASTModule(
        astModule.name, astModule.pak, astModule.path, astModule.moduleParseTaskId,
        newMacroState, astModule.locRange, astModule);

    return parseModuleBody(compiler, parser, helper, subModule);
}

(Package | Error) selectPackage(Package[] packages, mut string name, LocRange locRange)
{
    if (name == "compiler$(__GENERATION__)") {
        // reverse generation transform (TODO why does this happen??)
        name = "compiler";
    }
    return [first a for a in packages where a.name == name
        else return locRange.fail("undefined package: '$name' of $(packages)")];
}

class LexicalContextImpl : LexicalContext
{
    ParserHelper helper;

    this(this.compiler, this.pak, this.moduleParseTaskId, this.macroState, this.helper) { }

    override (ASTModuleBase | Error) resolveImport(ASTImportStatementBase importStmt) {
        return .resolveImport(
            compiler, pak.name,
            importStmt.instanceOf(ASTImportStatement)? else die,
            helper);
    }
}

(nullable ASTVersion | Error) parseModuleVersion(ParserImpl parser, LexicalContext lexicalContext)
{
    if (parser.acceptIdentifier("version")) {
        mut ASTModuleEntry[] then, else_;
        parser.expectToken(TokenType.lparen)?;
        string versionStr = parser.parseIdentifier;
        parser.expectToken(TokenType.rparen)?;
        if (parser.acceptToken(TokenType.lcurlybracket)) {
            while (!parser.acceptToken(TokenType.rcurlybracket)) {
                then ~= parser.parseModuleEntry(lexicalContext, false)?;
            }
        } else {
            then ~= parser.parseModuleEntry(lexicalContext, false)?;
        }
        if (parser.acceptIdentifier("else")) {
            if (parser.acceptToken(TokenType.lcurlybracket)) {
                while (!parser.acceptToken(TokenType.rcurlybracket)) {
                    else_ ~= parser.parseModuleEntry(lexicalContext, false)?;
                }
            } else {
                else_ ~= parser.parseModuleEntry(lexicalContext, false)?;
            }
        }
        return new ASTVersion(versionStr, then, else_);
    }
    return null;
}

(Protection protection, ASTImport import_ | :none | Error) parseImport(
    ParserImpl parser, LexicalContext lexicalContext, bool toplevel)
{
    parser.begin;
    mut Protection protection = Protection.private_;
    if (parser.acceptIdentifier("public")) {
        protection = Protection.public_;
    } else if (parser.acceptIdentifier("private")) {
        protection = Protection.private_;
    }

    parseImportStatement(parser, lexicalContext).case {
        Error err:
            parser.revert;
            return err;
        (:none):
            parser.revert;
            return (:none);
        ASTImportStatement importStmt:
            parser.commit;
            if (!toplevel && importStmt.isMacroImport) {
                return parser.fail("macro import not allowed here");
            }

            auto pool = lexicalContext.compiler.workPool;
            auto id = importStmt.repr(lexicalContext.pak.name);
            auto task = new ImportTask(id, lexicalContext, importStmt, lexicalContext.moduleParseTaskId);
            auto import_ = new ASTImport(importStmt, (pool, task));

            // If not toplevel, the import may be conditional.
            if (toplevel) pool.queue(task);

            return (protection, import_);
    }
}

(ASTModuleEntry | Error) parseModuleEntry(ParserImpl parser, LexicalContext lexicalContext, bool toplevel)
{
    parseImport(parser, lexicalContext, toplevel)?.case {
        (Protection protection, ASTImport import_):
            return ASTModuleEntry(protection, import_);
        (:none): {}
    }

    mut (Protection | :none) protection = :none;
    if (parser.acceptIdentifier("public")) {
        protection = Protection.public_;
    } else if (parser.acceptIdentifier("private")) {
        protection = Protection.private_;
    }
    Protection getProtection() {
        return protection.case(
            Protection p: p,
            (:none): Protection.public_);
    }

    if (auto sym = parseTemplateContents(parser, lexicalContext)?) {
        return ASTModuleEntry(getProtection, sym);
    }
    if (auto decl = lexicalContext.compiler.parseDeclaration(parser, lexicalContext)?) {
        return ASTModuleEntry(getProtection, decl);
    }
    parseExtern(parser, lexicalContext).case {
        ASTExternFunction fun: {
            return ASTModuleEntry(getProtection, fun);
        }
        ASTExternVariable var: {
            return ASTModuleEntry(getProtection, var);
        }
        (:none): {}
        Error err: return err;
    }
    if (ASTUnitTest ut = parseUnitTest(parser, lexicalContext)?) {
        return ASTModuleEntry(getProtection, ut);
    }
    if (ASTPragma pragma_ = parsePragma(parser, lexicalContext)?) {
        return ASTModuleEntry(getProtection, pragma_);
    }
    if (ASTVersion version_ = parseModuleVersion(parser, lexicalContext)?) {
        protection.case {
            Protection p: {
                string repr(Protection p) {
                    if (p == Protection.public_) return "public";
                    if (p == Protection.private_) return "private";
                    if (p == Protection.protected_) return "protected";
                    assert(false);
                }
                return parser.fail("unsupported '$(p.repr)' qualifier on 'version' block");
            }
            (:none): {}
        }
        return ASTModuleEntry(Protection.public_, version_);
    }

    return parser.fail("couldn't parse function or struct");
}

(ASTModule | Error) parseModuleBody(CompilerBase compiler, ParserImpl parser, ParserHelper helper, ASTModule module_)
{
    mut LexicalContext lexicalContext = new LexicalContextImpl(
        compiler, module_.pak, moduleParseTaskId=module_.moduleParseTaskId,
        module_.macroState, helper);

    /*
     * Why is there a group of import statements?
     * For performance reasons, it is advantageous to be able to dispatch lots of imports at once.
     * It is elegant to put macro statements first, but every macro statement forces a break in
     * parsing. To counteract this, we parse imports eagerly - we read as many statements as we can
     * with the current parser, being reluctant to generate errors.
     * Only when we can parse no further imports, do we flush to update the macro context.
     * For this reason it is undefined behavior to write a macro that redefines the
     * meaning of valid built-in import statements.
     */
    mut (Protection protection, ASTImport import_)[] importGroup;

    (void | Error) flushImportGroup() {
        for (entry in importGroup) {
            auto protection = entry.protection;
            auto import_ = entry.import_;
            if (!import_.statement.isMacroImport) {
                module_.entries ~= ASTModuleEntry(protection, import_);
                continue;
            }
            auto id = import_.statement.repr(lexicalContext.pak.name);
            auto task = lexicalContext.compiler.workPool.wait(id).instanceOf(ImportTask)? else die;

            module_.macroState = module_.macroState.dup;
            lexicalContext = new LexicalContextImpl(
                compiler, module_.pak, moduleParseTaskId=module_.moduleParseTaskId,
                module_.macroState, helper);

            lexicalContext.compiler.workPool.dependency(provider=id, consumer=:current);
            lexicalContext.macroState.addImport(task.module_?.macroState);
        }
        importGroup = null;
    }

    while (!parser.eof)
    {
        if (ASTModule submod = parseMacroContinuation(compiler, parser, helper, module_)?)
            return submod;

        auto loc = parser.loc;

        auto import_ = parseImport(parser, lexicalContext, toplevel=true);

        import_.case {
            (Protection protection, ASTImport import_):
                importGroup ~= (protection, import_);
                continue;
            Error error:
                if (!importGroup.empty) {
                    flushImportGroup?;
                    continue;
                } else return error;
            (:none):
                flushImportGroup?;
        }

        (void | Error) appendEntry() {
            auto entry = parseModuleEntry(parser, lexicalContext, true)?;

            entry.symbol.case {
                ASTDeclaration decl:
                    if (auto import_ = decl.instanceOf(ASTImport))
                        assert(false);
                    else
                        module_.entries ~= entry;
                default:
                    module_.entries ~= entry;
            }
        }
        parser.verifyTransactions("parse rule imbalance", &appendEntry)?;
    }
    compiler.disposeParser(parser);
    flushImportGroup?;
    return module_;
}

(ASTModule | Error) resolveImport(CompilerBase compiler, string pak, ASTImportStatement import_, ParserHelper helper)
{
    (string name, string pak) target = import_.target.case(
        (:normal, string name, string pak): (name, pak),
        (:macro_, ASTModuleBase module_): return module_.instanceOf(ASTModule)? else die,
        (:macroTask, ImportModuleBaseTask task): return compiler.workPool
            .wait(task.id)
            .instanceOf(ImportModuleBaseTask)
            .module_?.instanceOf(ASTModule)? else die);
    mut Package pak = selectPackage(compiler.allPackages, pak, import_.locRange)?;
    // TODO enum SearchMode { Transitive, Direct, Commandline }
    mut bool transitive = true;
    if (target.pak.length) {
        pak = selectPackage(compiler.allPackages, target.pak, import_.locRange)?;
        transitive = false;
    }
    return getModule(
        compiler, moduleToFile(target.name), pak, true, helper, import_.locRange);
}

(Module | Error) compileModule(ASTModule astModule, ColdContext coldContext, bool addDefaultImports)
{
    mut nullable Module parent = null;
    if (auto astParent = astModule.parent)
    {
        parent = compileModule(astParent, coldContext, addDefaultImports)?;
    }

    string loop() {
        if (coldContext.loopPass == 0) return "";
        return "_loop$(coldContext.loopPass)";
    }

    Module module_ = new Module(
        astModule.name, astModule.mangledName ~ loop, astModule.locRange, parent,
        moduleParseTaskId=astModule.moduleParseTaskId);
    auto coldContext = coldContext.withMacroState(astModule.macroState);
    auto warmContext = makeWarmContext(coldContext.compiler,
        framePointer=null, frameDepth=:none, compilingModule=module_);
    auto context = Context(namespace=module_, warmContext, coldContext);

    if (addDefaultImports) {
        context.compiler.addDefaultImports(context, module_)?;
    }

    // Handle all (toplevel) imports in parallel.
    for (entry in astModule.entries) {
        entry.symbol.case {
            ASTDeclaration decl:
                if (auto import_ = decl.instanceOf(ASTImport))
                    context.compiler.queueModuleCompilation(context, import_.module_?);
            default: {}
        }
    }

    (void | Error) handleEntry(ASTModuleEntry entry)
    {
        entry.symbol.case {
            ASTDeclaration astDecl: {
                if (auto structDecl = astDecl.instanceOf(ASTStructDecl)) {
                    module_.add(structDecl.name.name(warmContext), entry.protection, structDecl);
                } else if (auto aliasDecl = astDecl.instanceOf(ASTAliasDecl)) {
                    module_.add(aliasDecl.name.name(warmContext), entry.protection, aliasDecl);
                } else if (auto templateDecl = astDecl.instanceOf(ASTTemplateDecl)) {
                    module_.register(
                        templateDecl.name.name(warmContext), entry.protection,
                        templateDecl.compileSymbol(context)?);
                } else if (auto classDecl = astDecl.instanceOf(ASTClassDecl)) {
                    module_.add(classDecl.name.name(warmContext), entry.protection, classDecl);
                } else if (auto intfDecl = astDecl.instanceOf(ASTIntfDecl)) {
                    module_.add(intfDecl.name.name(warmContext), entry.protection, intfDecl);
                } else if (auto enumDecl = astDecl.instanceOf(ASTEnumDecl)) {
                    module_.register(
                        enumDecl.name.name(warmContext),
                        entry.protection, enumDecl.compileSymbol(context)?);
                } else if (auto funDef = astDecl.instanceOf(ASTFunction)) {
                    module_.add(funDef.name.name(warmContext), entry.protection, funDef);
                } else if (auto import_ = astDecl.instanceOf(ASTImport)) {
                    // requeue in case it was in a version()
                    auto id = context.compiler.queueModuleCompilation(context, import_.module_?);
                    auto importedModule = context.compiler.getCompiledModule(id)?;

                    bool public_ = entry.protection == Protection.public_;

                    module_.addImport(
                        importedModule, public_=public_, import_.statement.symbols);
                } else {
                    print("declaration $(astDecl.repr)");
                    assert(false);
                }
            }
            ASTExternFunction extern_:
                module_.register(extern_.name, entry.protection, extern_.compile(context)?);
            ASTExternVariable extern_:
                module_.register(extern_.name, entry.protection, extern_.compile(context)?);
            ASTUnitTest ut:
                module_.add("", entry.protection, ut);
            ASTPragma pragma_:
                module_.track(pragma_.compile(context)?);
            ASTVersion version_: {
                if ([any a == version_.name for a in context.platform.versions]) {
                    [handleEntry(entry)? for entry in version_.then];
                } else {
                    [handleEntry(entry)? for entry in version_.else_];
                }
            }
        }
    }

    [handleEntry(entry)? for entry in astModule.entries];

    module_.compile(context)?;

    context.modulePostProcessor.process(module_);

    return module_;
}

(ASTModule | Error) getModule(CompilerBase compiler, mut string filename, mut nullable Package pak, bool search,
    ParserHelper helper, LocRange locRange)
{
    version (firstpass) {}
    else {
        import package(compiler).std.file : isRegularFile;
    }
    mut string path = filename;
    if (search) {
        auto pakNotNull = pak? else return locRange.fail("search, but no package");
        // TODO destructuring tuple
        auto pair = findFileInPackage(filename, pakNotNull, locRange)?;
        path = pair[0];
        pak = pair[1];
    } else {
        assert2s(!pak, "no search, but package");
        auto pair = findResidualFilename(filename, compiler.allPackages);
        filename = pair[0];
        pak = pair[1];
    }
    auto pak = pak? else die;
    version (firstpass) {}
    else if (!path.isRegularFile)
        return locRange.fail("$path is not a file");
    // FIXME the workpool queueing here is 100% redundant with the ImportTask queueing, p sure
    auto task = new ParseAstModuleTask(compiler, filename, path, pak, helper, locRange);
    compiler.workPool.queue(task);
    compiler.workPool.dependency(provider=task.id, consumer=:current);
    return compiler.workPool.wait(task.id).instanceOf(ParseAstModuleTask).module_;
}

class ParseAstModuleTask : ITask
{
    CompilerBase compiler;
    string filename;
    string path;
    ReadFileTask readSource;
    Package pak;
    ParserHelper helper;
    LocRange locRange;
    mut (ASTModule | :none | Error) result;
    this(
        this.compiler, this.filename, this.path,
        this.pak, this.helper, this.locRange,
    ) {
        this.result = :none;
        this.readSource = new ReadFileTask(path);
        compiler.workPool.queue(readSource);
    }
    (ASTModule | Error) module_() {
        result.case {
            ASTModule mod: return mod;
            (:none): assert(false);
            Error err: return err;
        }
    }
    override string id() => "parse ast $path";
    override bool fresh() => true;
    override void run(WorkPoolBase workPool) {
        this.result = parse;
    }
    (ASTModule | Error) parse() {
        compiler.workPool.queue(readSource);
        compiler.workPool.dependency(provider=readSource.id, consumer=this.id);
        mut auto code = compiler.workPool.wait(readSource.id).instanceOf(ReadFileTask).text;
        // do not count references on the file source - it will end
        // up with lots of small inc/decs to fragments that we never free anyway
        (cast(size_t*) &code)[2] = 0;
        ParserImpl parser = compiler.createParser(path, code)?.instanceOf(ParserImpl)? else die;

        auto fromAtModule = parser.from;
        parser.expectIdentifier("module")?;
        string modname = parser.parseModuleName?;
        parser.expectToken(TokenType.semicolon)?;

        import package(compiler).std.string : endsWith;

        parser.to(fromAtModule).assert(
            filename.endsWith(modname.moduleToFile),
            () => "$filename: module doesn't match filename")?;

        ASTModule baseModule = new ASTModule(
            modname, pak, this.path, moduleParseTaskId=this.id, new MacroState, parser.to(fromAtModule), null);
        return parseModuleBody(compiler, parser, helper, baseModule);
    }
}


void assert(bool b) {
    import neat.base : assert;
    return assert(b);
}

(void | Error) assert(LocRange locRange, bool test, (string delegate!() | string) msg) {
    import neat.base : assert;
    return assert(locRange, test, msg);
}
