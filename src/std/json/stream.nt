module std.json.stream;

macro import std.json.macro;
macro import std.macro.assert;
macro import std.macro.easymacro;
macro import std.macro.quasiquoting;

import neat.base : LocRange;
import std.error;
import std.json;
import std.stream;

/**
 * A thing that can appear in a JSON stream.
 */
alias JsonToken = (
    string |
    nullptr_t |
    bool |
    int |
    // double |
    :arrayStart |
    :arrayEnd |
    :objectStart |
    :objectEnd |
    :comma |
    :colon
);

///
string toString(JsonToken token) {
    return token.case(
        string s: "\"$s\"",
        nullptr_t: "null",
        bool b: "$b",
        int i: "$i",
        :comma: ",",
        :colon: ":",
        :arrayStart: "[",
        :arrayEnd: "]",
        :objectStart: "{",
        :objectEnd: "}",
    );
}

/**
 * This error represents a problem while decoding JSON.
 */
class DecodeError : Error
{
    override string toString() => "DecodeError($(this.message))";
}

/**
 * Convert byte data into a stream of JSON tokens.
 * The data arrives as a stream of byte arrays, usually representing
 * read or receive calls.
 */
class JsonLexer : Source!JsonToken
{
    private Source!(ubyte[]) source;

    private ubyte[] buffer;

    this(this.source) { }

    override (JsonToken | :else | fail Error) get() {
        import std.string : atoi;
        (void | fail Error | fail :else) getMore() {
            buffer ~= source.get.case(Error err: return err, :else: return :else);
        }
        bool isDigit(char ch) => ch >= '0' && ch <= '9';
        void drop(int len = 1) { buffer = buffer[len .. $]; }
        (bool | fail Error | fail :else) startswith(string cmp) {
            for (i, ch in cmp) {
                if (i == buffer.length) getMore?;
                if (buffer[i] != cast(ubyte) ch)
                    return false;
            }
            return true;
        }
        while (true) {
            if (buffer.empty) getMore?;
            if (buffer[0] == cast(ubyte) ' ') {
                drop;
                continue;
            }
            if (buffer[0] == cast(ubyte) ',') { drop; return :comma; }
            if (buffer[0] == cast(ubyte) ':') { drop; return :colon; }
            if (buffer[0] == cast(ubyte) '{') { drop; return :objectStart; }
            if (buffer[0] == cast(ubyte) '}') { drop; return :objectEnd; }
            if (buffer[0] == cast(ubyte) '[') { drop; return :arrayStart; }
            if (buffer[0] == cast(ubyte) ']') { drop; return :arrayEnd; }
            if (isDigit(cast(char) buffer[0])) {
                mut int len = 1;
                while (true) {
                    if (len == buffer.length) getMore.case(:else: break)?;
                    if (isDigit(cast(char) buffer[len])) {
                        len++;
                        continue;
                    }
                    break;
                }
                auto result = atoi((cast(char*) buffer.ptr)[0 .. len]);
                drop(len);
                return result;
            }
            if (startswith("true")?) {
                drop(4);
                return true;
            }
            if (startswith("false")?) {
                drop(5);
                return false;
            }
            if (startswith("null")?) {
                drop(4);
                return null;
            }
            if (buffer[0] == cast(ubyte) '"') {
                drop;
                mut bool escaped = false;
                mut string result;
                while (true) {
                    if (buffer.empty) getMore?;
                    if (escaped) {
                        escaped = false;
                        drop;
                        continue;
                    }
                    if (buffer[0] == cast(ubyte) '\\') {
                        escaped = true;
                        drop;
                        continue;
                    }
                    if (buffer[0] != cast(ubyte) '"') {
                        result ~= cast(char) buffer[0];
                        drop;
                        continue;
                    }
                    drop;
                    break;
                }
                return result;
            }
            return new DecodeError("Invalid content in JSON text: $buffer", __RANGE__);
        }
    }
}

///
unittest
{
    auto source = new StringSource("{\"a\": 3, \"b\": [4, 5, 6], \"c\": \"Hello World\"}");
    auto source = new JsonLexer(source);
    mut JsonToken[] tokens;
    // while (auto token = source.get? else break) {
    while (true) {
        auto token = source.get.case(:else: break, Error: assert(false));
        tokens ~= token;
    }
    assert(tokens == [
        :objectStart,
            "a", :colon, 3, :comma,
            "b", :colon, :arrayStart,
                4, :comma, 5, :comma, 6,
            :arrayEnd, :comma,
            "c", :colon, "Hello World",
        :objectEnd,
    ]);
}

/**
 * Convert a stream of JSON tokens into byte data.
 * Note that the produced byte blocks are not very efficient; you will
 * probably want to feed them through a flushable buffer sink before
 * putting them in a socket.
 */
class JsonPrinter : Sink!JsonToken
{
    Sink!(ubyte[]) sink;

    this(this.sink) {}

    override (void | fail Error) put(JsonToken token) {
        (void | fail Error) put(string s) {
            // TODO array cast
            sink.put((cast(ubyte*) s.ptr)[0 .. s.length])?;
        }
        token.case {
            string s:
                // this is a very silly way to do it.
                // TODO improve, for instance skip from escaped character to escaped character
                put("\"")?;
                for (i, ch in s) {
                    if (ch == '"' || ch == '\\')
                        put("\\")?;
                    put(s[i .. i + 1])?;
                }
                put("\"")?;
            nullptr_t: put("null")?;
            bool b: put("true" if b else "false")?;
            int i: put("$i")?;
            :comma: put(",")?;
            :colon: put(":")?;
            :arrayStart: put("[")?;
            :arrayEnd: put("]")?;
            :objectStart: put("{")?;
            :objectEnd: put("}")?;
        }
    }
}

///
unittest
{
    JsonToken[] tokens = [
        :objectStart,
            "a", :colon, 3, :comma,
            "b", :colon, :arrayStart,
                4, :comma, 5, :comma, 6,
            :arrayEnd, :comma,
            "c", :colon, "Hello World",
        :objectEnd,
    ];

    auto stringSink = new StringSink;
    auto jsonSink = new JsonPrinter(stringSink);
    for (token in tokens) jsonSink.put(token).case(Error: assert(false));
    // TODO: assert(stringSink.content == `{"a":3,"b":[4,5,6],"c":"Hello World"}`);
    assert(stringSink.content == "{\"a\":3,\"b\":[4,5,6],\"c\":\"Hello World\"}");
}

/**
 * Convert a JSON value into a stream of JSON tokens.
 */
class JsonValueSource : Source!JsonToken
{
    alias StackEntry = (
        JSONValue |
        JSONValue[], bool needComma |
        (string key, JSONValue value)[], bool needComma |
        JSONValue, (string key, JSONValue value)[], bool needColon);

    StackEntry mut[] stack;

    this(JSONValue value) {
        this.stack ~= value;
    }

    StackEntry head() => this.stack[$ - 1];

    void pop() {
        this.stack = this.stack[0 .. $ - 1];
    }

    override (JsonToken | :else | fail Error) get() {
        if (this.stack.empty)
            return :else;
        JsonToken transform(JSONValue value) {
            value.value.case {
                :false:
                    return false;
                :true:
                    return true;
                int i:
                    return i;
                string s:
                    return s;
                JSONValue[] array:
                    this.stack ~= (array, needComma=false);
                    return :arrayStart;
                (string key, JSONValue value)[] obj:
                    this.stack ~= (obj, needComma=false);
                    return :objectStart;
            }
        }
        head.case {
            JSONValue value:
                pop;
                return transform(value);
            (JSONValue[] array, bool needComma):
                if (array.empty) {
                    pop;
                    return :arrayEnd;
                } else if (needComma) {
                    this.stack[$ - 1] = (array, needComma=false);
                    return :comma;
                } else {
                    auto nextValue = array[0];
                    this.stack[$ - 1] = (array[1 .. $], needComma=true);
                    return nextValue.transform;
                }
            ((string key, JSONValue value)[] obj, bool needComma):
                if (obj.empty) {
                    pop;
                    return :objectEnd;
                } else if (needComma) {
                    this.stack[$ - 1] = (obj, needComma=false);
                    return :comma;
                } else {
                    auto nextEntry = obj[0];
                    this.stack[$ - 1] = (nextEntry.value, obj[1 .. $], needColon=true);
                    return nextEntry.key;
                }
            (JSONValue nextValue, (string key, JSONValue value)[] obj, bool needColon):
                if (needColon) {
                    this.stack[$ - 1] = (nextValue, obj, needColon=false);
                    return :colon;
                } else {
                    this.stack[$ - 1] = (obj, needComma=true);
                    return nextValue.transform;
                }
        }
    }
}

///
unittest
{
    auto value = JSONValue({"a": 3, "b": [4, 5, 6], "c": "Hello World"});
    auto source = new JsonValueSource(value);
    mut JsonToken[] tokens;
    // while (auto token = source.get? else break) {
    while (true) {
        auto token = source.get.case(:else: break, Error: assert(false));
        tokens ~= token;
    }
    assert(tokens == [
        :objectStart,
            "a", :colon, 3, :comma,
            "b", :colon, :arrayStart,
                4, :comma, 5, :comma, 6,
            :arrayEnd, :comma,
            "c", :colon, "Hello World",
        :objectEnd,
    ]);
}

/**
 * Convert a stream of JSON tokens into a JSON value.
 */
class JsonValueSink : Sink!JsonToken
{
    (JSONValue | :nothing) value;

    (
        :array, JSONValue[] |
        :objectKey, (string, JSONValue)[] |
        :objectValue, string key, (string, JSONValue)[]
    ) mut[] stack;

    this() {
        this.value = :nothing;
    }

    override (void | fail Error) put(JsonToken token) {
        (void | fail Error) set(JSONValue value) {
            if (this.value != :nothing)
                return new DecodeError("successive values in stream: $(token) after $(this.value)", __RANGE__);
            this.value = value;
        }
        (void | fail Error) flush() {
            JSONValue value = this.value.case(:nothing: return new DecodeError(
                "invalid token order: got '$(token.toString)' but no value beforehand", __RANGE__));
            this.stack[$ - 1].case {
                (:array, JSONValue[] values):
                    stack[$ - 1] = (:array, values ~ value);
                    this.value = :nothing;
                (:objectKey, (string, JSONValue)[]):
                    return new DecodeError(
                        "invalid token order: got '$(token.toString)' but expected object key", __RANGE__);
                (:objectValue, string key, (string, JSONValue)[] values):
                    stack[stack.length - 1] = (:objectKey, values ~ (key, value));
                    this.value = :nothing;
            }
        }
        token.case {
            string s: set(JSONValue(s))?;
            nullptr_t: set(JSONValue(null))?;
            bool b: set(JSONValue(b))?;
            int i: set(JSONValue(i))?;
            // double d: set(JSONValue(d))?;
            :arrayStart:
                if (this.value != :nothing)
                    return new DecodeError("array immediately following value in stream", __RANGE__);
                this.stack ~= (:array, null);
            :comma:
                flush?;
            :arrayEnd:
                if (this.value != :nothing) flush?;
                this.stack[$ - 1].case {
                    (:array, JSONValue[] values):
                        this.value = JSONValue(values);
                    (:objectKey, (string, JSONValue)[]):
                        return new DecodeError("invalid token order: got ']' but expected object key", __RANGE__);
                    (:objectValue, string key, (string, JSONValue)[]):
                        return new DecodeError("invalid token order: got ']' but expected object value", __RANGE__);
                }
                this.stack = this.stack[0 .. $ - 1];
            :objectStart:
                if (this.value != :nothing)
                    return new DecodeError("object immediately following value in stream", __RANGE__);
                this.stack ~= (:objectKey, null);
            :objectEnd:
                if (this.value != :nothing) flush?;
                this.stack[$ - 1].case {
                    (:array, JSONValue[]):
                        return new DecodeError("invalid token order: got '}' but expected array value", __RANGE__);
                    (:objectKey, (string, JSONValue)[] values):
                        this.value = JSONValue(values);
                    (:objectValue, string key, (string, JSONValue)[]):
                        return new DecodeError("invalid token order: got '}' but expected object value", __RANGE__);
                }
                this.stack = this.stack[0 .. $ - 1];
            :colon:
                this.stack[$ - 1].case {
                    (:array, JSONValue[] values):
                        return new DecodeError("invalid token order: got ':' but expected array member", __RANGE__);
                    (:objectKey, (string, JSONValue)[] values):
                        JSONValue keyValue = this.value.case(:nothing: return new DecodeError(
                            "invalid token order: got ':' but expected object key", __RANGE__));
                        /*string key = keyValue.value.case(
                            string s: s,
                            default: return new DecodeError("invalid syntax: string expected before ':'", __RANGE__));*/
                        (string | fail DecodeError) key() {
                            keyValue.value.case {
                                string s: return s;
                                default: return new DecodeError(
                                    "invalid syntax: string expected before ':'", __RANGE__);
                            }
                        }
                        stack[$ - 1] = (:objectValue, key?, values);
                        this.value = :nothing;
                    (:objectValue, string key, (string, JSONValue)[]):
                        return new DecodeError("invalid token order: got '$key:' but expected object value", __RANGE__);
                }
        }
    }
}

/**
 * Encode a value as a JSON token stream.
 */
(void | fail Error) encode(T)(T value, Sink!JsonToken sink) {
    macro {
        import neat.array;
        import neat.struct_;
        import neat.types;

        auto T = type("T")?;
        if (T.instanceOf(Integer) || T.instanceOf(Long) || T.instanceOf(Short) || T.instanceOf(Boolean)) {
            code { sink.put(value)?; }
        } else if (auto array_ = T.instanceOf(Array)) {
            if (array_.elementType.instanceOf(Character)) {
                code { sink.put(value)?; }
            } else {
                code {
                    sink.put(:arrayStart)?;
                    for (i, entry in value) {
                        if (i > 0) sink.put(:comma)?;
                        .encode(entry, sink)?;
                    }
                    sink.put(:arrayEnd)?;
                }
            }
        } else if (auto struct_ = T.instanceOf(Struct)) {
            code { sink.put(:objectStart)?; }
            for (i, member in struct_.members) {
                auto name = compiler.astIdentifier(member.name, __RANGE__);
                auto nameStr = compiler.astStringLiteral(member.name, __RANGE__);
                if (i > 0) code {
                    sink.put(:comma)?;
                }
                code {
                    sink.put($nameStr)?;
                    sink.put(:colon)?;
                    .encode(value.$name, sink)?;
                }
            }
            code { sink.put(:objectEnd)?; }
        } else {
            return __RANGE__.fail("Don't know how to encode $(T.toString)");
        }
    }
}

///
unittest {
    auto sink = new JsonValueSink;
    5.encode(sink).case(Error: assert(false));
    assert(sink.value == JSONValue(5));
}

///
unittest {
    auto sink = new JsonValueSink;
    [2, 3].encode(sink).case(Error: assert(false));
    assert(sink.value == JSONValue([2, 3]));
}

///
unittest {
    struct S {
        int a;
        string[] b;
        bool c;
    }
    auto sink = new JsonValueSink;
    S(2, ["foo", "bar"], false).encode(sink).case(Error: assert(false));
    assert(sink.value == JSONValue({"a": 2, "b": ["foo", "bar"], "c": false}));
}

/**
 * Decode a value from a JSON token stream.
 */
(T | fail Error) decode(T)(Source!JsonToken source) {
    auto token = source.get? else return new DecodeError("end of input reached while decoding", __RANGE__);

    return decodeWithToken!T(source, token);
}

///
unittest
{
    auto source((JSONValue | string) a) => a.case(
        JSONValue a: new JsonValueSource(a),
        string s: new JsonLexer(new StringSource(s)));

    assert(JSONValue(5).source.decode!int == 5);
    assert(JSONValue(true).source.decode!bool == true);
    assert(JSONValue("foo").source.decode!string == "foo");
    assert(JSONValue([]).source.decode!(int[]) == []);
    assert(JSONValue([2, 3, 4]).source.decode!(int[]) == [2, 3, 4]);
    assert(JSONValue(["foo", "bar"]).source.decode!(string[]) == ["foo", "bar"]);

    assert("5".source.decode!int == 5);
    assert("true".source.decode!bool == true);
    assert("\"foo\"".source.decode!string == "foo");
    assert("[]".source.decode!(int[]) == []);
    assert("[2, 3, 4]".source.decode!(int[]) == [2, 3, 4]);
    assert("[\"foo\", \"bar\"]".source.decode!(string[]) == ["foo", "bar"]);

    struct S {
        int a;
        string[] b;
        bool c;
        string toString() => "S($a, $b, $c)";
    }
    assert(JSONValue({"a": 2, "b": ["foo", "bar"], "c": false}).source.decode!S == S(2, ["foo", "bar"], false));
    assert("{\"a\": 2, \"b\": [\"foo\", \"bar\"], \"c\": false}".source.decode!S == S(2, ["foo", "bar"], false));
}

private (T | fail Error) decodeWithToken(T)(Source!JsonToken source, JsonToken token) {
    macro {
        import neat.array;
        import neat.struct_;
        import neat.types;
        import neat.util : ASTSymbolHelper;

        auto T = type("T")?;
        if (T.instanceOf(Integer) || T.instanceOf(Long) || T.instanceOf(Short)) {
            code {
                token.case {
                    int i: return cast(T) i;
                    default: return new DecodeError("expected integer, but got $(token.toString)", __RANGE__);
                }
            }
        } else if (T.instanceOf(Boolean)) {
            code {
                token.case {
                    bool b: return b;
                    default: return new DecodeError("expected boolean, but got $(token.toString)", __RANGE__);
                }
            }
        } else if (auto array_ = T.instanceOf(Array)) {
            auto astElementType = new ASTSymbolHelper(array_.elementType);
            if (array_.elementType.instanceOf(Character)) {
                code {
                    token.case {
                        string s: return s;
                        default: return new DecodeError("expected string, but got $(token.toString)", __RANGE__);
                    }
                }
            } else {
                code {
                    if (token != :arrayStart)
                        return new DecodeError("expected '[', but got $(token.toString)", __RANGE__);
                    mut T result;
                    while (true) {
                        auto token = source.get? else
                            return new DecodeError("end of input reached while decoding", __RANGE__);
                        if (token == :arrayEnd) break;
                        if (result.empty) {
                            result ~= .decodeWithToken!($astElementType)(source, token)?;
                        } else {
                            if (token != :comma)
                                return new DecodeError("expected ',', not $(token.toString)", __RANGE__);
                            result ~= .decode!($astElementType)(source)?;
                        }
                    }
                    return result;
                }
            }
        } else if (auto struct_ = T.instanceOf(Struct)) {
            code {
                if (token != :objectStart)
                    return new DecodeError("expected '{', but got $(token.toString)", __RANGE__);
            }
            mut ASTSymbol[] args;
            for (i, member in struct_.members) {
                auto astName = compiler.astStringLiteral(member.name, __RANGE__);
                auto astFieldType = new ASTSymbolHelper(member.type);
                auto astField = compiler.astIdentifier("field$i", __RANGE__);
                code { mut ($astFieldType | :none) $astField = :none; }
                args ~= compiler.$expr
                    $astField.case(:none: return new DecodeError("missing field $($astName)", __RANGE__));
            }
            code {
                // TODO single mode variable
                mut bool startOfObject = true;
                mut bool expectSeparator = false;
                mut (string | :none) lastKey = :none;
                while (true) {
                    auto token = source.get? else
                        return new DecodeError("end of input reached while decoding", __RANGE__);
                    token.case {
                        :objectEnd:
                            if (!expectSeparator && !startOfObject)
                                return new DecodeError("expected object key, but got '}'", __RANGE__);
                            break;
                        :comma:
                            if (expectSeparator) expectSeparator = false;
                            else return new DecodeError("unexpected ','", __RANGE__)
                            continue;
                        string key:
                            if (expectSeparator)
                                return new DecodeError("expected ',', but got '$(token.toString)'", __RANGE__);
                            if (lastKey != :none)
                                return new DecodeError("expected ':', but got '$(token.toString)'", __RANGE__);
                            lastKey = key;
                            continue;
                        :colon:
                            if (expectSeparator)
                                return new DecodeError("expected ',', but got '$(token.toString)'", __RANGE__);
                            string key = lastKey.case(:none: return new DecodeError(
                                "expected object key, but got '$(token.toString)'", __RANGE__));
                            lastKey = :none;
                            startOfObject = false;
                            macro {
                                for (i, member in struct_.members) {
                                    auto astFieldType = new ASTSymbolHelper(member.type);
                                    auto astField = compiler.astIdentifier("field$i", __RANGE__);
                                    auto nameStr = compiler.astStringLiteral(member.name, __RANGE__);
                                    code {
                                        if (key == $nameStr) {
                                            $astField = .decode!($astFieldType)(source)?;
                                            expectSeparator = true;
                                            continue;
                                        }
                                    }
                                }
                            }
                            return new DecodeError("expected object member, but got '$(token.toString)'", __RANGE__);
                        default:
                            return new DecodeError("expected object key, but got '$(token.toString)'", __RANGE__);
                    }
                }
            }
            auto call = compiler.(astCall(astIdentifier("T", __RANGE__), args, __RANGE__));
            code { return $call; }
        } else {
            return __RANGE__.fail("Don't know how to decode $(T.toString)");
        }
    }
}

private class StringSource : Source!(ubyte[]) {
    bool empty;
    string content;
    this(this.content) { this.empty = false; }
    override (ubyte[] | :else | fail Error) get() {
        if (empty) return :else;
        empty = true;
        mut ubyte[] cast_;
        for (ch in content) cast_ ~= cast(ubyte) ch;
        return cast_;
    }
}

private class StringSink : Sink!(ubyte[]) {
    string content;
    this() { }
    override (void | fail Error) put(ubyte[] data) {
        for (b in data) content ~= cast(char) b;
    }
}
