module std.math.matrix;

import std.math;
import std.math.vector;

extern(C) void assert(bool);

struct mat4x4 {
    vec4f row1, row2, row3, row4;
    mat4x4 rotateX(float by) { return mul(mat4x4.rotationX(by)); }
    mat4x4 rotateY(float by) { return mul(mat4x4.rotationY(by)); }
    mat4x4 rotateZ(float by) { return mul(mat4x4.rotationZ(by)); }
    mat4x4 scale(float x, float y, float z) { return mul(mat4x4.scaling(x, y, z)); }
    mat4x4 translate(float x, float y, float z) { return mul(mat4x4.translation(x, y, z)); }
    mat4x4 mul(mat4x4 other) {
        // this is all super unoptimized
        float rowmul(int row, int col) {
            auto mul = this.row(row) * other.row(col);
            return mul.x + mul.y + mul.z + mul.w;
        }
        return mat4x4(
            vec4f(rowmul(0, 0), rowmul(0, 1), rowmul(0, 2), rowmul(0, 3)),
            vec4f(rowmul(1, 0), rowmul(1, 1), rowmul(1, 2), rowmul(1, 3)),
            vec4f(rowmul(2, 0), rowmul(2, 1), rowmul(2, 2), rowmul(2, 3)),
            vec4f(rowmul(3, 0), rowmul(3, 1), rowmul(3, 2), rowmul(3, 3)));

    }
    vec4f row(int r) {
        if (r == 0) return row1;
        if (r == 1) return row2;
        if (r == 2) return row3;
        if (r == 3) return row4;
        assert(false);
    }
    mat4x4 transpose() {
        return mat4x4(
            vec4f(row1.x, row2.x, row3.x, row4.x),
            vec4f(row1.y, row2.y, row3.y, row4.y),
            vec4f(row1.z, row2.z, row3.z, row4.z),
            vec4f(row1.w, row2.w, row3.w, row4.w));
    }

    static mat4x4 identity() {
        return mat4x4(
            vec4f(1, 0, 0, 0),
            vec4f(0, 1, 0, 0),
            vec4f(0, 0, 1, 0),
            vec4f(0, 0, 0, 1));
    }
    static mat4x4 rotationX(float angle) {
        float cos = cos(angle), sin = sin(angle);
        return mat4x4(
            vec4f(1,    0,   0, 0),
            vec4f(0,  cos, sin, 0),
            vec4f(0, -sin, cos, 0),
            vec4f(0,    0,   0, 1));
    }
    static mat4x4 rotationY(float angle) {
        float cos = cos(angle), sin = sin(angle);
        return mat4x4(
            vec4f(cos, 0, -sin, 0),
            vec4f(  0, 1,    0, 0),
            vec4f(sin, 0,  cos, 0),
            vec4f(  0, 0,    0, 1));
    }

    static mat4x4 rotationZ(float angle) {
        float cos = cos(angle), sin = sin(angle);
        return mat4x4(
            vec4f(cos, -sin, 0, 0),
            vec4f(sin,  cos, 0, 0),
            vec4f(  0,    0, 1, 0),
            vec4f(  0,    0, 0, 1));
    }

    static mat4x4 scaling(float x, float y, float z) {
        return mat4x4(
            vec4f(x, 0, 0, 0),
            vec4f(0, y, 0, 0),
            vec4f(0, 0, z, 0),
            vec4f(0, 0, 0, 1));
    }

    static mat4x4 translation(float x, float y, float z) {
        return mat4x4(
            vec4f(1, 0, 0, x),
            vec4f(0, 1, 0, y),
            vec4f(0, 0, 1, z),
            vec4f(0, 0, 0, 1));
    }

    static mat4x4 ortho(float left, float right, float bottom, float top, float near, float far) {
        float dx = right - left, dy = top - bottom, dz = far - near;
        float tx = -(right + left) / dx;
        float ty = -(top + bottom) / dy;
        float tz = -(far + near) / dz;
        return mat4x4(
            vec4f(2/dx,    0,     0, tx),
            vec4f(   0, 2/dy,     0, ty),
            vec4f(   0,    0, -2/dz, tz),
            vec4f(   0,    0,     0,  1));
    }
}
