module main;

macro import package(compiler).std.macro.cimport;
macro import package(compiler).std.macro.listcomprehension;

import backend.base;
import backend.c;
version (LLVMBackend) {
    import backend.llvm;
}
import helpers;
import neat.array;
import neat.base;
import neat.class_;
import neat.compiler;
import neat.docgen;
import neat.expr;
import neat.FileIdTableImpl;
import neat.function_;
import neat.packages;
import neat.stuff;
import neat.templ;
import neat.types;
import neat.unittest_;
import neat.util;
import neat.workpool;
import polyhash;
import package(compiler).std.algorithm;
import package(compiler).std.file;
import package(compiler).std.json;
import package(compiler).std.string;
import package(compiler).std.thread;
import package(compiler).std.argparse;
import c_header("sys/inotify.h");

extern(C) int getpid();
extern(C) void neat_runtime_system(string command);
extern(C) void neat_runtime_dlcall(string soname, string name, void* arg);
extern(C) bool neat_runtime_waitpid(int pid);
extern(C) int neat_runtime_execbg(string command, string[] arguments);
extern(C) long compiler_hash_add();
extern(C) long compiler_hash_mult();

string removeSlashes(string s) {
    mut string result;
    for (i in 0 .. s.length) {
        if (s[i .. i + 1] == "/") result = result ~ "_";
        else result = result ~ s[i .. i + 1];
    }
    return result;
}

struct BackgroundCompilation
{
    Hash hash;
    string srcFile;
    string objFile;
    int pid;
    string[] extraFlags;
}

private string getEnv(string key, string default_ = "") {
    import package(compiler).std.process : getEnv;
    auto ret = getEnv(key);
    if (!ret.empty) return ret;
    return default_;
}

BackgroundCompilation emitModule(
    Module module_, CompilationVisitor[] visitors, BuildSettings settings, FileIdTable fileIdTable,
    Mutex visitorLock, Hash prehash)
{
    auto hash = new Hash;

    hash.applyHash(prehash);

    auto symbols = module_.finishedSymbols;
    [symbol.hash(hash) for symbol in symbols];
    visitorLock.lock;
    [[visitor.visit(symbol) for symbol in symbols] for visitor in visitors];
    visitorLock.unlock;

    mut string objFile = ".obj/$(hash.text).o";
    version (LLVMBackend) {
        if (settings.backend.instanceOf(LLVMBackend) && settings.optimize) {
            objFile = ".obj/$(hash.text).bc";
        }
    }

    mut string srcFile;
    version (LLVMBackend) {
        if (settings.backend.instanceOf(LLVMBackend)) {
            srcFile = objFile;
        }
    }
    if (!srcFile.length) {
        assert(!!settings.backend.instanceOf(CBackend));
        srcFile = ".obj/module_$(hash.text).c";
    }

    auto backendModule = settings.backend.createModule(
        settings.platform, srcFile, module_.locRange.toBackendLoc(fileIdTable), settings.forMacro);
    version (LLVMBackend) {
        auto backendModuleLLVM = backendModule.instanceOf(LLVMBackendModule);
    }
    auto backendModuleC = backendModule.instanceOf(CBackendModule);

    int build(string src, string obj) {
        import package(compiler).std.string : join;

        version (LLVMBackend) {
            assert(!backendModuleLLVM);
        }

        mut string exec;
        mut string[] args;

        string[] baseArgs = ["-c", "-fpic", "-fno-strict-aliasing", src, "-o", obj];
        exec = getEnv("CC", "gcc");
        if (settings.optimize) args = baseArgs ~ "-O3";
        else args = baseArgs;
        if (settings.extraCFlags.length > 0) args ~= settings.extraCFlags.split(" ");

        string cmd = exec ~ " " ~ args.join(" ");
        int pid = neat_runtime_execbg(exec, args);
        if (settings.platform.platformFlags.verbose) {
            print("\$ $cmd [&$pid]");
        }
        return pid;
    }

    if (settings.caching && exists(objFile) && exists(srcFile)) {
        // preexisting object
        mut string[] extraFlags;
        if (".obj/$(hash.text).extraflags".exists) {
            extraFlags = ".obj/$(hash.text).extraflags".readText.split("\n");
        }
        return BackgroundCompilation(hash, srcFile, objFile, 0, extraFlags);
    }

    auto generator = new Generator(settings.platform, backendModule, fileIdTable);
    module_.emit(generator);
    backendModule.done;

    int pid() {
        version (LLVMBackend) {
            if (backendModuleLLVM) {
                backendModuleLLVM.writeOutput;
                return 0;
            }
        }
        assert(!!backendModuleC);
        {
            auto csrc = backendModuleC.output.text;
            write(srcFile, csrc);
        }
        return build(srcFile, objFile);
    }
    int pid = pid;
    auto compilation = BackgroundCompilation(hash, srcFile, objFile, pid, generator.extraFlags);

    if (generator.extraFlags.length > 0) {
        // FIXME [join line on "\n"
        ".obj/$(hash.text).extraflags".write(
            [join with "\n" line for line in generator.extraFlags]);
    } else {
        ".obj/$(hash.text).extraflags".remove;
    }

    return compilation;
}

class UnittestVisitor : CompilationVisitor
{
    mut string[] symbols;

    this() { }

    override void visit(FinishedSymbol sym) {
        if (auto uf = sym.instanceOf(CompiledUnittestFunction))
        {
            symbols ~= uf.fun.mangle;
        }
    }
}

class BuildSettings
{
    CompilerBase compiler;

    Backend backend;

    bool x86_32;

    bool caching;

    bool optimize;

    bool forMacro;

    string[] versions;

    PlatformFlags platformFlags;

    WorkPool pool;

    string extraCFlags;

    int loopPass;

    Platform platform() {
        BackendType macroWordType() {
            if (x86_32) return new BackendIntType;
            else return new BackendLongType;
        }
        return new Platform(macroWordType, platformFlags, versions, isMacro=forMacro);
    }

    this(this.compiler, this.backend, this.x86_32, this.caching, this.versions,
         this.platformFlags, this.optimize, this.forMacro,
         this.extraCFlags, this.pool, this.loopPass) { }
}

class CompilationTask : ITask
{
    Module module_;
    CompilationVisitor[] visitors;
    BuildSettings settings;
    FileIdTable fileIdTable;
    Mutex visitorLock;
    mut (:none | BackgroundCompilation) result;
    string id_;
    mut bool done;

    Hash prehash;

    BackgroundCompilation compilation() {
        result.case {
            BackgroundCompilation c: return c;
            (:none): assert(false);
        }
    }

    this(this.module_, this.visitors, this.settings, this.fileIdTable, this.visitorLock, Hash prehash) {
        this.result = :none;
        if (settings.forMacro) this.id_ = "emit $(module_.mangle) macro";
        else this.id_ = "emit $(module_.mangle)";
        this.prehash = new Hash;
        this.prehash.applyHash(prehash);
        this.prehash.adds(this.id_);
    }

    override string id() => id_;
    override bool fresh() => true;
    override void run(WorkPoolBase workPool) {
        this.result = emitModule(
            this.module_, this.visitors, this.settings, this.fileIdTable, this.visitorLock, this.prehash);
    }

    void waitDone() {
        if (done) return;
        int pid = compilation.pid;
        if (pid != 0) {
            neat_runtime_waitpid(pid);
        }
        done = true;
    }
}

struct BuildResult
{
    string[] objFiles;
    string[] intermediateFiles;
    Module module_;
    Hash hash;
}

class ModulePreProcessorImpl : ModulePreProcessor
{
    ASTModuleVisitor[] visitors;

    this(this.visitors) { }

    override void process(ASTModuleBase module_) {
        auto module_ = module_.instanceOf(ASTModule)? else die;

        [visitor.visit(module_) for visitor in visitors];
    }
}

class ModulePostProcessorImpl : ModulePostProcessor
{
    CompilationVisitor[] visitors;

    BuildSettings settings;

    FileIdTable fileIdTable;

    Mutex mutex, visitorLock;

    ModuleSet allModules;

    mut string[] taskIds;

    Hash prehash;

    this(this.visitors, this.settings, this.fileIdTable) {
        this.visitorLock = new Mutex;
        this.mutex = new Mutex;
        this.allModules = new ModuleSet;

        this.prehash = new Hash;
        prehash.apply(compiler_hash_add, compiler_hash_mult);
        settings.backend.hash(prehash);

        if (settings.x86_32) prehash.adds("m32");
        if (settings.optimize) prehash.adds("opt");
        // Macros and binaries must not share objects!
        // Macros have special magic to avoid dlopen issues.
        if (settings.forMacro) prehash.adds("macro");
        for (ver in settings.versions) prehash.adds("version=$(ver)");
    }

    override void process(ModuleBase module_)
    {
        auto module_ = module_.instanceOf(Module)? else die;

        queue(module_);
    }

    void queue(Module module_) {
        bool add(Module module_) {
            with (this.mutex.locked) {
                if (!this.allModules.add(module_)) return false;

                auto task = new CompilationTask(
                    module_, this.visitors, this.settings, this.fileIdTable, this.visitorLock, this.prehash);

                this.settings.pool.queue(task);
                if (module_.moduleParseTaskId != "")
                    this.settings.pool.dependency(provider=module_.moduleParseTaskId, consumer=task.id);
                this.settings.pool.dependency(provider=task.id, consumer=:current);
                this.taskIds ~= task.id;
            }

            queue(module_);
            return true;
        }
        module_.walkModules(&add);
    }

    void wait() {
        mut int i;
        with (this.mutex.locked) {
            while (i < this.taskIds.length) {
                auto taskId = taskIds[i];

                with (this.mutex.unlocked) {
                    this.settings.pool.wait(taskId);
                }
                i++;
            }
        }
    }
}

(BuildResult | Error) buildAstModule(
    ASTModule astModule, BuildSettings settings,
    ASTModuleVisitor[] moduleVisitors, CompilationVisitor[] compilationVisitors,
    FileIdTable fileIdTable, Options options)
{
    auto preProcessor = new ModulePreProcessorImpl(moduleVisitors);
    auto postProcessor = new ModulePostProcessorImpl(compilationVisitors, settings, fileIdTable);
    preProcessor.process(astModule);

    auto coldContext = makeColdContext(settings.compiler, settings.platform, astModule.macroState,
        settings.loopPass, preProcessor, postProcessor);
    Module module_ = compileModule(astModule, coldContext, addDefaultImports=true)?;

    postProcessor.wait;

    mut int[] pids;
    mut string[] objFiles;
    mut string[] intermediateFiles;
    auto hash = new Hash;
    hash.addl(__GENERATION__);
    for (taskId in postProcessor.taskIds.sort((a, b) => a.lexicallyBefore(b))) {
        auto task = settings.pool.wait(taskId).instanceOf(CompilationTask);
        auto compilation = task.compilation;
        objFiles ~= compilation.objFile;
        void addLinkerFlag(string flag) {
            if ([any a == flag for a in options.linkerArgs]) return;
            options.linkerArgs ~= flag;
        }
        [addLinkerFlag(flag) for flag in compilation.extraFlags];
        intermediateFiles ~= compilation.srcFile;
        // TODO ordering
        compilation.hash.(hash.apply(add, mult));
        task.waitDone;
    }

    return BuildResult(objFiles, intermediateFiles, module_, hash);
}

class SimpleModulePreProcessor : ModulePreProcessor
{
    this() { }

    override void process(ASTModuleBase module_)
    {
    }
}

class SimpleModulePostProcessor : ModulePostProcessor
{
    this() { }

    override void process(ModuleBase module_)
    {
    }
}

(Function | Error) extractFunction(Module module_, string name, BuildSettings settings, LocRange locRange) {
    auto preProcessor = new SimpleModulePreProcessor;
    auto postProcessor = new SimpleModulePostProcessor;
    auto coldContext = makeColdContext(settings.compiler, settings.platform, new MacroState,
        settings.loopPass, preProcessor, postProcessor);
    auto warmContext = makeWarmContext(settings.compiler, framePointer=null, frameDepth=:none, compilingModule=module_);
    auto simpleContext = Context(module_, warmContext, coldContext);
    auto fun = module_.lookup(name, simpleContext, LookupReason.identifier, locRange)??
        else return locRange.fail("undefined function '$(name)'");
    return fun.instanceOf(Function)?
        else return locRange.fail("'$(name)' is not a function");
}

class ParserHelperImpl : ParserHelper
{
    BuildSettings settings;

    FileIdTable fileIdTable;

    this(this.settings, this.fileIdTable) { }

    override (LibraryCallRecord | Error) proxyCall(ASTModuleBase astModule, string function_, void* ptr,
        LocRange locRange)
    {
        auto astModule = astModule.instanceOf(ASTModule)? else die;
        if (settings.platform.platformFlags.verbose) {
            print("# stageM $function_");
        }
        // ignore pragma(lib) in macro (what are you doing)
        auto dummyOptions = new Options;
        auto result = buildAstModule(astModule, this.settings, [], [], this.fileIdTable, dummyOptions)?;
        string name = result.module_.extractFunction(function_, settings, locRange)?.mangle;
        // write into unique tmp to avoid collision between processes
        int pid = getpid;
        string soname = ".obj/macro_$(name)_$(result.hash.text).so";
        auto tmpname = ".obj/macro_$(name)_$(result.hash.text).$pid.so";
        bool verbose = settings.platform.platformFlags.verbose;

        if (!settings.caching || !exists(soname)) {
            settings.backend.linkSharedLib(soname=tmpname, flags=settings.extraCFlags, verbose=verbose, result.objFiles);
            neat_runtime_system("mv $tmpname $soname");
        }
        neat_runtime_dlcall(soname, name, ptr);
        return (soname=soname, fnname=name);
    }
}

// "AST", lol. Package fresh off the commandline, dependencies not resolved yet.
// Needed because we can reference future packages.
struct ASTPackage
{
    string name;
    string path;
    bool syspkg;
    string[] deps;
}

// better way to do this (reassign?)
(string result, string remainder) slice(string text, string marker)
{
    int pos = find(text, marker);
    if (pos == -1) {
        return (text, "");
    }
    return (text[0 .. pos], text[pos + marker.length .. $]);
}

ASTPackage parsePackage(mut string arg, bool syspkg)
{
    auto pair1 = slice(arg, ":");
    string name = pair1.result; arg = pair1.remainder;
    assert(name.length > 0);
    auto pair2 = slice(arg, ":");
    string path = pair2.result; arg = pair2.remainder;
    assert(path.length > 0);
    mut string[] deps;
    while (arg.length)
    {
        auto pair3 = slice(arg, ",");
        deps ~= pair3.result; arg = pair3.remainder;
    }
    return ASTPackage(name, path, syspkg, deps);
}

string resolvePath(ASTPackage pak, string execPath) {
    if (!pak.syspkg) return realpath(pak.path);
    return realpath("$execPath/$(pak.path)");
}

Package[] resolvePackages(ASTPackage[] astPackages, string execPath) {
    Package[] result = [new Package(pkg.name, resolvePath(pkg, execPath), []) for pkg in astPackages];
    for (i, astPackage in astPackages) {
        for (dep in astPackage.deps) {
            mut nullable Package foundDep;
            for (resultPak in result) {
                if (resultPak.name == dep) {
                    if (foundDep) print("Dependency '$dep' of '$(astPackage.name)' exists twice!");
                    assert(!foundDep);
                    foundDep = resultPak;
                    break;
                }
            }
            auto foundDep = foundDep? else ({
                print("Missing package dependency: $dep");
                die;
            });
            result[i].addDependency(foundDep);
        }
    }
    return result;
}

class UmlVisitor : CompilationVisitor
{
    mut (string base, string child)[] inheritance;

    this() { }

    override void visit(FinishedSymbol sym) {
        if (auto defClass = sym.instanceOf(DefineClassIntf)) {
            defClass.obj.case {
                Class class_: {
                    if (class_.superClass) {
                        auto pair = (class_.superClass.name, class_.name);
                        if (![any a == pair for a in this.inheritance])
                            this.inheritance ~= pair;
                    }
                    for (superIntf in class_.superIntfs) {
                        auto pair = (superIntf.name, class_.name);
                        if (![any a[0] == pair[0] && a[1] == pair[1] for a in this.inheritance])
                            this.inheritance ~= pair;
                    }
                }
                Intf intf: {
                    for (superIntf in intf.superIntfs) {
                        auto pair = (superIntf.name, intf.name);
                        if (![any a[0] == pair[0] && a[1] == pair[1] for a in this.inheritance])
                            this.inheritance ~= pair;
                    }
                }
            }
        }
    }

    void writeTo(string filename) {
        mut string diagram = "Digraph G {\n";
        void addl(string s) { diagram ~= "  $s\n"; }
        for (pair in inheritance) {
            addl("$(pair.base) -> $(pair.child) [dir=back, arrowhead=empty];");
        }
        diagram ~= "}\n";
        write(filename, diagram);
    }
}

class ModuleSet
{
    mut Module[string] store;
    this() { }
    bool add(Module mod)
    {
        if (this.store.has(mod.mangledName)) return false;
        this.store[mod.mangledName] = mod;
        return true;
    }
    Module[] array()
    {
        return store.values;
    }
}

string alignTabs(string text) {
    auto lines = text.split("\n");
    auto segments = [line.split("\t") for line in lines];
    int numTabs = [max [count ch in line where ch == '\t'] for line in lines];
    // Yes that `- 1` is intentional. Think about it.
    int[] spaceUse = [
        [max cast(int) lineSegments[i].length for lineSegments in segments where i < lineSegments.length - 1 base 0]
        for i in 0 .. numTabs];
    mut string res;
    for (line in segments) {
        for (i, segment in line) {
            res ~= segment;
            if (i < line.length - 1) {
                int target = spaceUse[i] + 1;
                for (k in 0 .. target - segment.length)
                    res ~= " ";
            }
        }
        res ~= "\n";
    }
    return res;
}

void help(ArgParser parser, string executable) {
    mut string msg = "Usage: $executable [options] FILE.nt

Or: $executable build\t Builds the project in the current folder.

Options:

";
    for (arg in parser.args) {
        string description = arg.description.case(:hidden: continue);

        if (arg.shortname != "") {
            msg ~= "  -$(arg.shortname), -$(arg.longname)\t$(description)\n";
        } else {
            msg ~= "  -$(arg.longname)\t$(description)\n";
        }
    }
    print(msg.alignTabs.strip);
}

class Options
{
    mut string output;
    mut string[] linkerArgs;
    mut ASTPackage[] astPackages;
    mut bool dontLink;
    mut bool optimize;
    mut bool caching;
    mut bool x86_32, macro_x86_32;
    mut string intermediateListFile;
    mut nullable Backend backend, macroBackend;
    mut int generation;
    mut string umlFile;
    mut bool unittest_;
    mut bool noMain;
    mut bool cpr; // critical path report
    mut PlatformFlags platformFlags, macroPlatformFlags;
    mut bool run;
    mut bool loop, watch;
    mut string[] runArgs;
    mut string[] cFlags; // for std.macro.cimport
    mut string[] versions, macroVersions;
    mut string docGenFolder;
    mut string runningCompilerVersion;
    mut string requestedCompilerVersion;
    mut string extraCFlags, macroExtraCFlags;
    mut string fileIdOutput;
    // Global filename/id mapping.
    // Used to apply file IDs for LocRange literals compiled into us.
    FileIdTableImpl fileIdTable;
    mut int threads;

    this() {
        this.caching = true;
        this.generation = __GENERATION__;
        this.threads = 0;
        this.fileIdTable = new FileIdTableImpl;
    }

    ArgParser argParser() {
        auto parser = new GccArgParser;

        // bleh, no way to say "integer with default value" in argparser yet
        int jobsFlag(string flag, string[] args, ArgResult result) {
            if (flag == "-j") {
                result.set("jobs", "");
                return 1;
            }
            return 0;
        }

        int fileIdPinFlag(string flag, string[] args, ArgResult result) {
            if (flag != "--file-id-pin") return 0;
            assert(args.length >= 2);
            auto id = args[0].atoi, path = args[1];
            this.fileIdTable.setInheritedFileId(id, path);
            return 2;
        }

        parser.add("h", "help", :noArg, "Print this help page");
        parser.add("P", "package", :multiArgs, "Define a package");
        parser.add("S", "syspackage", :multiArgs, "Define a system package");
        parser.add("r", "run", :noArg, "Run the executable after compiling");
        parser.add("running-compiler-version", :stringArg, :hidden);
        parser.add("compiler-version", :stringArg, :hidden);
        parser.add("I", :multiArgs, :hidden);
        parser.add("loop", :noArg, "Loop the compilation");
        parser.add("w", "watch", :noArg, "Watch source files for changes before looping");
        parser.add("l", :multiArgs, :hidden);
        parser.add("L", :multiArgs, :hidden);
        parser.add("o", "output", :stringArg, "Filename of the output binary");
        parser.add("O", "optimize", :noArg, "Optimize the output");
        parser.add("unittest", :noArg, "Run unittests");
        parser.add("no-main", :noArg, "Don't call the main function");
        parser.add("release", :noArg, "Disable bounds checking");
        parser.add("v", "verbose", :noArg, "Print info about compiler steps");
        parser.add("c", "no-link", :noArg, "Don't link the output");
        parser.add("x", "no-caching", :noArg, "Disable the compiler cache");
        parser.add("j", "jobs", :intArg, "The number of threads to use");
        parser.add("backend", :stringArg, "The output backend");
        parser.add("macro-backend", :stringArg, "The output backend for macros");
        parser.add("version", :multiArgs, "Define a version for the output platform");
        parser.add("macro-version", :multiArgs, "Define a version for the macro platform");
        parser.add("m32", :noArg, "Set 32-bit target for the output platform");
        parser.add("macro-m32", :noArg, "Set 32-bit target for the macro platform");
        parser.add("print-generation", :noArg, "Print the compiler generation");
        parser.add("next-generation", :noArg, "Increment the emitted compiler generation");
        parser.add("uml", :stringArg, "Generate class UML diagrams");
        parser.add("docgen", :stringArg, "Generate comments-based documentation");
        parser.add("cpr", :noArg, "Print the critical-path report");
        parser.add("dump-intermediates", :stringArg, :hidden);
        parser.add("extra-cflags", :stringArg, :hidden);
        parser.add("macro-extra-cflags", :stringArg, :hidden);
        parser.add("file-id-output", :stringArg, :hidden);
        parser.add(new &jobsFlag);
        parser.add(new &fileIdPinFlag);
        return parser;
    }

    string[] parseArgs(string executable, string[] args) {
        auto parser = argParser;

        bottom die(string s) {
            print("error: $s");
            exit(1);
        }

        ArgResult temp() {
            // TODO
            // import package(compiler).std.error : Error;
            import package(compiler).std.error;

            return parser.parse(args).case(Error err: die(err.message));
        }

        auto result = temp;

        // TODO if variable assignment/truthy split overloading
        if (result.has("help")) { help(parser, executable); exit(0); }
        if (result.has("package")) {
            for (value in result.getMultiple("package"))
                addPackage(value, false);
        }
        if (result.has("syspackage")) {
            for (value in result.getMultiple("syspackage"))
                addPackage(value, true);
        }
        if (result.has("run")) { this.run = true; }
        if (result.has("running-compiler-version")) {
            this.runningCompilerVersion = result.get("running-compiler-version");
        }
        if (result.has("compiler-version")) {
            this.requestedCompilerVersion = result.get("compiler-version");
        }
        if (result.has("I")) { cFlags ~= ["-I$value" for value in result.getMultiple("I")]; }
        if (result.has("loop")) { this.loop = true; }
        if (result.has("watch")) { this.watch = true; }
        if (result.has("l")) { this.linkerArgs ~= ["-l$value" for value in result.getMultiple("l")]; }
        if (result.has("L")) { this.linkerArgs ~= result.getMultiple("L"); }
        if (result.has("output")) { this.output = result.get("output"); }
        if (result.has("optimize")) { this.optimize = true; }
        if (result.has("unittest")) { this.unittest_ = true; }
        if (result.has("no-main")) { this.noMain = true; }
        if (result.has("release")) { this.platformFlags.releaseMode = true; }
        if (result.has("verbose")) {
            this.platformFlags.verbose = true;
            this.macroPlatformFlags.verbose = true;
        }
        if (result.has("no-link")) { this.dontLink = true; }
        if (result.has("no-caching")) { this.caching = false; }
        if (result.has("jobs")) {
            auto jobs = result.get("jobs");
            if (jobs == "") this.threads = 4;
            else this.threads = jobs.atoi;
        }
        if (result.has("backend")) { this.backend = parseBackend(result.get("backend")); }
        if (result.has("macro-backend")) { this.macroBackend = parseBackend(result.get("macro-backend")); }
        if (result.has("version")) {
            this.versions ~= result.getMultiple("version");
        }
        if (result.has("macro-version")) {
            this.macroVersions ~= result.getMultiple("macro-version");
        }
        if (result.has("m32")) { this.x86_32 = true; }
        if (result.has("macro-m32")) { this.macro_x86_32 = true; }
        if (result.has("print-generation")) {
            print(itoa(__GENERATION__));
            exit(0); // TODO return :exit
        }
        if (result.has("next-generation")) {
            // build the next generation of the compiler
            this.generation = __GENERATION__ + 1;
        }
        if (result.has("uml")) { this.umlFile = result.get("uml"); }
        if (result.has("docgen")) { this.docGenFolder = result.get("docgen"); }
        if (result.has("cpr")) { this.cpr = true; }
        if (result.has("dump-intermediates")) { this.intermediateListFile = result.get("dump-intermediates"); }
        if (result.has("extra-cflags")) { this.extraCFlags = result.get("extra-cflags"); }
        if (result.has("macro-extra-cflags")) { this.macroExtraCFlags = result.get("macro-extra-cflags"); }
        if (result.has("file-id-output")) { this.fileIdOutput = result.get("file-id-output"); }
        this.runArgs = result.extra;

        if (watch && !loop) {
            print("error: -watch makes no sense without -loop");
            exit(1);
        }
        if (!run && !runArgs.empty) {
            print("error: -run not specified but extra args were given");
            exit(1);
        }
        return result.remaining;
    }

    Backend parseBackend(string backend) {
        if (backend == "c") return new CBackend;
        else if (backend == "llvm") {
            version (LLVMBackend) return new LLVMBackend;
            else {
                print("LLVM backend not compiled in!");
                exit(1);
            }
        } else {
            print("Unknown backend '$backend'!");
            exit(1);
        }
    }

    void addDefaults() {
        version (LLVMBackend) {
            if (!this.backend) {
                this.backend = new LLVMBackend;
            }
            if (!this.macroBackend) {
                this.macroBackend = new LLVMBackend;
            }
        } else {
            if (!this.backend) {
                this.backend = new CBackend;
            }
            if (!this.macroBackend) {
                this.macroBackend = new CBackend;
            }
        }
    }

    string[] allVersions() {
        return ["generation$(i+1)" for i in 0 .. this.generation] ~ this.versions;
    }

    string[] allMacroVersions() {
        return ["generation$(i+1)" for i in 0 .. __GENERATION__] ~ ["macro"] ~ this.macroVersions;
    }

    void addPackage(string pak, bool relative) {
        auto pak = parsePackage(pak, relative);
        if ([any a.name == pak.name for a in this.astPackages]) {
            print("warn: package double-specified: $(pak.name); using newer definition");
            this.astPackages = [a for a in this.astPackages where a.name != pak.name];
        }
        this.astPackages ~= pak;
    }

    void parseConfig(string path) {
        if (!path.exists) return;
        auto lines = path.read.split("\n");
        mut string[] args;
        for (line in lines) {
            auto words = line.split(" ");
            args ~= words[0];
            mut int used = 1;
            if (words[0] == "--file-id-pin") {
                args ~= words[1];
                used = 2;
            }
            if (words.length > used) args ~= words[used .. $].join(" ");
        }
        parseArgs("neat.ini", args);
    }
}

ASTModule builtinSymbols(Options options) {
    // parse task id/path doesn't matter; they're builtins.
    auto builtins = new ASTModule(
        "", new Package("builtins", "", []), path="", moduleParseTaskId="",
        new MacroState, __RANGE__, null);

    builtins.addAliasDecl("string", Protection.public_,
        new ASTArray(new ASTIdentifier("char", false), mutableElements=false));
    // TODO dedi build type
    builtins.addAliasDecl("true", Protection.public_, new ASTSymbolHelper(new BoolLiteral(true)));
    builtins.addAliasDecl("false", Protection.public_, new ASTSymbolHelper(new BoolLiteral(false)));
    builtins.addAliasDecl("null", Protection.public_, new ASTSymbolHelper(new NullExpr(new NullPointer)));
    builtins.addAliasDecl("__GENERATION__", Protection.public_, new ASTSymbolHelper(new IntLiteral(options.generation)));
    return builtins;
}

(void | Error) buildBinary(
    Options options, WorkPool workPool,
    string mainFile, string execPath, Package[] packages, int loopPass,
) {
    /*print("packages:");
    for (pkg in packages) {
        print("  '" ~ pkg.name ~ "' at " ~ pkg.path ~ ": deps " ~ [join ", " "'" ~ a.name ~ "'" for a in pkg.deps]);
    }*/
    auto builtins = builtinSymbols(options);
    auto defaultImports = [builtins];
    auto compiler = new CompilerImpl(
        defaultImports, packages, options.cFlags, workPool, options.fileIdTable);
    auto settings = new BuildSettings(compiler, options.backend? else die,
        x86_32=options.x86_32, caching=options.caching, versions=options.allVersions,
        platformFlags=options.platformFlags, optimize=options.optimize, forMacro=false,
        extraCFlags=options.extraCFlags, pool=workPool, loopPass=loopPass);
    auto macroSettings = new BuildSettings(compiler, options.macroBackend? else die,
        x86_32=options.macro_x86_32, caching=options.caching, versions=options.allMacroVersions,
        platformFlags=options.macroPlatformFlags, optimize=false, forMacro=true,
        extraCFlags = options.macroExtraCFlags, pool=workPool, loopPass=loopPass);
    auto parserHelper = new ParserHelperImpl(macroSettings, compiler.fileIdTable);
    // FIXME break reference loop
    compiler.parserHelper = parserHelper;
    mut CompilationVisitor[] compilationVisitors;
    mut ASTModuleVisitor[] moduleVisitors;

    auto unittestVisitor = new UnittestVisitor;
    if (options.unittest_) {
        compilationVisitors ~= unittestVisitor;
    }

    auto umlVisitor = new UmlVisitor;
    if (options.umlFile != "") {
        compilationVisitors ~= umlVisitor;
    }

    auto docGenVisitor = new DocGenVisitor(mainFile);
    if (options.docGenFolder != "") {
        moduleVisitors ~= docGenVisitor;
    }

    auto astModule = getModule(compiler, mainFile, null, false, parserHelper, __RANGE__)?;
    BuildResult result = buildAstModule(astModule, settings, moduleVisitors,
        compilationVisitors, compiler.fileIdTable, options)?;
    mut string fileArgs = [join " " ~ a for a in result.objFiles];
    string[] intermediateFiles = result.intermediateFiles;
    if (options.umlFile != "") {
        umlVisitor.writeTo(options.umlFile);
    }
    if (options.docGenFolder != "") {
        docGenVisitor.writeTo(options.docGenFolder);
    }

    string binHashOutput = ".obj/hash_$(result.hash.text).c";
    with (result.hash) {
        write(binHashOutput,
"long long int compiler_hash_add() { return $(add)LL; }
long long int compiler_hash_mult() { return $(mult)LL; }
"       );
    }
    fileArgs ~= " " ~ binHashOutput;
    mut auto intermediates = result.intermediateFiles;
    intermediates ~= binHashOutput;

    string unittestCode() {
        mut string ret;
        for (symbol in unittestVisitor.symbols) {
            ret ~= "extern void $symbol();\n";
        }
        ret ~= "void _run_unittests() {\n";
        for (symbol in unittestVisitor.symbols) {
            ret ~= "  $symbol();\n";
        }
        ret ~= "}\n";
        return ret;
    }

    auto unittestFile = ".obj/_run_unittests.c";

    unittestFile.write(unittestCode);
    fileArgs ~= " " ~ unittestFile;
    intermediates ~= unittestFile;

    (string | Error) mainName() => result.module_.extractFunction("main", settings, __RANGE__)?
        .mangle;

    if (options.intermediateListFile != "") {
        options.intermediateListFile.write(mainName? ~ "\n" ~ intermediates.join("\n") ~ "\n");
    }

    if (options.dontLink) {
        compiler.clear;
        if (options.cpr) workPool.report;
        return;
    }

    mut string baseFlags;
    if (options.optimize) baseFlags ~= " -Ofast";
    if (options.extraCFlags) baseFlags ~= " $(settings.extraCFlags)";

    version (LLVMBackend) {
        if (options.backend.instanceOf(LLVMBackend) && options.optimize)
            baseFlags ~= " -flto";
    }

    mut string flags = baseFlags ~ " -rdynamic";
    mut string linkerFlags = " -ldl";
    for (linkerArg in options.linkerArgs) linkerFlags ~= " " ~ linkerArg;
    mut string compilerCmd = "clang-15 -opaque-pointers -Wno-unused-command-line-argument -Wno-unknown-attributes -fpic";
    if (options.backend.instanceOf(CBackend)) compilerCmd = getEnv("CC", "gcc");
    if (options.noMain)
        flags ~= " -DNEAT_NO_MAIN";
    else
        flags ~= " -DMAIN=$(mainName?)";
    string runtime = execPath ~ "/src/runtime.c";
    string cmd = "$compilerCmd$flags$fileArgs $runtime -o $(options.output)$linkerFlags";
    if (settings.platform.platformFlags.verbose) {
        print("\$ $cmd");
    }
    neat_runtime_system(cmd);
    if (!options.fileIdOutput.empty) {
        mut string content;
        // FIXME something goes wrong with the refcounting if I directly access pinnedFileIds.keys here
        auto pinnedFileIds = compiler.fileIdTable.instanceOf(FileIdTableImpl)?.pinnedFileIds else die;
        for (id in pinnedFileIds.keys) {
            auto name = compiler.fileIdTable.toFileName(id);
            content ~= "--file-id-pin $id $name\n";
        }
        options.fileIdOutput.write(content);
    }
    compiler.clear;
    if (options.cpr) workPool.report;
    if (options.run) {
        import package(compiler).std.process : exec;

        auto debugCmd = options.output ~ " " ~ options.runArgs.join(" ");
        if (settings.platform.platformFlags.verbose) {
            print("\$ $debugCmd");
        }
        exec(options.output, options.runArgs);
    }
}

void main(mut string[] args)
{
    mkdir(".obj");
    string executable = args[0];
    args = args[1 .. $];
    string[] allArgs = args;
    string execPath = "/proc/self/exe".realpath.dirname;
    auto options = new Options;
    // TODO make configurable somehow? commandline arg?
    options.parseConfig(execPath ~ "/neat.ini");
    args = options.parseArgs(executable, args);
    options.addDefaults;

    string reqVer = options.requestedCompilerVersion;
    if (reqVer != "" && reqVer != options.runningCompilerVersion) {
        swapCompilerVersion(options, allArgs, reqVer, "on the commandline");
    }

    if (args.length != 1)
    {
        help(options.argParser, executable);
        return;
    }
    auto pool = new ThreadPool(options.threads);
    auto workPool = new WorkPool(pool);
    (void | Error) build(int loopPass)
        => .build(options, workPool=workPool, args=args, allArgs=allArgs, execPath=execPath, loopPass=loopPass);
    if (options.loop) {
        mut int loopPass = 0;
        while (true) {
            build(loopPass=loopPass++).case {
                void: {}
                Error err:
                    .printError(err, options.fileIdTable);
            }
            if (options.watch) {
                watchForChanges(workPool);
            } else {
                print("Press <return> to continue.");
                getchar;
            }
            workPool.refresh;
        }
    } else {
        build(loopPass=0).case {
            void: return;
            Error err:
                .printError(err, options.fileIdTable);
                exit(1);
        }
    }
}

void watchForChanges(WorkPool workPool) {
    import c.unistd : read, close;

    auto files = [task.instanceOf(ReadFileTask).path for task in workPool.allDependencies("")
        where task.instanceOf(ReadFileTask)];
    print("Change any file to continue.");
    int fd = inotify_init;
    auto watches = [fd.inotify_add_watch(file.toStringz, IN_MODIFY | IN_DELETE_SELF) for file in files];
    auto buf = new ubyte mut[](8192);
    while (true) {
        long len = read(fd, buf.ptr, buf.length);
        mut int offs = 0;
        while (offs < len) {
            auto event = cast(inotify_event*) &buf[offs];
            auto target = [first file for i, file in files where watches[i] == event.wd];
            print("File '$target' changed, continuing...");
            break;
            // print("event $(event.mask), $(event.len), $(event.wd) for target=$target");
            offs += sizeof(inotify_event) + event.len;
        }
        break;
    }
    [fd.inotify_rm_watch(watch) for watch in watches];
    close(fd);
}

(void | Error) build(
    Options options, WorkPool workPool, string[] args, string[] allArgs, string execPath, int loopPass
) {
    if (args[0] == "build") {
        return buildPackage(options, workPool, allArgs, execPath, loopPass=loopPass);
    } else {
        return buildFile(options, workPool, args[0], execPath=execPath, loopPass=loopPass);
    }
}

(void | Error) buildFile(Options options, WorkPool workPool, string mainFile, string execPath, int loopPass) {
    // Add "." default package for commandline builds
    // This must be first in the list so that commandline can always override it.
    auto packages = options.astPackages.resolvePackages(execPath);
    auto packages = [new Package(name="src", path=realpath("."), packages)] ~ packages;

    if (!options.output.length) options.output = mainFile.basename.withoutExtension;

    return buildBinary(options, workPool, mainFile, execPath=execPath, packages, loopPass=loopPass);
}

(void | Error) buildPackage(Options options, WorkPool workPool, string[] allArgs, string execPath, int loopPass) {
    mut Package[] packages = options.astPackages.resolvePackages(execPath);
    BinaryPackageFile pkgFile() {
        loadPkgFile(".", options.runningCompilerVersion).case {
            PackageFile file:
                if (auto bin = file.instanceOf(BinaryPackageFile))
                    return bin;
                print("Cannot build binary for non-binary package!");
                exit(1);
            ReloadCompiler reload:
                swapCompilerVersion(options, allArgs, reload.requestedVer, "in package.json");
            (:notFound):
                print("package.json not found.");
                exit(1);
        }
    }
    auto pkgFile = pkgFile;
    options.output = pkgFile.binary;
    mut PackageLock packageLock = loadPkgLock(".").case(
        PackageLock f: f,
        (:notFound): new PackageLock([]));
    // default commandline packages
    auto ret = resolvePackageVersions("src", ".", packages, [], packageLock, new VersionProvider,
                                        currentCompiler=options.runningCompilerVersion);
    Package pkg() {
        ret.case {
            (:mismatched): {
                print("Package resolution failed. :-(");
                exit(1);
            }
            ReloadCompiler reload:
                assert(false); // should have been handled earlier
            (Package package_, PackageLock resultLock): {
                packageLock = resultLock;
                return package_;
            }
        }
    }
    auto pkg = pkg;
    writePkgLock(packageLock, ".");

    Package[] allRecursiveDeps() {
        mut Package[string] packages;
        void scan(Package pkg) {
            if (pkg.name == "compiler") return;
            if (packages.has(pkg.name)) return;
            packages[pkg.name] = pkg;
            [scan(a) for a in pkg.deps];
        }
        scan(pkg);
        return packages.values;
    }

    packages ~= allRecursiveDeps;
    // print("Packages: " ~ [join ", " a.repr for a in packages]);
    return buildBinary(options, workPool, pkgFile.main, execPath=execPath, packages, loopPass=loopPass);
}

/**
 * Must be done first to ensure we allow some degree of forward compat.
 * Really, we should be pulling out -compiler-version= separately.
 */
void swapCompilerVersion(Options options, string[] allArgs, string reqVerStr, string where) {
    print("Wrong compiler version, running $(options.runningCompilerVersion) but requested $(
        reqVerStr) $where. Bootstrapping $(reqVerStr)...");
    Version reqVer = Version.parse(reqVerStr);
    string zipName() {
        if (reqVer.lesser("0.1.4")) return "neat-$reqVerStr-gcc.zip";
        return "neat-v$reqVerStr-gcc.zip";
    }
    string url = "https://github.com/Neat-Lang/neat/releases/download/v$reqVerStr/$zipName";
    import package(compiler).std.process : system_iret;
    string targetPath = "$neatCachePath/compilers/v$reqVerStr";
    void system_v(string s) {
        print("\$ " ~ s);
        int ret = system_iret(s);
        if (ret != 0) {
            print("command failed with $ret!");
            // avoid cycle
            if (!s.startsWith("rm -rf")) system_v("rm -rf $targetPath");
            exit(1);
        }
    }
    int system_iret_v(string s) { print("\$ " ~ s); return system_iret(s); }
    string dirName() {
        if (reqVer.lesser("0.1.7")) return "neat";
        return "neat-v$reqVerStr";
    }
    if (!targetPath.exists) {
        system_v("mkdir -p $targetPath");
        system_v("wget -c $url -O $targetPath/$zipName");
        system_v("cd $targetPath && unzip $zipName && cd $dirName && ./build.sh");
    }
    // TODO shell escape
    exit(system_iret_v("$targetPath/$dirName/neat " ~ allArgs.join(" ")));
}

extern(C) int getchar();
