module neat.base;

import backend.base;
import helpers;
import polyhash;

enum TokenType {
    none,
    end,
    whitespace,
    identifier,
    number,
    comment,
    dot,
    comma,
    singleQuote,
    charLiteral,
    doubleQuote, // ["]foo $(bar) baz["]
    stringLiteral, // "[foo ]$(bar)[ baz]"
    formatQuoteStart, // "foo [$](bar)"
    backtick,
    colon,
    semicolon,
    lparen,
    rparen,
    smaller,
    greater,
    equal,
    exclamationmark,
    questionmark,
    dollar,
    lsquarebracket,
    rsquarebracket,
    lcurlybracket,
    rcurlybracket,
    plus,
    minus,
    asterisk,
    slash,
    backslash,
    circumflex,
    percent,
    tilde,
    ampersand,
    bar,
    hash,
}

// something that can be referenced by a name
abstract class Symbol
{
    string repr() {
        // TODO this.__classname
        return "TODO Symbol.repr $(cast(void*) this)";
    }
    string toString() return repr;
}

/**
 * Gifted: An expression with an unmanaged lifetime that we must take over.
 * Ephemeral: An expression that will be freed at some indeterminate point.
 * Lexical: An expression that will be freed at the earliest when the scope ends.
 * Permanent: An expression that will never naturally be freed.
 *  (Can be incremented and decremented, but must remain above 1.)
 * None: An expression that should not have rc done on it.
 *
 * Examples:
 * - gifted: `new Class()`
 * - ephemeral: `foo.(that)`
 * - lexical: `void foo(Class obj) { }` or `Class obj;`
 * - permanent: `"string"`
 * - none: cast(T) foo
 */
enum Lifetime
{
    gifted,
    ephemeral,
    lexical,
    permanent,
    none,
}

struct ExprInfo
{
    Lifetime lifetime;

    string repr() {
        mut string ret;
        if (lifetime == Lifetime.gifted) ret ~= "gifted";
        else if (lifetime == Lifetime.ephemeral) ret ~= "ephemeral";
        else if (lifetime == Lifetime.lexical) ret ~= "lexical";
        else if (lifetime == Lifetime.permanent) ret ~= "permanent";
        else if (lifetime == Lifetime.none) ret ~= "none";
        else assert(false);
        return ret;
    }
    string toString() return repr;
}

abstract class Expression : Symbol
{
    Type type;
    ExprInfo info;
    abstract int emit(Generator output);
    abstract void hash(Hash hash);
}

abstract class Statement
{
    abstract void emit(Generator output);
    abstract void hash(Hash hash);
    string repr() => "TODO Statement.repr";
    string toString() => repr;
}

abstract class Reference : Expression
{
    bool mutable;
    abstract int emitLocation(Generator output);
}

enum Protection
{
    public_,
    protected_,
    private_
}

abstract class Type : Symbol
{
    abstract BackendType emit(Platform platform);
    abstract bool same(Type type);
    string mangle() {
        print("Don't know how to mangle $(repr)");
        assert(false);
    }
    abstract void hash(Hash hash);

    bool zeroInitializable;

    bool hasElaborateCopyConstructor;

    (nullable Expression | fail Error) implicitConvertFrom(Context context, Expression source, LocRange locRange)
    {
        return null;
    }

    (nullable Expression | fail Error) implicitConvertTo(
        Context context, Expression source, Type target, LocRange locRange)
    {
        return null;
    }

    /**
     * Implicitly converts to the target without change in bits.
     * Used for implicit array type conversion.
     */
    bool triviallyConvertsTo(Type target)
    {
        return this.same(target);
    }

    (nullable Expression | fail Error) truthy(Context context, Expression expr, LocRange locRange)
    {
        return null;
    }

    /**
     * Called to create a copy of the expression.
     * The returned expression will count as a new reference.
     */
    (Expression | fail Error) copy(Context context, Expression source, LocRange locRange)
    {
        return source;
    }

    /**
     * Called when a scoped expression goes out of scope.
     */
    nullable Statement endLifetime(Context context, Expression value)
    {
        return null;
    }

    /**
     * When looking up a nember in this type at scope 'namespace',
     * what is the maximum protection level of the member where
     * lookup will succeed?
     */
    Protection protectionAt(Namespace namespace) {
        // all are visible by default.
        return Protection.private_;
    }

    /**
     * Called to resolve 'value.field'.
     * If 'base' is null, this indicates a static field access, 'Type.field'.
     */
    (nullable Symbol | fail Error) accessMember(
        Context context, nullable Expression base, string field, Protection protection, LocRange locRange)
    {
        return null;
    }

    /**
     * Called to resolve `value.field(args)`.
     */
    (nullable Expression | fail Error) callMember(
        Context context, nullable Expression base, string field, ASTArgument[] args, Protection protection, LocRange locRange)
    {
        return null;
    }

    /**
     * Called to resolve `value.field = arg`.
     */
    (nullable Statement | fail Error) assignMember(
        Context context, Expression base, string field, Expression arg, Protection protection, LocRange locRange)
    {
        return null;
    }

    /**
     * Called to resolve `base[index]`.
     */
    (nullable Expression | fail Error) index(Context context, Expression base, Expression index, LocRange locRange)
    {
        return null;
    }

    /**
     * Called to resolve `base[index] = value`.
     */
    (nullable Statement | fail Error) indexAssignment(
        Context context, Expression base, Expression index, Expression value, LocRange locRange)
    {
        return null;
    }

    /**
     * Called to resolve 'lhs op rhs' where op is a binary operator.
     */
    (nullable Expression | fail Error) binaryOp(Context context, string op, Expression lhs, Expression rhs, LocRange locRange)
    {
        return null;
    }

    /**
     * Called to resolve 'Type(a, b, c)'.
     *
     * TODO: rename to callType
     */
    (nullable Expression | fail Error) call(Context context, LocRange locRange, ASTArgument[] args)
    {
        return null;
    }

    /**
     * Called to resolve `expr(a, b, c)`, where `typeof(expr)` is `Type`.
     *
     * TODO: rename to call
     */
    (nullable Expression | fail Error) callExpr(Context context, LocRange locRange, Expression expr, ASTArgument[] args)
    {
        return null;
    }

    /**
     * Implement lambda quarantine checks.
     * So far, only return is affected directly.
     *
     * See: doc/quarantine.md
     */
    (void | fail Error) checkQuarantine(Context context, LocRange locRange, QuarantineReason reason)
    {
    }

    /**
     * Case `a.b = c`:
     * Behavior depends on the quarantine policy of `a` and `c`.
     * Assignment of a checked value to an occluded container field is an error.
     * Assignment of a checked value to a transparent non-lexical container field is an error.
     *  - But I think it's impossible. How can you lexically export the type?
     */
    QuarantinePolicy quarantinePolicy()
    {
        return QuarantinePolicy(container=:occluded, value=:harmless);
    }
}

struct QuarantinePolicy {
    // transparent containers allow assignment
    (:transparent | :occluded) container;
    (:checked | :harmless) value;
}

alias QuarantineReason = (
    :returningFrom, Returnable returnable
);

interface Hashable
{
    (ASTSymbol | fail Error) hash(Context context, Expression value, LocRange locRange);
}

class Generator
{
    BackendModule mod;

    nullable BackendFunction fun;

    FileIdTable fileIdTable;

    Platform platform;

    int frameReg;

    string[] extraLibs; // from pragma(lib)

    this(this.platform, this.mod, this.fileIdTable)
    {
        this.fun = null;
    }

    bool once(string name)
    {
        return this.mod.once(name);
    }

    void addLibrary(string lib) {
        for (lib2 in extraLibs) if (lib == lib2) return;
        this.extraLibs ~= lib;
    }
}

abstract class ASTSymbol
{
    LocRange locRange;

    abstract (Symbol | fail Error) compile(Context context);

    ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTSymbol'! this=$(cast(size_t) this)"); assert(false); }

    // TODO this.classname
    string repr() { return "TODO repr(ASTSymbol): $(locRange.toString)"; }
    string toString() => repr;
}

// TODO Statement, Context multi-return
struct StatementCompileResult
{
    Statement statement;

    Namespace namespace;
}

abstract class ASTStatement
{
    LocRange locRange;

    abstract (StatementCompileResult | fail Error) compile(Context context);

    ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTStatement'!"); assert(false); }

    // TODO this.classname
    string repr() { return "TODO repr(ASTStatement): $(locRange.toString)"; }
}

/**
 * Something that updates a namespace without behavioral side effects:
 *
 * - import
 * - alias
 * - struct decl
 * - class decl
 *
 * Ironically, a variable declaration is not an ASTDeclaration.
 * Find a better name?
 */
abstract class ASTDeclaration
{
    LocRange locRange;

    abstract (Namespace | fail Error) compile(Context context);

    abstract ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTDeclaration'!"); assert(false); }

    // TODO this.classname
    string repr() { return "TODO repr(ASTDeclaration)"; }
}

abstract class ASTSymbolDeclaration : ASTDeclaration
{
    string name;

    abstract (Symbol | fail Error) compileSymbol(Context context);

    override (Namespace | fail Error) compile(Context context)
    {
        auto symbol = compileSymbol(context)?;

        return context.compiler.exprAlias(context.namespace, this.name, symbol);
    }
}

alias ExtForVarDecl = ((:auto_ | ASTSymbol | :none) type, LocRange locRange, string name);

enum LookupReason
{
    // normal name lookup
    identifier,
    // lookup for foo.bar (ufcs, don't match class methods on 'this')
    ufcs,
    // didYouMean,
}

/**
 * A namespace is a lexical environment that supports identifier lookup.
 * Note that this means "foo", not "a.foo".
 */
abstract class Namespace
{
    nullable Namespace parent; // lexical parent

    bool isContextScope;

    this(this.parent, this.isContextScope) { }

    /**
     * name:    The name being looked up.
     *
     * context: The compiler context originating the lookup.
     *          The namespace in context is used as the provenance of the lookup,
     *          meaning it decides whether private members may be read.
     *
     * loc:     The location of the symbol triggering the lookup.
     */
    abstract (nullable Symbol | fail Error) lookup(
        string name, Context context, LookupReason reason, LocRange locRange);

    string mangle() { return this.parent.mangle; }
    abstract string repr();
}

/// Something that 'return' returns from.
interface Returnable
{
    /// We want to return `proposed`, so give me a type you can be happy with.
    (Type | fail Error) mergeReturn(Context context, Expression ret, LocRange locRange);
}

/// Something that variables can be declared in.
interface Declarable
{
    LatentVariable declare(string name, Type[] frame, bool mut, bool borrowed, Platform platform);
}

// Namespace with unwind side effect, such as onExit call.
// Evaluated before declaration cleanup.
interface Unwindable
{
    (nullable Statement | fail Error) unwind(Context context);
}

// variable without stackframe
interface LatentVariable
{
    Type type();

    Expression localStackFrame(Context context);

    Reference access(Context context);
}

// Something that should be cleaned up on unwind.
// TODO remove this - it's redundant with Unwindable. (?)
abstract class DeclarationHolder : Namespace
{
    abstract bool freeOnExit();

    abstract Reference accessDecl(Context context);
}

/**
 * This contains the parts of Context that are never modified at all.
 */
final class ColdContext
{
    CompilerBase compiler;

    Platform platform;

    MacroState macroState;

    // here for caching reasons
    // TODO replace with once
    Type nativeWordType;

    int loopPass;

    ModulePreProcessor modulePreProcessor;

    ModulePostProcessor modulePostProcessor;

    this(this.compiler, this.platform, this.macroState, this.nativeWordType, this.loopPass,
         this.modulePreProcessor, this.modulePostProcessor) { }

    ColdContext withMacroState(MacroState macroState) {
        return new ColdContext(this.compiler, this.platform, macroState,
            this.nativeWordType, this.loopPass, this.modulePreProcessor,
            this.modulePostProcessor);
    }
}

/**
 * This contains the parts of Context that are modified occasionally,
 * but not too often.
 */
final class WarmContext
{
    // the reference by which free variables are resolved.
    nullable Expression framePointer;

    nullable ModuleBase compilingModule;

    LabelCounter labelCounter;

    IUniqCounter uniqCounter;

    LocRange[] errorStack;

    this(this.framePointer, this.compilingModule, this.labelCounter, this.uniqCounter, this.errorStack) { }

    WarmContext withFramePointer(nullable Expression framePointer) {
        return new WarmContext(
            framePointer, this.compilingModule, this.labelCounter,
            this.uniqCounter, this.errorStack);
    }

    WarmContext withCompilingModule(ModuleBase compilingModule) {
        return new WarmContext(
            this.framePointer, compilingModule, this.labelCounter,
            this.uniqCounter, this.errorStack);
    }

    WarmContext withLabelPrefix(string prefix) {
        auto labelCounter = new LabelCounter(prefix);
        auto uniqCounter = this.uniqCounter.dup;

        return new WarmContext(
            this.framePointer, this.compilingModule, labelCounter,
            uniqCounter, this.errorStack);
    }
}

/**
 * Generates unique text labels with a prefix.
 * Usually used for names that will appear in the output and must be stable between runs.
 */
class LabelCounter
{
    string prefix;

    int count;

    this(this.prefix = "uniq") { }

    string next() {
        auto count = this.count++;
        return "$(this.prefix)$count";
    }
}

/**
 * Generate a unique numeric label.
 * This class is more performant than `LabelCounter`.
 * The value is not stable between runs; however, it is guaranteed to be globally unique per program run.
 * `dup` must be called when the UniqCounter will be passed to another thread.
 */
interface IUniqCounter {
    int next();
    IUniqCounter dup();
}

// Used by main to analyze the AST tree (docgen)
interface ModulePreProcessor
{
    void process(ASTModuleBase astModule_);
}

// Will be used by main to start emitting modules as soon as they finish.
interface ModulePostProcessor
{
    void process(ModuleBase module_);
}

/**
 * Context used when transforming an AST into a semantic tree.
 *
 * TODO figure out how to reduce refcounts on this.
 */
struct Context
{
    Namespace namespace;

    WarmContext warmContext;

    ColdContext coldContext;

    Context withNamespace(Namespace namespace) {
        return Context(namespace, this.warmContext, this.coldContext);
    }

    Context withFramePointer(nullable Expression framePointer) {
        return Context(this.namespace, this.warmContext.withFramePointer(framePointer), this.coldContext);
    }

    Context withCompilingModule(ModuleBase compilingModule) {
        return Context(this.namespace, this.warmContext.withCompilingModule(compilingModule), this.coldContext);
    }

    Context withLabelPrefix(string prefix) {
        return Context(this.namespace, this.warmContext.withLabelPrefix(prefix), this.coldContext);
    }

    alias compiler = (coldContext.compiler);
    alias platform = (coldContext.platform);
    alias macroState = (coldContext.macroState);
    alias nativeWordType = (coldContext.nativeWordType);
    alias modulePreProcessor = (coldContext.modulePreProcessor);
    alias modulePostProcessor = (coldContext.modulePostProcessor);
    alias loopPass = (coldContext.loopPass);

    alias framePointer = (warmContext.framePointer);
    alias compilingModule = (warmContext.compilingModule);
    alias labelCounter = (warmContext.labelCounter);
    alias uniqCounter = (warmContext.uniqCounter);
    alias errorStack = (warmContext.errorStack);

    void pushErrorLoc(LocRange locRange) {
        this.warmContext.errorStack ~= locRange;
    }

    void popErrorLoc() {
        this.warmContext.errorStack = this.warmContext.errorStack[0 .. $ - 1];
    }

    (void | fail Error) assert2(bool test, LocRange locRange, string msg) {
        if (test) return;
        return new Error(warmContext.errorStack ~ locRange, msg);
    }

    string getLabel() { return this.warmContext.labelCounter.next; }

    int getUniqueId() { return this.warmContext.uniqCounter.next; }
}

// bleh cycle
abstract class ASTModuleBase
{
    string mangledName;

    abstract void addEntry(Protection protection, (ASTExternFunctionBase | ASTPragmaBase | ASTDeclaration) target);

    abstract void addAliasDecl(string name, Protection protection, ASTSymbol target);

    abstract nullable ASTSymbol getSymbolAlias(string name);
}

abstract class ASTPragmaBase
{
    abstract (FinishedSymbol | fail Error) compile(Context context);
}

abstract class ASTExternFunctionBase
{
    string name;

    abstract string repr();
}

// TODO clear all this up
abstract class FinishedSymbol
{
    abstract void emit(Generator generator);
    abstract void hash(Hash hash);
}

// cycle breaker helper: needed for CompilerBase
abstract class ModuleBase : Namespace
{
    string name;

    string mangledName;

    abstract void addImport(ModuleBase module_, bool public_, string[] symbols);

    abstract void addModuleDependency(ModuleBase module_);

    abstract (void | fail Error) compile(Context context);

    // Add symbol to list of anonymous symbols that will be emitted.
    abstract void track((Symbol | FinishedSymbol) sym);

    override string repr() => "Module";
}

struct ASTArgument
{
    ASTSymbol sym;

    string name;

    LocRange locRange;
}

struct ASTParameter
{
    string name;

    bool mutable;

    ASTSymbol type;

    nullable ASTSymbol defaultValue;

    LocRange locRange;
}

/*
 * Stackoverflow insists that "parameters" are the stuff in the function parameter list,
 * and "arguments" are the values you pass to a function.
 *
 * Fine by me.
 *
 * We could separate "declaration parameters" and "definition parameters."
 * For instance, extern(C) declarations are only interesting for generating a call,
 * and will never generate a function body. However, usually when meaningful information
 * is used to customize the define-site, this is also interesting for the call-site,
 * especially with regards to lifetime. As such, it's probably good there is only one type.
 */
struct Parameter
{
    bool isThisAssignment;

    string name;

    bool mutable;

    Type type;

    nullable Expression defaultValue;

    LocRange locRange;

    static Parameter fromType(Type type) {
        return Parameter(false, "", false, type, null, __RANGE__);
    }

    static Parameter simple(string name, Type type) {
        return Parameter(false, name, false, type, null, __RANGE__);
    }
}

// FIXME class Object
class ASTImportStatementBase
{
}

/**
 * Helper class used to break dependency loops between neat.base, macros and the rest of the compiler.
 */
abstract class CompilerBase
{
    WorkPoolBase workPool;

    // for std.macro.cimport
    string[] cFlags;

    FileIdTable fileIdTable;

    // parser
    abstract (Parser | fail Error) createParser(string filename, string fulltext);

    // all packages for the current build
    abstract Package[] allPackages();

    // must be called or LocRange IDs may be wrong.
    abstract void disposeParser(Parser parser);

    abstract (nullable ASTSymbol | fail Error) parseExpression(
        Parser parser, LexicalContext lexicalContext);

    abstract (nullable ASTSymbol | fail Error) parseExpressionLeaf(
        Parser parser, LexicalContext lexicalContext);

    abstract (nullable ASTSymbol | fail Error) parseType(
        Parser parser, LexicalContext lexicalContext);

    abstract (ASTStatement | fail Error) parseStatement(
        Parser parser, LexicalContext lexicalContext);

    abstract (nullable ASTDeclaration | fail Error) parseDeclaration(
        Parser parser, LexicalContext lexicalContext);

    abstract (ASTSymbol | fail Error) parseStringLiteral(
        Parser parser, LexicalContext lexicalContext);

    (ASTSymbol | fail Error) parseStringLiteral(
        Parser parser, LexicalContext lexicalContext, string separator, LocRange from)
    {
        return parseStringLiteral(parser, lexicalContext);
    }

    abstract (nullable ASTSymbolDeclaration | fail Error) parseTemplateStub(
        Parser parser, LexicalContext lexicalContext, string name, string comment,
        (nullable ASTSymbolDeclaration | fail Error) delegate!() dg);

    abstract (ASTStatement | fail Error) parseFunctionBody(
        Parser parser, LexicalContext lexicalContext);

    abstract ASTStatement astExpressionStmt(ASTSymbol expr, LocRange locRange);

    abstract ASTStatement astScope(ASTStatement[] stmts, LocRange locRange);

    // sequence of statements that don't open a new scope
    abstract ASTStatement astSequence(ASTStatement[] stmts, LocRange locRange);

    abstract ASTStatement astIf((ASTSymbol | ASTStatement) test, ASTStatement then, nullable ASTStatement else_, LocRange locRange);

    abstract ASTStatement astForLoop(
        ASTStatement init, ASTSymbol test, ASTStatement step, ASTStatement body_, LocRange locRange);

    abstract ASTStatement astExtForLoop(
        ASTSymbol source, ExtForVarDecl var1, (ExtForVarDecl | :none) var2, ASTStatement body_, LocRange locRange);

    abstract ASTStatement astAssign(ASTSymbol target, ASTSymbol source, LocRange locRange);

    // a += 2
    abstract ASTStatement astOpAssign(ASTSymbol left, string op, ASTSymbol right, LocRange locRange);

    abstract ASTStatement astDeclareVar(
        string name, bool mutable, bool uninitialized, nullable ASTSymbol initial, LocRange locRange);

    abstract ASTStatement astDeclareVarExtract(
        string name, bool mutable, bool infer, nullable ASTSymbol type, ASTSymbol source, LocRange locRange);

    // initial is optional
    abstract ASTStatement astDeclareTypedVar(
        string name, bool mutable, bool uninitialized, ASTSymbol type, nullable ASTSymbol initial, LocRange locRange);

    abstract ASTSymbol astReturn(ASTSymbol value, LocRange locRange);

    // TODO: remove
    abstract ASTSymbol astReturnNew(ASTSymbol value, bool failProp, LocRange locRange);

    abstract ASTSymbol astBreak(LocRange locRange);

    abstract ASTSymbol astContinue(LocRange locRange);

    // TODO: remove
    abstract ASTSymbol astBreakNew(LocRange locRange);

    // TODO: remove
    abstract ASTSymbol astContinueNew(LocRange locRange);

    abstract ASTStatement astDeclarationStatement(ASTDeclaration target, LocRange locRange);

    abstract ASTSymbol astBinaryOp(string op, ASTSymbol left, ASTSymbol right, LocRange locRange);

    abstract (ASTSymbol left, string op, ASTSymbol right | :none) destructAstBinaryOp(ASTSymbol sym);

    abstract ASTSymbol astCast(ASTSymbol target, ASTSymbol value, LocRange locRange);

    abstract (ASTSymbol target, ASTSymbol value | :none) destructAstCast(ASTSymbol sym);

    abstract ASTSymbol astIndex(ASTSymbol base, ASTSymbol index, LocRange locRange);

    abstract ASTSymbol astMember(ASTSymbol base, string name, LocRange locRange);

    abstract (ASTSymbol base, string member | :none) destructAstMember(ASTSymbol astMember);

    abstract ASTSymbol astReference(ASTSymbol value, LocRange locRange);

    abstract ASTSymbol astDereference(ASTSymbol value, LocRange locRange);

    abstract ASTSymbol astNumberLiteral(long value, LocRange locRange);

    abstract (long | :none) destructAstNumberLiteral(ASTSymbol sym);

    abstract ASTSymbol astStringLiteral(string text, LocRange locRange);

    abstract ASTSymbol astCharLiteral(char ch, LocRange locRange);

    abstract (string | :none) destructAstStringLiteral(ASTSymbol sym);

    abstract (ASTSymbol target, ASTArgument[] args | :none) destructAstCall(ASTSymbol sym);

    abstract ASTSymbol astFormatString(ASTSymbol[] parts, LocRange locRange);

    ASTSymbol astBoolLiteral(bool value, LocRange locRange) {
        if (value) return astIdentifier("true", locRange);
        else return astIdentifier("false", locRange);
    }

    abstract ASTSymbol astArrayLiteral(ASTSymbol[] values, LocRange locRange);

    abstract ASTSymbol astTupleLiteral(ASTSymbol[] entries, LocRange locRange);

    abstract ASTSymbol astTupleLiteral2((string name, ASTSymbol symbol)[] entries, LocRange locRange);

    abstract ASTSymbol astArraySlice(ASTSymbol array, ASTSymbol lower, ASTSymbol upper, LocRange locRange);

    // a .. b
    abstract ASTSymbol astIota(ASTSymbol from, ASTSymbol to, LocRange locRange);

    abstract ASTSymbol astVoidLiteral(LocRange locRange);

    abstract ASTSymbol astIdentifier(string name, LocRange locRange);

    abstract (string | :none) destructAstIdentifier(ASTSymbol sym);

    abstract ASTSymbol astNegation(ASTSymbol value, LocRange locRange);

    abstract (ASTSymbol | :none) destructAstNegation(ASTSymbol sym);

    abstract ASTSymbol astCall(ASTSymbol target, ASTSymbol[] args, LocRange locRange);

    abstract ASTSymbol astNewExpression(ASTSymbol type, (ASTSymbol[] | ASTArgument[]) args, LocRange locRange);

    abstract ASTSymbol astDestroy(ASTSymbol target, LocRange locRange);

    abstract ASTSymbol astStatementExpression(ASTStatement[] statements, ASTSymbol expr, LocRange locRange);

    abstract ASTSymbol astArray(ASTSymbol elementType, LocRange locRange);

    abstract ASTSymbol astBasicType(string name, LocRange locRange);

    abstract ASTSymbol astTypeOf(ASTSymbol symbol, LocRange locRange);

    abstract ASTSymbol astPointer(ASTSymbol target, LocRange locRange);

    abstract ASTSymbol astFunctionPointer(ASTSymbol ret, ASTSymbol[] params, LocRange locRange);

    abstract ASTSymbol astTupleType((string name, ASTSymbol type)[] members, LocRange locRange);

    abstract ASTSymbolDeclaration astStructDecl(string name, ASTStructMember[] members, bool externC, LocRange locRange);

    abstract ASTSymbol astUnion(string name, ASTUnionMember[] members, LocRange locRange);

    abstract ASTSymbol astEitherType((ASTSymbol symbol, bool fail, LocRange locRange)[] entries, LocRange locRange);

    abstract ASTSymbol astEitherCaseExpr(ASTSymbol base, ASTEitherCaseExprCase[] cases, LocRange locRange);

    abstract ASTStatement astEitherCaseStmt(
        ASTSymbol base, ASTEitherCaseStmtCase[] cases, nullable ASTStatement default_, LocRange locRange);

    abstract ASTSymbol astNullable(ASTSymbol next, bool nullify, LocRange locRange);

    abstract ASTExternFunctionBase astExternFunction(
        string name, ASTSymbol ret, ASTParameter[] params, bool variadic, LocRange retLocRange);

    abstract ASTModuleBase astModule(
        string name, Package pak, MacroState macroState, LocRange locRange, nullable ASTModuleBase parent);

    abstract ASTDeclaration astImport(string name, string pak, string[] symbols, LocRange locRange);

    abstract ASTDeclaration astImport2(string name, string pak, string[] symbols, LocRange locRange);

    abstract ASTPragmaBase astPragma(string pragma_, ASTSymbol[] args, LocRange locRange);

    abstract ASTSymbol astParenPropertyExpression(ASTSymbol base, ASTSymbol prop, LocRange locRange);

    abstract ASTModuleBase resolveImport(string pak, ASTImportStatementBase import_, LocRange locRange);

    // expressions and statements
    abstract (nullable Expression | fail Error) implicitConvertTo(
        Context context, Expression from, Type to, LocRange locRange);

    abstract (Expression | fail Error) binaryOp(
        string op, Context context, Expression left, Expression right, LocRange locRange);

    abstract Expression intLiteral(int value);

    abstract Expression wordLiteral(Platform platform, long value);

    abstract Expression boolLiteral(bool value);

    abstract Expression voidLiteral();

    abstract (Expression | fail Error) truthy(Context context, Expression value, LocRange locRange);

    abstract Expression castTo(Type target, Expression source);

    abstract Expression trivialCastTo(Type target, Expression source);

    abstract Expression stringLiteral(Platform platform, string value);

    abstract Reference stackFrame(Type type);

    abstract (nullable Expression | fail Error) call(
        Context context, ASTSymbol target, ASTArgument[] args, LocRange locRange, bool isImplCall);

    abstract Expression mkCall(Symbol target, Expression[] args, LocRange locRange);

    abstract Expression simpleCall(Context context, string name, Type ret, Expression[] args, LocRange locRange);

    abstract Expression pointerOffset(Expression pointer, Expression offset);

    // evaluate first `statement`, then `expression`.
    abstract Expression statementExpression(Statement statement, Expression expression);

    abstract Expression statementExpression(Statement statement, Expression expression, ExprInfo exprInfo);

    abstract Reference dereference(Expression value);

    abstract Expression reference(Reference ref_);

    abstract Expression functionReference(FunctionDeclarationBase funcDecl);

    abstract Expression wrap(nullable Statement before, Expression value, nullable Statement after);

    // wrap(), allowing References
    abstract Expression wrapRef(nullable Statement before, Expression value, nullable Statement after);

    // Call dg with expr or copy of expr.
    // If expr was a gift, it is freed after.
    abstract (Expression | fail Error) consume(
        Context context, Expression expr, (Expression | fail Error) delegate!(Expression) dg);

    abstract Statement consumeStmt(Context context, Expression expr, Statement delegate!(Expression) dg);

    /// Call dg with owned temp of expr.
    /// If expr was a gift, it is freed after.
    ///
    /// Set `mayUnwind` to true if `dg()` may unwind.
    /// in that case, borrowed `expr` must be copied.
    abstract (nullable Expression | fail Error) consumeTemporary(
            Context context, bool allowRefReturn, Expression expr,
            (nullable Expression | fail Error) delegate!(Expression) dg);

    abstract (nullable Symbol | fail Error) accessMember(
        Context context, Symbol base, string member, LocRange locRange, bool allowUndefined);

    abstract Reference structMemberReference(Reference base, int index);

    abstract (nullable Symbol | fail Error) accessMemberWithLifetime(
        Context context, Symbol base, string member, LocRange locRange, bool allowUndefined);

    // look up name following the namespace in context
    abstract (nullable Symbol | fail Error) lookup(
        Context context, LocRange locRange, LookupReason reason, string name);

    abstract Statement assignStatement(Reference target, Expression value);

    abstract Statement sequence(Statement first, nullable Statement second);

    Statement sequence2(nullable Statement first, Statement second) {
        if (auto first = first) return sequence(first, second);
        return second;
    }

    abstract Statement sequenceStatement(Statement[] stmts);

    abstract Statement ifStatement(Expression test, Statement then, nullable Statement else_);

    abstract Statement loopStatement(
            Context context, Statement initializer, Expression test, Statement body_, Statement step);

    abstract Statement returnStatement(Expression value);

    abstract Statement exprStatement(Expression test);

    abstract (Statement | fail Error) move(Context context, Reference target, Expression source, LocRange locRange);

    /// Create a temporary of `type`. Temporary is passed to `callback`, which returns an initializer.
    /// Returns Expression evaluating to "Initializer, then temporary".
    abstract (nullable Expression | fail Error) exprWithScratchspace(
        int uniqId, Type type, bool temporary, (nullable Statement | fail Error) delegate!(Reference) callback);

    abstract (Statement | fail Error) unwindScope(Context context, Namespace target, Statement next);

    abstract (nullable Statement | fail Error) stmtWithTemporary(
        int uniqId, Expression value, (nullable Statement | fail Error) delegate!(Reference) callback);

    abstract (nullable Expression | fail Error) exprWithTemporary(
        int uniqId, Expression value, (nullable Expression | fail Error) delegate!(Reference) callback);

    // don't create referenceable memory
    abstract (nullable Statement | fail Error) stmtWithTemporaryExpr(
        int uniqId, Expression value, (nullable Statement | fail Error) delegate!(Expression) callback);

    abstract (nullable Expression | fail Error) exprWithTemporaryExpr(
        int uniqId, Expression value, (nullable Expression | fail Error) delegate!(Expression) callback);

    abstract (nullable Expression | fail Error) exprWithTemporaryExpr(
        int uniqId, Expression value, bool copyLifetime,
        (nullable Expression | fail Error) delegate!(Expression) callback);

    /**
    * Create a runtime function that, given some parameters, declares and calls the ASTStatement
    * provided.
    * The function will be automatically linked in.
    */
    abstract FunctionDeclarationBase createRuntimeFunction(
        Context context, string name, Type ret, Parameter[] params, ASTStatement delegate!() makeBody);

    Namespace exprAlias(nullable Namespace parent, string name, Symbol value) {
        return symbolAlias(parent, name, value);
    }

    abstract Namespace symbolAlias(nullable Namespace parent, string name, Symbol value);

    abstract DeclarationHolder variableDeclaration(
        nullable Namespace parent, string name, Platform platform, Type type, bool mut, bool borrowed, bool hidden);

    abstract Type nativeWordType(Platform platform);

    abstract Type struct_(string name, StructMemberDeclaration[] members, LocRange locRange, string manglePrefix);

    abstract Type eitherType((bool fail, Type type)[] types);

    abstract (Type | :none) isArrayType(Type type);

    abstract (string | :none) isBasicType(Type type);

    abstract (Symbol | fail Error) identifier(Context context, string name, bool moduleLevel, LocRange locRange);

    (Expression | fail Error) expectImplicitConvertTo(Context context, Expression from, Type to, LocRange locRange)
    {
        if (auto result = implicitConvertTo(context, from, to, locRange)?) return result;
        context.assert2(false, locRange, "Cannot convert to $(to.repr): $(from.type.repr)")?;
    }

    // true if ClassType or IntfType
    abstract bool isClassType(Type type);

    // called when expr is discarded (usually via ignored return value)
    abstract (void | fail Error) discardErrorCheck(Expression expr, LocRange locRange);

    abstract (void | fail Error) addDefaultImports(Context context, ModuleBase module_);

    abstract ModuleBase createModule(
        string name, string mangle, string moduleParseTaskId, LocRange locRange, nullable ModuleBase parent);

    abstract string queueModuleCompilation(Context context, ASTModuleBase module_);

    abstract (ModuleBase | fail Error) getCompiledModule(string id);

    LocRange makeLocRange((string | int) fileName, int fromRow, int fromColumn, int toRow, int toColumn) {
        int fileId = fileName.case(string s: -1, int i: i);
        return LocRange(fileId, (fromRow, fromColumn), (toRow, toColumn));
    }

    abstract IUniqCounter uniqCounter();
}

alias ASTStructMember = (string name, Protection protection, ASTSymbol type);

alias ASTUnionMember = (string name, ASTSymbol type);

abstract class FunctionDeclarationBase : Symbol
{
    string name;

    /**
     * The field for the `ret` accessor.
     * The created function should only become globally visible once `ret` has been resolved.
     * Yes this identifier is supposed to look ugly.
     * See Function::inferReturnType.
     */
    nullable Type retWIP;

    Type ret() { return this.retWIP.notNull; }

    Parameter[] params;

    bool variadic;

    nullable Type contextType; // must be a pointer

    abstract void declare(Generator output);

    abstract string mangle();
}

/**
 * This is in base because it's circular with Context.
 */
class MacroState
{
    Macro[] macros;

    MacroState[] imports;

    this() { }

    MacroState dup() {
        auto newState = new MacroState;
        newState.macros = new Macro[](this.macros.length);
        for (i, macro_ in this.macros)
            newState.macros[i] = macro_;
        newState.imports = new MacroState[](this.imports.length);
        for (i, import_ in this.imports)
            newState.imports[i] = import_;
        return newState;
    }

    void applyMacro(MacroArgs args) {
        this.applyMacroExported(args);
        if (args.done) return;
        for (import_ in this.imports) {
            import_.applyMacroExported(args);
            if (args.done) return;
        }
    }

    void applyMacroExported(MacroArgs args) {
        for (macro_ in this.macros) {
            macro_.apply(args);
            if (args.done) return;
        }
    }

    void addImport(MacroState target) {
        this.imports ~= target;
    }

    void addMacro(Macro macro_) {
        this.macros ~= macro_;
    }
}

abstract class Macro
{
    abstract void apply(MacroArgs args);
}

// macro subclasses are differentiated by args
abstract class MacroArgs
{
    abstract bool done();
}

// hook the ASTCall -> Call transform
class CallMacroArgs : MacroArgs
{
    ASTSymbol target;
    ASTArgument[] args;
    Context context;
    LocRange locRange;
    (nullable Expression | fail Error) transformed; // out
    this() {
        this.transformed = null;
    }
    void set(this.target, this.args, this.context, this.locRange) {
        this.transformed = null;
    }
    override bool done() {
        return this.transformed.case(nullable Expression expr: !!expr, Error: true);
    }
}

/// Placed here to allow quoting a.case()
struct ASTEitherCaseExprCase
{
    LocRange locRange;

    ASTSymbol type;

    // may be null
    string identifier;

    bool fail; // Helper: used for returning failure.

    ASTSymbol expr;
}

struct ASTExprCaseExprCase
{
    LocRange locRange;

    ASTSymbol value;

    ASTSymbol expr;
}

// alternate interpretation: value.case(2: "A", 3: "B");
(ASTExprCaseExprCase | fail Error) reinterpretAsExprCase(ASTEitherCaseExprCase arg, Context context) {
    context.assert2(arg.identifier == "", arg.locRange, "Expression case cannot have a name")?;
    context.assert2(arg.fail == false, arg.locRange, "Expression case cannot be 'fail'")?;
    return arg.(ASTExprCaseExprCase(locRange, type, expr));
}

/**
 * Tag types that are reinterpretable as sumtypes.
 * This exists for one usecase only: so that you can do
 * ```
 * nullable Object obj;
 * Object obj = obj.case(null: return null);
 * ```
 */
interface CanTreatAsEither
{
    (nullable Expression | fail Error) toEitherType(Context context, Expression base);
}

///
struct ASTEitherCaseStmtCase
{
    LocRange locRange;

    ASTSymbol type;

    string identifier;

    ASTStatement stmt;
}

class Overload : Symbol
{
    Symbol[] parts;

    this(this.parts) { }

    override string repr() {
        mut string partsRepr;
        for (i, part in parts) {
            if (i) partsRepr ~= ", ";
            partsRepr ~= part.repr;
        }
        return "[$partsRepr]";
    }
}

// hook parseExpressionBase
class ParseExpressionBaseArgs : MacroArgs
{
    Parser parser;
    LexicalContext lexicalContext;
    (nullable ASTSymbol | fail Error) symbol; // out
    this(this.parser, this.lexicalContext) {
        this.symbol = null;
    }
    override bool done() {
        return this.symbol.case(nullable ASTSymbol sym: !!sym, Error: true);
    }
}

// hook parseProperties
class ParsePropertyArgs : MacroArgs
{
    Parser parser;
    LexicalContext lexicalContext;
    ASTSymbol left;
    (nullable ASTSymbol | fail Error) result; // out
    this(this.parser, this.lexicalContext, this.left) {
        this.result = null;
    }
    override bool done() {
        return this.result.case(nullable ASTSymbol sym: !!sym, Error: true);
    }
}

// hook parseStatement
class ParseStatementArgs : MacroArgs
{
    Parser parser;
    LexicalContext lexicalContext;
    (nullable ASTStatement | fail Error) statement; // out
    this(this.parser, this.lexicalContext) {
        this.statement = null;
    }
    override bool done() {
        return this.statement.case(nullable ASTStatement stmt: !!stmt, Error: true);
    }
}

interface ImportModuleBaseTask : ITask
{
    (ASTModuleBase | fail Error) module_();
}

// hook "import "
class ParseImportArgs : MacroArgs
{
    Parser parser;
    LexicalContext lexicalContext;
    (nullable ASTModuleBase | fail Error | ImportModuleBaseTask) module_; // out
    this(this.parser, this.lexicalContext) {
        this.module_ = null;
    }
    (ASTModuleBase | ImportModuleBaseTask | fail Error) getModule(CompilerBase compiler) {
        return this.module_.case(
            nullable ASTModuleBase base: base.notNull,
            ImportModuleBaseTask task: task,
            Error err: err);
    }
    override bool done() {
        return this.module_.case(
            ImportModuleBaseTask task: true,
            nullable ASTModuleBase mod: !!mod,
            Error: true);
    }
}

abstract class Parser
{
    // Whether our file ID must be preserved in the next binary.
    bool pinned;

    abstract void begin();
    abstract void commit();
    abstract void revert();
    abstract bool accept(string match);
    abstract Error fail(string message);
    abstract LocRange loc();
    abstract LocRange from();
    abstract LocRange to(LocRange from);
    abstract void strip();
    abstract string parseLastComment();
    abstract string text();
    abstract bool acceptToken(TokenType type);
    abstract bool acceptToken2(TokenType first, TokenType second);
    abstract bool acceptToken3(TokenType first, TokenType second, TokenType third);
    abstract bool acceptToken2Not(TokenType match, TokenType nomatch);
    abstract bool acceptToken2Not2(TokenType match, TokenType nomatch1, TokenType nomatch2);
    abstract (string | :none) acceptTokenStr(TokenType type);
    abstract bool acceptIdentifier(string identifier);
    abstract (void | fail Error) expectToken(TokenType token);
    abstract bool peekToken(TokenType type);
    abstract void dropToken();
    abstract bool eof();
    abstract bool hard_eof();
    abstract (void | fail Error) verifyTransactions(string msg, (void | fail Error) delegate!() dg);
    abstract string parseIdentifier();
    abstract (:failure | :success, long, bool withBasePrefix | fail Error) parseNumber();

    (void | fail Error) assert_(bool flag, string message)
    {
        if (!flag) return this.fail(message);
        return;
    }

    (void | fail Error) expect(string match)
    {
        if (this.accept(match))
            return;
        return this.fail("'" ~ match ~ "' expected");
    }

    ParserTransaction transaction() {
        return ParserTransaction(this, committed=false);
    }

    bool isKeyword(string identifier) {
        // :sigh: TODO Give macros the ability to define custom reserved keywords.
        if (identifier == "the") return true;
        return identifier == "mut" || identifier == "auto" || identifier == "new" || identifier == "return";
    }
}

(void | fail Error) expectIdentifier(Parser parser, string match)
{
    if (parser.acceptIdentifier(match))
        return;
    return parser.fail("'" ~ match ~ "' expected");
}

bool acceptTokenIdentifier(Parser parser, TokenType first, string second) with (parser)
{
    if (!peekToken(first)) return false;
    begin;
    dropToken;
    if (!acceptIdentifier(second)) {
        revert;
        return false;
    }
    commit;
    return true;
}

struct ParserTransaction
{
    private Parser parser;
    private bool committed;
    void onEnter() {
        parser.begin;
    }
    void onExit() {
        if (!committed) parser.revert;
    }
    void commit() {
        assert(!committed);
        parser.commit;
        committed = true;
    }
}

class StructMemberDeclaration
{
    string name;

    Protection protection;

    Type type;

    this(this.name, this.protection, this.type) { }
}

abstract class LexicalContext
{
    CompilerBase compiler;

    Package pak;

    // here so downstream tasks can be declared as depending on parsing this module
    string moduleParseTaskId;

    MacroState macroState;

    // break an annoying dependency cycle
    abstract (ASTModuleBase | fail Error) resolveImport(ASTImportStatementBase importStmt);
}

class Package
{
    string name;
    string path;
    Package[] deps;

    this(this.name, this.path, this.deps) { }

    void addDependency(Package dep) {
        this.deps ~= dep;
    }

    ASTSymbol quote(Quoter quoter) {
        mut ASTSymbol[] deps_;
        for (auto dep in this.deps)
            deps_ ~= dep.quote(quoter);
        return quoter.compiler.astNewExpression(
            quoter.compiler.astIdentifier("Package", __RANGE__), [
                quoter.compiler.astStringLiteral(this.name, __RANGE__),
                quoter.compiler.astStringLiteral(this.path, __RANGE__),
                quoter.compiler.astArrayLiteral(deps_, __RANGE__)], __RANGE__);
    }

    string repr() {
        mut string depStr;
        for (dep in deps) {
            if (depStr.length) depStr ~= ", ";
            depStr ~= dep.name;
        }
        return "Package($name, $path, [$depStr])";
    }
}

abstract class WorkPoolBase
{
    abstract void queue(ITask task);
    abstract ITask wait(string id);
    // if `provider` is not fresh, `consumer` is not fresh.
    abstract void dependency((string | :current) provider, (string | :current) consumer);
}

interface ITask
{
    void run();
    string id();
    // Return false if environment conditions have changed from when the task was added.
    // For instance, if a file changed checksum or last-modified date.
    bool fresh();
}

/**
 * Helper class used for quasiquoting.
 * Transforms an AST* into an ASTSymbol representing a CompilerBase call producing this thing.
 */
abstract class Quoter {
    CompilerBase compiler; // for use by quote() methods

    abstract ASTSymbol compilerCall(string name, ASTSymbol[] parameters, LocRange locRange);
    abstract ASTSymbol quoteLocRange(LocRange locRange);
}

class Error
{
    LocRange[] stack;

    string msg;

    this(this.stack, this.msg) { }
}

extern(C) void exit(int);

interface FileIdTable
{
    int toFileId(string filename);
    void setInheritedFileId(int id, string filename);
    string toFileName(int fileId);
    void pin(int fileId);
}

struct LocRange {
    int fileId;
    (int row, int column) from;
    (int row, int column) to;

    string repr(FileIdTable fileIdTable) {
        return fileIdTable.toFileName(fileId) ~ ":" ~ itoa(from.row + 1) ~ ":" ~ itoa(from.column + 1);
    }

    string toString() {
        return "[?$fileId]:" ~ itoa(from.row + 1) ~ ":" ~ itoa(from.column + 1);
    }

    Error fail(string message) {
        return new Error([*this], message);
    }

    (bottom | fail Error) die(string message) {
        return new Error([*this], message);
    }

    // This should have been caught earlier.
    void hardCheck(bool flag, string message) {
        if (flag) return;
        print("$(toString): Internal compiler error!");
        print(message);
        exit(1);
    }

    BackendLocation toBackendLoc(FileIdTable fileIdTable) {
        mut BackendLocation ret;
        ret.file = fileIdTable.toFileName(fileId);
        ret.line = from.row;
        ret.column = from.column;
        return ret;
    }

    (void | fail Error) assert(bool test, string a) {
        if (!test) return this.fail(a);
    }
    (void | fail Error) assert2(bool test, string a, string b) {
        if (!test) return this.fail(a ~ b);
    }
    (void | fail Error) assert3(bool test, string a, string b, string c) {
        if (!test) return this.fail(a ~ b ~ c);
    }
    (void | fail Error) assert4(bool test, string a, string b, string c, string d) {
        if (!test) return this.fail(a ~ b ~ c ~ d);
    }
    (void | fail Error) assert5(bool test, string a, string b, string c, string d, string e) {
        if (!test) return this.fail(a ~ b ~ c ~ d ~ e);
    }
}

template notNull(T) {
    nonnullable T notNull(nullable T arg) {
        if (auto a = arg) return a;
        assert(false);
    }
}

bottom exitWithError(Error err, nullable FileIdTable fileIdTable = null) {
    printError(err, fileIdTable);
    exit(1);
}

void printError(Error err, nullable FileIdTable fileIdTable = null) {
    assert(err.stack.length > 0);
    if (auto fileIdTable = fileIdTable) {
        for (loc in err.stack[0 .. $ - 1])
            print(loc.repr(fileIdTable) ~ ":");
    } else {
        for (loc in err.stack[0 .. $ - 1])
            print(loc.toString ~ ":");
    }
    err.stack[$ - 1].printAtErrorLoc(fileIdTable, err.msg);
}

void printAtErrorLoc(LocRange locRange, nullable FileIdTable fileIdTable, string message) {
    mut string filename = "";
    if (auto fileIdTable = fileIdTable)
        filename = fileIdTable.toFileName(locRange.fileId);
    if (filename.empty || !exists(filename)) {
        print("$(filename):$(locRange.from.row + 1):$(locRange.from.column + 1): $message");
        return;
    }
    auto text = read(filename);
    print("$(filename):$(locRange.from.row + 1):");
    auto line = text.getLine(locRange.from.row);
    print(line);
    if (locRange.(from.row != to.row || from.column == to.column)) {
        mut string spacer;
        for (i in 0 .. locRange.from.column) spacer ~= " ";
        print("$spacer^ $message");
    } else {
        mut string wiggle;
        for (i in 0 .. locRange.from.column) wiggle ~= " ";
        for (i in locRange.from.column .. locRange.to.column) wiggle ~= "~";
        print("$wiggle $message");
    }
}

string getLine(string text, int line) {
    return text.split("\n")[line];
}
