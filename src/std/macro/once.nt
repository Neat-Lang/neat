module std.macro.once;

macro import std.macro.quasiquoting;

import neat.runtime : assert;
import package(compiler).neat.base;
import package(compiler).neat.hash;
import package(compiler).neat.util;
import package(compiler).neat.types;

class ASTOnceExpression : ASTSymbol
{
    ASTSymbol target;

    this(this.target, this.locRange) { }

    override (Symbol | fail Error) compile(Context context)
    {
        auto varName = "once__" ~ this.locRange.repr.cleanup;
        auto target = this.target.compile(context)?.beExpressionImplCall(context, target.locRange)?;
        version (firstpassmacro) {
            return target;
        } else {
            auto initStmt = new InitGlobalVarOnce(varName, target);
            auto globVar = new ExternCVariable(target.type, varName, threadlocal=true);
            return context.compiler.statementExpression(initStmt, globVar);
        }
    }
}

class InitGlobalVarOnce : Statement
{
    string name;

    Expression value;

    this(this.name, this.value) {}

    override void emit(Generator output) {
        version (firstpassmacro) {
            assert(false);
        } else {
            auto backendType = this.value.type.emit(output.platform);
            auto globalPtr = output.fun.globalVar(this.name, backendType, define=true, threadlocal=true);
            auto global = output.fun.load(backendType, globalPtr);
            auto zero = output.fun.zeroLiteral(backendType);
            auto eq = output.fun.binop("==", backendType, global, zero);

            string label = output.fun.getLabel;
            output.fun.testBranch(eq, label ~ "_then", label ~ "_fin");

            output.fun.setLabel(label ~ "_then");
            auto value = this.value.emit(output);
            output.fun.store(backendType, globalPtr, value);

            output.fun.branch(label ~ "_fin");
            output.fun.setLabel(label ~ "_fin");
        }
    }

    override void hash(Hash hash) {
        hash.adds("init global");
        hash.adds(name);
        value.hash(hash);
    }

    override string repr() { return "InitGlobalVar($name)"; }
}

bool isAlnum(int ch) {
    return isAlpha(ch) || isDigit(ch);
}

bool isAlpha(int ch) {
    return ch >= cast(int) "a"[0] && ch <= cast(int) "z"[0]
        || ch >= "A"[0] && ch <= cast(int) "Z"[0];
}

bool isDigit(int ch) {
    return ch >= cast(int) "0"[0] && ch <= cast(int) "9"[0];
}

string cleanup(string s) {
    mut string ret;
    for (ch in s)
        if (ch.isAlnum) ret ~= ch;
        else ret ~= "_";
    return ret;
}

class OnceMacro : Macro
{
    this() { }

    override void apply(MacroArgs args) {
        if (auto args = args.instanceOf(ParseExpressionBaseArgs)) {
            args.symbol = this.parse(args.parser, args.lexicalContext);
        }
    }

    (nullable ASTSymbol | fail Error) parse(Parser parser, LexicalContext lexicalContext)
    {
        parser.begin;
        auto from = parser.from?;
        if (!parser.acceptIdentifier("once")?) {
            parser.revert;
            return null;
        }
        parser.commit;
        auto locRange = parser.to(from);
        if (auto expression = lexicalContext.compiler.parseExpression(parser, lexicalContext)?) {
            return new ASTOnceExpression(expression, locRange);
        } else {
            return parser.fail("expression expected");
        }
    }
}

void addOnceMacro(MacroState macroState)
{
    macroState.addMacro(new OnceMacro);
}

macro(addOnceMacro);
