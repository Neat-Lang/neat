module backend.c;

import backend.base;
import helpers;
import polyhash;
macro import package(compiler).std.macro.listcomprehension;

class CBackend : Backend {
    this() { }
    override CBackendModule createModule(
        Platform platform, string targetFile, BackendLocation loc, bool forMacro)
    {
        return new CBackendModule(platform, forMacro);
    }
    override void hash(Hash hash) {
        hash.adds("gcc");
    }
    override void linkSharedLib(string soname, string flags, bool verbose, string[] objFiles) {
        string objStr = [join " " ~ a for a in objFiles];
        string basecmd = getEnv("CC", "gcc") ~ " -fpic -fno-strict-aliasing "
            ~ flags;
        string cmd = "$basecmd -shared -g $objStr -o $soname";
        if (verbose) {
            print("\$ $cmd");
        }
        neat_runtime_system(cmd);
    }
}

private string getEnv(string key, string default_ = "") {
    import package(compiler).std.process : getEnv;
    auto ret = getEnv(key);
    if (!ret.empty) return ret;
    return default_;
}

struct Global {
    string name;
    string type;
}

struct Globals {
    Global[string] globals;
    void add(Global global) {
        this.globals[global.name] = global;
    }
    bool defined(string name) {
        return this.globals.has(name);
    }
}

extern(C) void neat_runtime_file_write(string file, string content);
extern(C) void neat_runtime_system(string command);
extern(C) void neat_runtime_dlcall(string soname, string name, void* arg);
extern(C) bool neat_runtime_symbol_defined_in_main(string symbol);

class CBackendModule : BackendModule {
    LineWriter output;
    Platform platform;

    int literalId;
    Globals globals;

    bool forMacro;

    this(Platform platform, this.forMacro) {
        this.output = new LineWriter;
        this.platform = platform;
        this.output.print("#include <stdlib.h>");
        this.output.print("#include <string.h>");
        this.output.print("typedef struct { } VOIDTYPE;");
        defineCIntrinsics(this, platform);
    }

    override bool declared(string name) {
        return this.globals.defined(name);
    }

    override void declare(string name, BackendType ret, BackendType[] args, bool variadic)
    {
        if (this.declared(name)) return;
        if (name == "memcpy" || name == "malloc" || name == "calloc"
            || name == "strlen" || name == "realpath" || name == "getenv"
            || name == "atoi" || name == "atof" || name == "atoll" || name == "memcmp"
            || name == "memset"
        ) return; // in header, don't redeclare - may conflict
        mut string argstr = "(";
        auto realArgs = [a for a in args where !a.instanceOf(BackendVoidType)];
        for (int i, arg in realArgs) {
            if (i) argstr ~= ", ";
            argstr ~= typeFmt(this, arg) ~ " arg" ~ itoa(i);
        }
        if (variadic) {
            if (realArgs.length) argstr ~= ", ";
            argstr ~= "...";
        }
        argstr ~= ")";
        mut string retstr;
        if (ret.instanceOf(BackendVoidType)) {
            retstr = "void";
        } else {
            retstr = typeFmt(this, ret);
        }
        this.output.print(retstr ~ " " ~ name ~ argstr ~ ";");
        auto fpType = new BackendFunctionPointerType(ret, args, variadic, this.platform);
        this.globals.add(Global(name, typeFmt(this, fpType)));
    }

    void defineVar(string name, BackendType type, bool threadlocal)
    {
        if (this.declared(name)) return;
        string modifier = "__thread " if threadlocal else "";
        this.output.print(modifier ~ typeFmt(this, type) ~ " $name;");
        this.globals.add(Global(name, typeFmt(this, type)));
    }

    void declareVar(string name, BackendType type, bool threadlocal)
    {
        if (this.declared(name)) return;
        string modifier = "__thread " if threadlocal else "";
        this.output.print("extern $modifier" ~ typeFmt(this, type) ~ " $name;");
        this.globals.add(Global(name, typeFmt(this, type)));
    }

    override BackendFunction define(
        string name, string decoration, BackendType ret, BackendType[] args, BackendLocation loc)
    {
        auto fpType = new BackendFunctionPointerType(ret, args, variadic=false, this.platform);
        this.globals.add(Global(name, typeFmt(this, fpType)));
        return new CBackendFunction(this, name, ret, args);
    }
    override void declareSymbolList(string name, size_t length)
    {
        string globalDecl = "void *" ~ name ~ "[" ~ ltoa(length) ~ "]";
        this.output.print("extern " ~ globalDecl ~ ";");
        this.globals.add(Global(name, ""));
    }
    override void defineSymbolList(string name, (string | size_t)[] symbols)
    {
        if (forMacro && neat_runtime_symbol_defined_in_main(name))
            return;

        mut string symbolList;
        for (i, symbol in symbols) {
            if (i) symbolList ~= ", ";
            symbolList ~= "(void*) " ~ symbol.case(string s: s, size_t l: ltoa(l));
        }
        string globalDecl = "void *" ~ name ~ "[" ~ ltoa(symbols.length) ~ "]";
        this.output.print(globalDecl ~ " = { " ~ symbolList ~ "};");
        this.globals.add(Global(name, ""));
    }
    string nextLiteral() {
        string res = "@str" ~ itoa(this.literalId);
        this.literalId = this.literalId + 1;
        return res;
    }
}

string typeMangle(BackendType type) {
    if (type.instanceOf(BackendLongType)) return "l";
    if (type.instanceOf(BackendIntType)) return "i";
    if (type.instanceOf(BackendShortType)) return "s";
    if (type.instanceOf(BackendCharType)) return "c";
    if (type.instanceOf(BackendFloatType)) return "f";
    if (type.instanceOf(BackendDoubleType)) return "d";
    if (type.instanceOf(BackendVoidType)) return "v";
    if (auto backendSpacerType = type.instanceOf(BackendSpacerType)) {
        return "U" ~ ltoa(backendSpacerType.size) ~ "a" ~ ltoa(backendSpacerType.alignment);
    }
    if (auto backendPointerType = type.instanceOf(BackendPointerType)) {
        return "P" ~ typeMangle(backendPointerType.target);
    }
    if (auto backendStructType = type.instanceOf(BackendStructType)) {
        mut string mangle = "S" ~ ltoa(backendStructType.members.length);
        for (i, member in backendStructType.members) {
            mangle ~= typeMangle(member);
        }
        return mangle;
    }
    if (auto backendFpType = type.instanceOf(BackendFunctionPointerType)) {
        mut string res;
        if (backendFpType.variadic) res ~= "Fv";
        else res ~= "F";
        res ~= typeMangle(backendFpType.ret);
        res ~= ltoa(backendFpType.params.length);
        for (i, param in backendFpType.params) {
            res ~= typeMangle(param);
        }
        return res;
    }
    if (auto backendSAtype = type.instanceOf(BackendStaticArrayType)) {
        return "A" ~ typeMangle(backendSAtype.element) ~ "l" ~ itoa(backendSAtype.length);
    }
    assert(false);
}

string typeFmt(CBackendModule mod, BackendType type) {
    return typeFmtInternal(mod, type, false);
}

string typeFmtInternal(CBackendModule mod, BackendType type, bool indirect) {
    if (type.instanceOf(BackendLongType)) return "long long int";
    if (type.instanceOf(BackendIntType)) return "int";
    if (type.instanceOf(BackendShortType)) return "short";
    if (type.instanceOf(BackendCharType)) return "char";
    if (type.instanceOf(BackendFloatType)) return "float";
    if (type.instanceOf(BackendDoubleType)) return "double";
    if (type.instanceOf(BackendVoidType)) {
        if (indirect) return "void";
        else return "VOIDTYPE";
    }
    if (auto backendSpacerType = type.instanceOf(BackendSpacerType)) {
        // Naked arrays are awkward in C, so make sure it's bundled in a struct.
        string mangle = typeMangle(type);
        string typestr = "arr_" ~ mangle;
        if (mod.declared(typestr)) return typestr;
        string def = "typedef struct { char value[" ~ ltoa(backendSpacerType.size) ~ "]; } " ~ typestr ~ " " ~
            "__attribute__ ((aligned (" ~ itoa(backendSpacerType.alignment) ~ ")));";
        mod.output.print(def);
        mod.globals.add(Global(typestr, ""));
        return typestr;
    }
    if (auto backendPointerType = type.instanceOf(BackendPointerType)) {
        return typeFmtInternal(mod, backendPointerType.target, true) ~ "*";
    }
    if (auto backendStructType = type.instanceOf(BackendStructType)) {
        string mangle = typeMangle(type);
        string typestr = "str_" ~ mangle;
        if (mod.declared(typestr)) return typestr;
        mut string def = "typedef struct { ";
        for (int i, member in backendStructType.members) {
            if (member.size > 0) {
                def ~= typeFmtInternal(mod, member, false) ~ " _" ~ itoa(i) ~ ";";
            } else {
                string fieldmangle = typeMangle(member);
                def ~= "/* $fieldmangle _$(i); */";
            }
        }
        def ~= "} " ~ typestr ~ ";";
        mod.output.print(def);
        mod.globals.add(Global(typestr, ""));
        return typestr;
    }
    if (auto backendFpType = type.instanceOf(BackendFunctionPointerType)) {
        string mangle = typeMangle(type);
        string typestr = "fp_" ~ mangle;
        if (mod.declared(typestr)) return typestr;
        mut string def = "typedef ";
        def ~= typeFmtInternal(mod, backendFpType.ret, true) ~ "(*" ~ typestr ~ ")(";
        mut bool comma = false;
        for (i, param in backendFpType.params) {
            if (param.size > 0) {
                if (comma) def ~= ", ";
                comma = true;
                def ~= typeFmtInternal(mod, param, false);
            }
        }
        if (backendFpType.variadic) {
            if (comma) def ~= ", ";
            comma = true;
            def ~= "...";
        }
        def ~= ");";
        mod.output.print(def);
        mod.globals.add(Global(typestr, ""));
        return typestr;
    }
    if (auto backendSAtype = type.instanceOf(BackendStaticArrayType)) {
        return typeFmtInternal(mod, backendSAtype.element, true) ~ "[" ~ itoa(backendSAtype.length) ~ "]";
    }
    assert(false);
}

alias Instr = (
      :arg, int index
    | :shortLiteral, int value
    | :byteLiteral, int value
    | :intLiteral, long value
    | :longLiteral, long value
    | :wordLiteral, Platform platform, long value
    | :floatLiteral, float value
    | :doubleLiteral, double value
    | :stringLiteral, string text
    | :zeroLiteral, BackendType type
    | :unreachable
    | :structLiteral, BackendStructType struct_, int[] regs
    | :symbolList, string name
    | :globalVar, string name, BackendType type, bool define, bool threadlocal
    | :binOp, string op, BackendType type, int left, int right
    | :bitCast, int from, BackendType to
    | :zeroExtend, int value, BackendType to
    | :signExtend, int value, BackendType to
    | :trunc, int value, BackendType to
    | :convert, int from, BackendType to
    | :callInstr, BackendType retType, string name, int[] args
    | :getFuncPtr, BackendType type, string name
    | :callFuncPtr, BackendType type, int regId, int[] args
    | :load, BackendType type, int regId
    | :staticAlloca, BackendType type
    | :field, BackendType type, int regId, int index
    | :fieldOffset, BackendType type, int regId, size_t index
    | :ptrOffset, BackendType type, int ptrReg, int offsetReg
    | :store, BackendType type, int targetReg, int valueReg
    | :return_, int regId
    | :setLabel, string label
    | :branch, string label
    | :testBranch, int regId, string thenLabel, string elseLabel
    | :switch_, int regId, (int value, string label, bool unlikely)[] targets, string defaultLabel
    | :setLocation, BackendLocation loc
);

/**
 * SSA results can be held back for a future instruction to compose.
 * However, whenever a global state change point is reached,
 * such as a store, or function call, all held SSA
 * instructions must be flushed.
 */

// flow for 1 use:
// pending -> held -> done
// pending -> held -> persisted
// flow for multiple uses:
// pending -> persisted
enum SSAMode
{
    pending,
    // reg$reg
    persisted,
    // (int) 5
    held,
    done
}

struct Value {
    string type;
    string value;
    bool exactType;

    // empty type and empty value: void, never emitted
    bool fake() {
        return type == "" && value == "";
    }

    static Value none() {
        return Value(type="", value="", exactType=true);
    }

    string repr() {
        return "Value(type=$type, value=$value, exactType=$(cast(int) exactType))";
    }
}

struct SSAInstr {
    SSAMode mode;
    int reg; // -1 for terminators
    // inc for every instr that uses us.
    // one-use instrs can be inlined.
    int uses;
    Value heldValue;
    Instr instr;
}

class CBackendFunction : BackendFunction {
    CBackendModule mod;
    BackendType ret_;
    BackendType[] args;

    LineWriter output;
    int blockId;

    SSAInstr mut[] instrs;

    string[] labels;

    this(this.mod, this.name, this.ret_, this.args)
    {
        this.output = new LineWriter;
    }

    override string toString() => "CBackendFunction($(this.name))";

    void print(string msg) {
        this.output.append("  ");
        this.output.append(msg);
        this.output.endl;
    }
    override string getLabel() {
        return "Label" ~ itoa(this.blockId);
    }
    override string getCurrentLabel() {
        return this.labels[$ - 1];
    }
    override void setLabel(string label) {
        if (!labels.empty && labels[$ - 1] == label) return;
        if ([any a == label for a in labels]) {
            .print("duplicate label $label");
            assert(false);
        }
        labels ~= label;
        addInstr((:setLabel, label));
    }
    override void setLocation(BackendLocation loc) {
        addInstr((:setLocation, loc));
    }
    int addInstr(Instr instr) {
        int reg = cast(int) this.instrs.length;
        this.instrs ~= SSAInstr(SSAMode.pending, reg, 0, Value.none, instr);
        return reg;
    }
    void addBlockEnderInstr(Instr instr) {
        this.instrs ~= SSAInstr(SSAMode.pending, -1, 0, Value.none, instr);
    }
    void useReg(int reg) {
        this.instrs[reg].uses += 1;
    }
    override int arg(int index) {
        return addInstr((:arg, index));
    }
    override int intLiteral(long value) {
        return addInstr((:intLiteral, value));
    }
    override int shortLiteral(int value) {
        return addInstr((:shortLiteral, value));
    }
    override int byteLiteral(int value) {
        return addInstr((:byteLiteral, value));
    }
    override int longLiteral(long value) {
        return addInstr((:longLiteral, value));
    }
    override int floatLiteral(float value) {
        return addInstr((:floatLiteral, value));
    }
    override int doubleLiteral(double value) {
        return addInstr((:doubleLiteral, value));
    }
    override int wordLiteral(Platform platform, long value) {
        return addInstr((:wordLiteral, platform, value));
    }
    override int stringLiteral(string text) {
        return addInstr((:stringLiteral, text));
    }
    override int voidLiteral() {
        return zeroLiteral(new BackendVoidType);
    }
    override void unreachable() {
        addBlockEnderInstr(:unreachable);
        // TODO
        // this.blockId++;
        this.blockId += 1;
    }
    override int zeroLiteral(BackendType type) {
        return addInstr((:zeroLiteral, type));
    }
    override int structLiteral(BackendType struct_, int[] regs) {
        [useReg(reg) for reg in regs];
        // FIXME structLiteral should take BackendStructType
        if (auto struct_ = struct_.instanceOf(BackendStructType))
            return addInstr((:structLiteral, struct_, regs));
        assert(false);
    }
    override int symbolList(string name) {
        return addInstr((:symbolList, name));
    }
    override int globalVar(string name, BackendType type, bool define, bool threadlocal) {
        return addInstr((:globalVar, name, type, define, threadlocal));
    }
    override int binop(string op, BackendType type, int left, int right) {
        useReg(left); useReg(right);
        return addInstr((:binOp, op, type, left, right));
    }
    override int bitcast(int from, BackendType to) {
        useReg(from);
        return addInstr((:bitCast, from, to));
    }
    override int zeroExtend(int value, BackendType to) {
        useReg(value);
        return addInstr((:zeroExtend, value, to));
    }
    override int signExtend(int value, BackendType to) {
        useReg(value);
        return addInstr((:signExtend, value, to));
    }
    override int trunc(int value, BackendType to) {
        useReg(value);
        return addInstr((:trunc, value, to));
    }
    override int convert(int from, BackendType to) {
        useReg(from);
        return addInstr((:convert, from, to));
    }
    override int call(BackendType retType, string name, int[] args) {
        [useReg(arg) for arg in args];
        return addInstr((:callInstr, retType, name, args));
    }
    override int getFuncPtr(BackendType type, string name) {
        return addInstr((:getFuncPtr, type, name));
    }
    override int callFuncPtr(BackendType type, int callReg, int[] args) {
        useReg(callReg);
        [useReg(arg) for arg in args];
        return addInstr((:callFuncPtr, type, callReg, args));
    }
    override int load(BackendType backendType, int source) {
        useReg(source);
        return addInstr((:load, backendType, source));
    }
    override int staticAlloca(BackendType backendType) {
        return addInstr((:staticAlloca, backendType));
    }
    override int field(BackendType backendType, int source, int index) {
        useReg(source);
        return addInstr((:field, backendType, source, index));
    }
    override int fieldOffset(BackendType backendType, int source, size_t index) {
        useReg(source);
        return addInstr((:fieldOffset, backendType, source, index));
    }
    override int ptrOffset(BackendType backendType, int ptrReg, int offsetReg) {
        useReg(ptrReg);
        useReg(offsetReg);
        return addInstr((:ptrOffset, backendType, ptrReg, offsetReg));
    }
    override void store(BackendType backendType, int targetReg, int valueReg) {
        useReg(targetReg);
        useReg(valueReg);
        addInstr((:store, backendType, targetReg, valueReg));
    }
    override void ret(int reg) {
        useReg(reg);
        addBlockEnderInstr((:return_, reg));
    }
    override void branch(string label) {
        addBlockEnderInstr((:branch, label));
        this.blockId = this.blockId + 1;
    }
    override void testBranch(int reg, string thenLabel, string elseLabel) {
        useReg(reg);
        addBlockEnderInstr((:testBranch, reg, thenLabel, elseLabel));
        this.blockId = this.blockId + 1;
    }
    override void switch_(int reg, (int value, string label, bool unlikely)[] targets, string defaultLabel) {
        useReg(reg);
        addBlockEnderInstr((:switch_, reg, targets, defaultLabel));
        this.blockId = this.blockId + 1;
    }
    void flush() {
        string valueFormat(Value value, bool parens) {
            import package(compiler).std.string : endsWith;

            if (value.type == "") return value.value;
            if (value.exactType) return value.value;
            if (value.value == "0" && value.type.endsWith("*"))
                return "NULL";
            string castExpr = "(" ~ value.type ~ ") " ~ value.value;
            if (parens) return "(" ~ castExpr ~ ")";
            else return castExpr;
        }
        string reg2(int reg, string type) {
            auto ssaInstr = this.instrs[reg];
            if (ssaInstr.mode == SSAMode.held || ssaInstr.mode == SSAMode.persisted) {
                if (ssaInstr.mode == SSAMode.held) this.instrs[reg].mode = SSAMode.done;

                mut auto value = ssaInstr.heldValue;
                if (type != value.type) value = Value(type, value.value, exactType=false);

                return valueFormat(value, true);
            }
            assert(false);
        }
        string reg(int reg) {
            return reg2(reg, this.instrs[reg].heldValue.type);
        }
        string unsignedReg(int target) {
            if (this.instrs[target].heldValue.type == "char")
                return "(unsigned char) " ~ reg(target);
            else
                return "(unsigned) " ~ reg(target);
        }
        Value regExt(int reg) {
            auto ssaInstr = this.instrs[reg];
            if (ssaInstr.mode == SSAMode.held) {
                this.instrs[reg].mode = SSAMode.done;
                return ssaInstr.heldValue;
            }
            assert(ssaInstr.mode == SSAMode.persisted);
            return ssaInstr.heldValue;
        }
        Value dispatch(int regId) {
            auto ssaInstr = this.instrs[regId];
            mut Value ret;
            void flushRegs() {
                flushRegsImpl(regId);
            }
            ssaInstr.instr.case {
                (:arg, int index): {
                    string typestr = typeFmt(mod, this.args[index]);
                    ret = Value(typestr, "arg" ~ itoa(index), exactType=false);
                }
                (:intLiteral, long value): {
                    ret = Value("int", ltoa(value), exactType=true);
                }
                (:shortLiteral, int value): {
                    ret = Value("short", itoa(value), exactType=true);
                }
                (:byteLiteral, int value): {
                    ret = Value("char", itoa(value), exactType=true);
                }
                (:longLiteral, long value): {
                    ret = Value("long long int", ltoa(value), exactType=true);
                }
                (:floatLiteral, float value): {
                    ret = Value("float", ftoa(value), exactType=true);
                }
                (:doubleLiteral, double value): {
                    ret = Value("double", ftoa(value), exactType=true);
                }
                (:wordLiteral, Platform platform, long value): {
                    ret = Value("int", ltoa(value), exactType=true);
                }
                (:stringLiteral, string text): {
                    mut string escapedText;
                    // TODO ord()
                    for (i in 0 .. text.length) {
                        if (text[i .. i + 1] == "\"") escapedText ~= "\\\"";
                        else if (text[i .. i + 1] == "\\") escapedText ~= "\\\\";
                        else if (text[i .. i + 1] == "\r") escapedText ~= "\\r";
                        else if (text[i .. i + 1] == "\n") escapedText ~= "\\n";
                        else if (text[i .. i + 1] == "\0") escapedText ~= "\\0";
                        else escapedText ~= text[i .. i + 1];
                    }
                    ret = Value("char*", "\"" ~ escapedText ~ "\"", exactType=true);
                }
                (:zeroLiteral, BackendType type): {
                    if (type.size > 0) {
                        string typestr = typeFmt(mod, type);
                        mut string init = "0";
                        if (type.instanceOf(BackendStructType) || type.instanceOf(BackendSpacerType))
                            init = "{0}";
                        ret = Value(typestr, init, exactType=false);
                    }
                    else ret = Value.none;
                }
                (:structLiteral, BackendStructType struct_, int[] regs): {
                    string typestr = typeFmt(mod, struct_);

                    mut string res;
                    for (int i, member in struct_.members) {
                        if (member.size == 0)
                            continue;
                        if (!res.empty) res ~= ", ";
                        res ~= reg(regs[i]);
                    }
                    ret = Value(typestr, "{" ~ res ~ "}", exactType=false);
                }
                (:symbolList, string name): {
                    ret = Value("void*", name, exactType=true);
                }
                (:globalVar, string name, BackendType type, bool define, bool threadlocal): {
                    if (define) mod.defineVar(name, type, threadlocal);
                    else mod.declareVar(name, type, threadlocal);
                    ret = Value(typeFmt(mod, new BackendPointerType(type, mod.platform)), "&$name", exactType=true);
                }
                (:binOp, string op, BackendType type, int left, int right): {
                    mut string typestr = typeFmt(mod, type);
                    if (isBooleanOp(op)) {
                        typestr = "int";
                    }
                    if (op == ">>>") {
                        ret = Value(typestr, "(" ~ unsignedReg(left) ~ " >> " ~ reg(right) ~ ")", exactType=true);
                    } else if (op == "%") {
                        auto l = reg(left), r = reg(right);
                        ret = Value(typestr, "((($l % $r) + $r) % $r)", exactType=true);
                    } else {
                        ret = Value(typestr, "(" ~ reg(left) ~ " " ~ op ~ " " ~ reg(right) ~ ")", exactType=true);
                    }
                }
                (:bitCast, int from, BackendType to): {
                    auto from = regExt(from);
                    if (from.fake) ret = Value.none;
                    else {
                        string typestr = typeFmt(mod, to);

                        ret = Value(typestr, from.value, exactType=false);
                    }
                }
                (:zeroExtend, int value, BackendType to): {
                    string type = typeFmt(mod, to);
                    ret = Value(type, "($type) $(unsignedReg(value))", exactType=true);
                }
                (:signExtend, int value, BackendType to): {
                    // TODO revisit when we have unsigned types
                    string type = typeFmt(mod, to);
                    ret = Value(type, "($type) $(reg(value))", exactType=true);
                }
                (:trunc, int value, BackendType to): {
                    string type = typeFmt(mod, to);
                    ret = Value(type, "($type) $(reg(value))", exactType=true);
                }
                (:convert, int from, BackendType to): {
                    auto from = regExt(from);
                    string toStr = typeFmt(mod, to);
                    if (from.type == "int")
                        // impl conv
                        ret = Value(toStr, from.value, exactType=true);
                    else
                        // cast conv
                        ret = Value(toStr, from.value, exactType=false);
                }
                (:callInstr, BackendType retType, string name, int[] args): {
                    string argstr = [
                        join with ", " valueFormat(value, parens=false)
                        for value in [regExt(a) for a in args]
                        where !value.fake
                    ];
                    if (retType.size > 0) {
                        string type = typeFmt(mod, retType);
                        ret = Value(type, name ~ "(" ~ argstr ~ ")", exactType=true);
                    } else {
                        ret = Value("", name ~ "(" ~ argstr ~ ")", exactType=true);
                    }
                    flushRegs;
                }
                (:getFuncPtr, BackendType type, string name): {
                    ret = Value(typeFmt(mod, type), name, exactType=true);
                }
                (:callFuncPtr, BackendType type, int regId, int[] args): {
                    auto backendFpType = type.instanceOf(BackendFunctionPointerType);
                    assert(!!backendFpType);
                    auto retType = backendFpType.ret;
                    string argstr = [
                        join with ", " valueFormat(value, parens=false)
                        for value in [regExt(a) for a in args]
                        where !value.fake
                    ];
                    string target = reg(regId);
                    if (retType.size > 0) {
                        string typestr = typeFmt(mod, retType);
                        ret = Value(typestr, "(" ~ target ~ ")(" ~ argstr ~ ")", exactType=true);
                    } else {
                        ret = Value("", "(" ~ target ~ ")(" ~ argstr ~ ")", exactType=true);
                    }
                    flushRegs;
                }
                (:load, BackendType type, int regId): {
                    import package(compiler).std.string : startsWith;
                    if (type.size > 0) {
                        string type = typeFmt(mod, type);
                        string value = reg(regId);
                        if (value.startsWith("&")) {
                            ret = Value(type, value[1 .. $], exactType=true);
                        } else {
                            ret = Value(type, "*" ~ value, exactType=true);
                        }
                    } else ret = Value.none;
                }
                (:staticAlloca, BackendType type): {
                    flushRegs; // TODO is this right?
                    string typefmt = typeFmt(mod, type);
                    if (type.size > 0) {
                        mut string init = "0";
                        if (type.instanceOf(BackendStructType) || type.instanceOf(BackendSpacerType))
                            init = "{0}";
                        this.print(typefmt ~ " reg" ~ itoa(regId) ~ "_frame = " ~ init ~ ";");
                        ret = Value(typefmt ~ "*", "&reg" ~ itoa(regId) ~ "_frame", exactType=true);
                    } else {
                        ret = Value(typefmt ~ "*", "NULL", exactType=false);
                    }
                }
                (:field, BackendType type, int regId, int index): {
                    auto backendStructType = type.instanceOf(BackendStructType);
                    assert(!!backendStructType);

                    if (backendStructType.members[index].size > 0) {
                        string typefmt = typeFmt(mod, backendStructType.members[index]);
                        ret = Value(typefmt, "(" ~ reg(regId) ~ ")._" ~ ltoa(index), exactType=true);
                    } else {
                        ret = Value.none;
                    }
                }
                (:fieldOffset, BackendType type, int regId, size_t index): {
                    auto backendStructType = type.instanceOf(BackendStructType);
                    assert(!!backendStructType);

                    if (backendStructType.members[index].size > 0) {
                        string typefmt = typeFmt(mod, backendStructType) ~ "*";
                        string memberfmt = typeFmt(mod, backendStructType.members[index]);
                        ret = Value(memberfmt ~ "*", "&(" ~ reg2(regId, typefmt) ~ ")->_" ~ ltoa(index), exactType=true);
                    } else {
                        // TODO figure out precisely what the backend should do in this case!
                        // ret = Value.none;
                        ret = Value("void*", "0", exactType=false);
                    }
                }
                (:ptrOffset, BackendType type, int ptrReg, int offsetReg): {
                    string typefmt = typeFmt(mod, type) ~ "*";
                    ret = Value(
                        typefmt,
                        "&(" ~ reg2(ptrReg, typefmt) ~ ")"
                            ~ "[" ~ reg(offsetReg) ~ "]",
                        exactType=true);
                }
                (:store, BackendType type, int targetReg, int valueReg): {
                    if (type.size > 0) {
                        auto targetRegExt = regExt(targetReg);
                        auto valueRegStr = reg(valueReg);
                        if (valueRegStr == "") {
                            .print("storing invalid register $(valueReg) of $(type.repr) in $targetReg");
                            mut int* i; *i = *i;
                        }
                        flushRegs;
                        string typeStr = typeFmt(mod, type);
                        if (targetRegExt.type == typeStr) {
                            this.print("*" ~ targetRegExt.value ~ " = " ~ valueRegStr ~ ";");
                        } else {
                            this.print("*(" ~ typeStr ~ "*) " ~ targetRegExt.value
                                ~ " = " ~ valueRegStr ~ ";");
                        }
                    }
                    ret = Value.none;
                }
                (:return_, int regId): {
                    if (this.ret_.size > 0) {
                        auto val = reg(regId);
                        if (val == "") {
                            .print("Backend error: $(this.name): nonzero return with fake register.");
                            auto ssaInstr = this.instrs[regId];
                            .print("reg $regId, value $(ssaInstr.heldValue.repr) from $(ssaInstr.instr.repr)");
                            assert(false);
                        }
                        this.print("return " ~ val ~ ";");
                        flushRegs;
                    } else {
                        flushRegs;
                        this.print("return;");
                    }
                    ret = Value.none;
                }
                (:setLabel, string label): {
                    flushRegs;
                    this.print(label ~ ":;");
                    ret = Value.none;
                }
                (:branch, string label): {
                    flushRegs;
                    this.print("goto " ~ label ~ ";");
                    ret = Value.none;
                }
                (:unreachable): {
                    this.print("/* noreturn */");
                    flushRegs;
                    ret = Value.none;
                }
                (:testBranch, int regId, string thenLabel, string elseLabel):
                    auto testReg = reg(regId);
                    flushRegs;
                    this.print("if (" ~ testReg ~ ") "
                        ~ "goto " ~ thenLabel ~ "; "
                        ~ "else goto " ~ elseLabel ~ ";");
                    ret = Value.none;
                (:switch_, int regId, (int value, string label, bool unlikely)[] targets, string defaultLabel):
                    auto testReg = reg(regId);
                    flushRegs;
                    this.print("switch ($testReg) {");
                    for (target in targets) {
                        this.print("  case $(target.value): goto $(target.label);");
                    }
                    this.print("  default: goto $(defaultLabel);");
                    this.print("}");
                    ret = Value.none;
                (:setLocation, BackendLocation loc):
                    this.print("#line $(loc.line+1) \"$(loc.file)\"");
            }
            return ret;
        }
        void persistReg(int regId) {
            mut Value value;
            auto ssaInstr = this.instrs[regId];
            if (ssaInstr.mode == SSAMode.held) {
                value = ssaInstr.heldValue;
            } else {
                assert(ssaInstr.mode == SSAMode.pending);
                value = dispatch(regId);
            }
            if (value.type == "") {
                if (value.value != "")
                    this.print(value.value ~ ";");
                /*else
                    this.print("// reg$regId = nothing ($(ssaInstr.instr.repr))");*/
                this.instrs[regId].mode = SSAMode.persisted;
                this.instrs[regId].heldValue = Value.none;
                return;
            } else {
                import package(compiler).std.string : startsWith;

                mut string init; init = value.value;
                if (!init.startsWith("{")) init = valueFormat(value, false);
                this.print(value.type ~ " reg" ~ itoa(regId) ~ " = " ~ init ~ ";");
            }
            this.instrs[regId].mode = SSAMode.persisted;
            this.instrs[regId].heldValue = Value(value.type, "reg" ~ itoa(regId), exactType=true);
        }
        void flushRegsImpl(size_t limit) {
            for (regId in 0 .. limit) {
                auto ssaInstr = this.instrs[regId];
                if (ssaInstr.mode == SSAMode.held) {
                    persistReg(cast(int) regId);
                }
            }
        }
        for (int regId, ssaInstr in this.instrs) {
            assert(ssaInstr.mode == SSAMode.pending);
            if (ssaInstr.uses == 1) {
                auto value = dispatch(regId);
                this.instrs[regId].mode = SSAMode.held;
                this.instrs[regId].heldValue = value;
            } else {
                persistReg(regId);
            }
        }
        flushRegsImpl(this.instrs.length);
    }
    override void done() {
        flush;
        mut string argstr = "(";
        this.print("/*unreachable*/");
        for (int i, arg in this.args) {
            if (i) argstr ~= ", ";
            argstr ~= typeFmt(mod, arg) ~ " arg" ~ itoa(i);
        }
        argstr ~= ")";
        mut string retstr;
        if (this.ret_.size > 0) {
            retstr = typeFmt(mod, this.ret_);
        } else {
            retstr = "void";
        }
        this.mod.output.print(retstr ~ " " ~ this.name ~ argstr ~ "{");
        auto funtext = this.output.text;
        this.mod.output.print(funtext);
        this.mod.output.print("}");
    }
}

class LineAppender
{
    char mut[] buffer;
    size_t used;
    this() {
        this.buffer = new char mut[](128);
    }
    void appends(string msg) {
        this.expand(this.used + msg.length);
        memcpy(&this.buffer[this.used], msg.ptr, msg.length);
        this.used = this.used + msg.length;
    }
    void appendi(int i) {
        this.appends(itoa(i)); // TODO
    }
    void expand(size_t newLength) {
        while (newLength > this.buffer.length)
        {
            auto newBuf = new char mut[](this.buffer.length * 2);
            for (i in 0 .. this.used)
                newBuf[i] = this.buffer[i];
            this.buffer = newBuf;
        }
    }
    string flush() {
        string result = new string(this.used);
        memcpy(result.ptr, this.buffer.ptr, this.used);
        this.used = 0;
        return result;
    }
}

class LineWriter
{
    string mut[] lines;
    int length;
    LineAppender line;
    this() {
        this.line = new LineAppender;
    }
    void print(string msg) {
        this.line.appends(msg);
        this.endl;
    }
    void appendsi(string s, int i)
    {
        this.line.appends(s);
        this.line.appendi(i);
    }
    void appendsis(string s1, int i, string s2)
    {
        this.line.appends(s1);
        this.line.appendi(i);
        this.line.appends(s2);
    }
    void append(string a)
    {
        this.line.appends(a);
    }
    void append2s(string a, string b)
    {
        this.line.appends(a);
        this.line.appends(b);
    }
    void append3s(string a, string b, string c)
    {
        this.line.appends(a);
        this.line.appends(b);
        this.line.appends(c);
    }
    void append5s(string a, string b, string c, string d, string e)
    {
        this.line.appends(a);
        this.line.appends(b);
        this.line.appends(c);
        this.line.appends(d);
        this.line.appends(e);
    }
    void append6s(string a, string b, string c, string d, string e, string f)
    {
        this.append5s(a, b, c, d, e);
        this.line.appends(f);
    }
    void endl() {
        this.line.appends("\n");
        this.append_(this.line.flush);
    }
    void append_(string line) {
        if (this.length == this.lines.length) {
            mut size_t newLen = this.lines.length * 2;
            if (newLen == 0) newLen = 1;
            auto newLines = new string mut[](newLen);
            for (i in 0 .. this.length) newLines[i] = this.lines[i];
            this.lines = newLines;
        }
        this.lines[this.length] = line;
        this.length = this.length + 1;
    }
    string text()
    {
        mut size_t sum;
        for (i in 0 .. this.length)
            sum += this.lines[i].length;
        char mut[] res = new char mut[](sum);
        mut size_t offset = 0;
        for (i in 0 .. this.length)
        {
            string line = this.lines[i];
            memcpy(&res[offset], line.ptr, line.length);
            offset += line.length;
        }
        assert(offset == sum);
        return res.freeze;
    }
}

void defineCIntrinsics(CBackendModule mod, Platform platform) {
    BackendType voidp = platform.voidp;
    BackendType sizet = platform.nativeWordType;
    BackendType void_ = new BackendVoidType;
    mod.declare("neat_runtime_alloc", voidp, [sizet], variadic=false);
    mod.declare("neat_runtime_refcount_set", void_, [voidp, sizet], variadic=false);
}

string repr(Instr instr) {
    return instr.case(
        (:arg, int index): "arg($index)",
        (:intLiteral, long value): "intLiteral($value)",
        (:shortLiteral, int value): "shortLiteral($value)",
        (:byteLiteral, int value): "byteLiteral($value)",
        (:longLiteral, long value): "longLiteral($value)",
        (:floatLiteral, float value): "floatLiteral($value)",
        (:doubleLiteral, double value): "doubleLiteral($value)",
        (:wordLiteral, Platform platform, long value): "wordLiteral($value)",
        (:stringLiteral, string text): "stringLiteral($text)",
        (:zeroLiteral, BackendType type): "zeroLiteral($(type.repr))",
        (:unreachable): "unreachable",
        (:structLiteral, BackendStructType struct_, int[] regs): "structLiteral",
        (:symbolList, string name): "symbolList($name)",
        (:globalVar, string name, BackendType type, bool define, bool threadlocal):
            "globalVar($name, $(cast(int) define), $(cast(int) threadlocal))",
        (:binOp, string op, BackendType type, int left, int right): "binOp($op, $left, $right)",
        (:bitCast, int from, BackendType to): "bitCast($from, $(to.repr))",
        (:zeroExtend, int value, BackendType to): "zeroExtend($value, $(to.repr))",
        (:signExtend, int value, BackendType to): "signExtend($value, $(to.repr))",
        (:trunc, int value, BackendType to): "trunc($value, $(to.repr))",
        (:convert, int from, BackendType to): "convert($from, $(to.repr))",
        (:callInstr, BackendType retType, string name, int[] args): "call($name)",
        (:getFuncPtr, BackendType type, string name): "getFuncPtr($(type.repr), $name)",
        (:callFuncPtr, BackendType type, int regId, int[] args): "callFuncPtr($regId)",
        (:load, BackendType type, int regId): "load($(type.repr), $regId)",
        (:staticAlloca, BackendType type): "staticAlloca($(type.repr))",
        (:field, BackendType type, int regId, int index): "field($(type.repr), $regId, $index)",
        (:fieldOffset, BackendType type, int regId, size_t index): "fieldOffset($(type.repr), $regId, $index)",
        (:ptrOffset, BackendType type, int ptrReg, int offsetReg): "ptrOffset($(type.repr), $ptrReg, $offsetReg)",
        (:store, BackendType type, int targetReg, int valueReg): "store($(type.repr), $targetReg, $valueReg)",
        (:return_, int regId): "return($(regId))",
        (:setLabel, string label): "setLabel($label)",
        (:branch, string label): "branch($label)",
        (:testBranch, int regId, string thenLabel, string elseLabel): "testBranch($regId, $thenLabel, $elseLabel)",
        (:switch_, int regId, (int value, string label, bool unlikely)[] targets, string defaultLabel): "switch($regId)",
        (:setLocation, BackendLocation loc): "setLocation($(loc.line + 1), \"$(loc.file)\")"
    );
}
