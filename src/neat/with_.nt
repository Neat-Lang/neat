module neat.with_;

import helpers;
import neat.base;
import neat.function_ : VariableDeclaration;
import neat.util;

class WithNamespace : Namespace, Unwindable
{
    LatentVariable latent;

    bool isPtr;

    LocRange locRange;

    this(this.parent, this.latent, this.isPtr, this.locRange) { this.isContextScope = parent.isContextScope; }

    override (nullable Statement | fail Error) unwind(Context context) {
        auto temporary = accessDecl(context);
        if (auto exit = temporary.type.accessMember(
                context, temporary, "onExit", Protection.private_, this.locRange)?) {
            return context.compiler.exprStatement(exit.beExpressionImplCall(context, this.locRange)?);
        }
        return null;
    }

    Reference accessDecl(Context context)
    {
        if (isPtr) return context.compiler.dereference(latent.access(context));
        else return latent.access(context);
    }

    override (nullable Symbol | fail Error) lookup(
        string name, Context context, LookupReason reason, LocRange locRange)
    {
        if (context.framePointer) {
            auto temporary = accessDecl(context);
            auto member = context.compiler.accessMemberWithLifetime(context, temporary, name, locRange, true)?;
            if (member) return member;
        }
        if (this.parent) return this.parent.lookup(name, context, reason, locRange);
        return null;
    }
}

class ASTWithStatement : ASTStatement
{
    ASTSymbol expr;

    ASTStatement stmt;

    this(this.expr, this.stmt, this.locRange) { }

    override (StatementCompileResult | fail Error) compile(Context context)
    {
        Expression expr = this.expr.compile(context)?.beExpressionImplCall(context, this.expr.locRange)?;
        bool isPtr = !!expr.instanceOf(Reference);

        Type varType() {
            if (isPtr) return new Pointer(expr.type);
            return expr.type;
        }

        // TODO with (mut expr) so we can borrow vars here.
        (Expression | fail Error) takeExpr() {
            if (isPtr) return context.compiler.reference(expr.instanceOf(Reference).notNull);
            if (expr.info.lifetime == Lifetime.ephemeral || expr.info.lifetime == Lifetime.lexical)
                return expr.copy(context)?;
            return expr;
        }

        auto outerNamespace = context.namespace;
        auto withVarDecl = context.compiler.variableDeclaration(
                context.namespace, "__with", varType, mut=true, borrowed=false, hidden=true);
        auto var = withVarDecl.instanceOf(VariableDeclaration).variable;
        auto context = context.withNamespace(withVarDecl);

        mut Reference target = var.access(context);
        assert(target.info.lifetime == Lifetime.ephemeral);
        auto set = context.compiler.assignStatement(target, takeExpr?);

        if (isPtr) target = context.compiler.dereference(target);

        mut nullable Statement prefix, suffix;
        if (auto enter = target.type.accessMember(
            context, target, "onEnter", Protection.private_, this.locRange)?) {
            prefix = context.compiler.exprStatement(enter.beExpressionImplCall(context, this.locRange)?);
        }
        // onExit is called by the unwind.
        // if (auto exit = ... )

        auto subContext = context.withNamespace(new WithNamespace(context.namespace, var, isPtr, this.locRange));
        auto subStmtPair = this.stmt.compile(subContext)?;

        with (context.compiler) {
            auto stmt = subStmtPair.statement;
            auto stmt = sequence(sequence(sequence(set, prefix), stmt), suffix);
            auto stmt = unwindScope(subContext, outerNamespace, stmt)?;
            return StatementCompileResult(stmt, outerNamespace);
        }
    }

    override ASTSymbol quote(Quoter quoter) {
        print("TODO: quote(ASTWithStatement)");
        assert(false);
    }
}

(nullable ASTStatement | fail Error) parseWithStatement(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from?;
    if (!parser.acceptIdentifier("with")?) {
        parser.revert;
        return null;
    }
    parser.commit;
    parser.expect("(")?;
    auto subExpr = lexicalContext.compiler.parseExpression(parser, lexicalContext)?;
    parser.assert_(!!subExpr, "with expression expected")?;
    parser.expect(")")?;
    auto locRange = parser.to(from);
    auto body_ = lexicalContext.compiler.parseStatement(parser, lexicalContext)?;

    return new ASTWithStatement(subExpr.notNull, body_, locRange);
}
