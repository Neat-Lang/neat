module neat.compiler;

macro import package(compiler).std.macro.assert;
macro import package(compiler).std.macro.listcomprehension;
macro import package(compiler).std.macro.once;
macro import package(compiler).std.macro.quasiquoting;

import backend.base;
import neat.array;
import neat.base;
import neat.bottom;
import neat.class_;
import neat.either;
import neat.expr;
import neat.float;
import neat.FileIdTableImpl;
import neat.formatstring;
import neat.function_;
import neat.lexer;
import neat.parser;
import neat.pragmas;
import neat.quasiquoting;
import neat.runtime;
import neat.statements;
import neat.struct_;
import neat.stuff;
import neat.templ;
import neat.tuples;
import neat.types;
import neat.union_;
import neat.util;
import package(compiler).std.thread;

/**
 * This class pulls together all the Neat compiler functionality into one class.
 * It is passed around everywhere to break module dependency loops.
 */
class CompilerImpl : CompilerBase
{
    ASTModule[] defaultImports;

    Package[] allPackages_;

    Mutex mutex;

    GlobalUniqCounter glob;

    this(this.defaultImports, this.allPackages_, this.cFlags, this.workPool, this.fileIdTable) {
        this.mutex = new Mutex;
        this.glob = new GlobalUniqCounter;
    }

    CachedRuntimeFunction[] cachedRuntimeFunctions;

    (int uniqueId, (ASTSymbol | ASTStatement))[LocRange] cachedFragments;

    // TODO hashmap.length
    int numCachedFragments;

    // break reference cycles to avoid leaks
    void clear() {
        this.cachedRuntimeFunctions = [];
        this.defaultImports = [];
        this.cachedFragments.clear;
    }

    // parser
    override (Parser | Error) createParser(string filename, string text) {
        auto fileId = this.fileIdTable.toFileId(filename);
        return new ParserImpl(filename, fileId, text, tokenize(text)?);
    }

    override (Parser | Error) createFragmentParser(string fragment, LocRange locRange) {
        auto tokens = tokenize(fragment, locRange.from.row, locRange.from.column)?;
        return new ParserImpl("TODO??", locRange.fileId, fragment, tokens);
    }

    override void disposeParser(Parser parser) {
        auto parserImpl = parser.instanceOf(ParserImpl)? else die;
        if (parserImpl.pinned) {
            this.fileIdTable.pin(parserImpl.fileId);
        }
    }

    override Package[] allPackages() => this.allPackages_;

    override (nullable ASTSymbol | Error) parseExpression(Parser parser, LexicalContext lexicalContext)
    {
        return .parseExpression(parser.instanceOf(ParserImpl)? else die, lexicalContext);
    }

    override (nullable ASTSymbol | Error) parseArithmetic(Parser parser, LexicalContext lexicalContext)
    {
        auto leaf = parseExpressionLeaf(parser, lexicalContext)?
            .case(null: return parser.fail("Expression leaf expected"));

        return .parseArithmetic(parser.instanceOf(ParserImpl)? else die, lexicalContext, leaf, 0);
    }

    override (nullable ASTSymbol | Error) parseExpressionLeaf(Parser parser, LexicalContext lexicalContext)
    {
        return .parseExpressionLeaf(parser.instanceOf(ParserImpl)? else die, lexicalContext);
    }

    override (ASTStatement | Error) parseStatement(Parser parser, LexicalContext lexicalContext)
    {
        return .parseStatement(parser.instanceOf(ParserImpl)? else die, lexicalContext);
    }

    override (nullable ASTIdentifierSymbol | Error) parseIdentifierSymbol(Parser parser, LexicalContext lexicalContext)
    {
        return .parseIdentifierSymbol(parser.instanceOf(ParserImpl)? else die, lexicalContext);
    }

    override (nullable ASTDeclaration | Error) parseDeclaration(Parser parser, LexicalContext lexicalContext)
    {
        return .parseDeclaration(parser.instanceOf(ParserImpl)? else die, lexicalContext);
    }

    override (nullable ASTSymbol | Error) parseType(Parser parser, LexicalContext lexicalContext)
    {
        return .parseType(parser.instanceOf(ParserImpl)? else die, lexicalContext);
    }

    override (ASTSymbol | Error) parseStringLiteral(
        Parser parser, LexicalContext lexicalContext)
    {
        return .parseStringLiteral(parser.instanceOf(ParserImpl)? else die, lexicalContext, TokenType.doubleQuote);
    }

    override (nullable ASTSymbolDeclaration | Error) parseTemplateStub(
        Parser parser, LexicalContext lexicalContext, ASTIdentifierSymbol name, string comment,
        (nullable ASTSymbolDeclaration | Error) delegate!() dg)
    {
        return .parseTemplateStub(parser, lexicalContext, name, comment, dg);
    }

    override (ASTStatement | Error) parseFunctionBody(Parser parser, LexicalContext lexicalContext)
    {
        if (parser.acceptToken2(TokenType.equal, TokenType.greater)) {
            auto expr = parseExpression(parser, lexicalContext)??
                else return parser.fail("function expression expected");
            parser.expectToken(TokenType.semicolon)?;
            return astExpressionStmt(astReturn(expr, expr.locRange), expr.locRange);
        }
        return .parseStatement(parser.instanceOf(ParserImpl)? else die, lexicalContext);
    }

    override ASTSymbol astBinaryOp(string op, ASTSymbol left, ASTSymbol right, LocRange locRange)
    {
        return new ASTBinaryOp(op, left, right, locRange);
    }

    override (ASTSymbol left, string op, ASTSymbol right | :else) destructAstBinaryOp(ASTSymbol sym) {
        return sym.instanceOf(ASTBinaryOp)?.((that.left, that.op, that.right)) else :else;
    }

    override (ASTSymbol decl, ASTSymbol[] types | :else) destructAstTemplateInstance(ASTSymbol sym) {
        return sym.instanceOf(ASTTemplateInstance)?.((that.templateDecl, that.types)) else :else;
    }

    override ASTSymbol astIndex(ASTSymbol base, ASTSymbol index, LocRange locRange)
    {
        return new ASTIndexAccess(base, index, locRange);
    }

    override ASTSymbol astMember(ASTSymbol base, ASTIdentifierSymbol member, LocRange locRange)
    {
        return new ASTMember(base, member, locRange);
    }

    override (ASTSymbol base, ASTIdentifierSymbol member | :else) destructAstMember(ASTSymbol sym) {
        if (auto astMember = sym.instanceOf(ASTMemberBase)) {
            return (astMember.base, astMember.member);
        }
        return :else;
    }

    override ASTSymbol astReference(ASTSymbol value, LocRange locRange)
    {
        return new ASTReference(value, locRange);
    }

    override ASTSymbol astDereference(ASTSymbol value, LocRange locRange)
    {
        return new ASTDereference(value, locRange);
    }

    override ASTSymbol astNumberLiteral(long value, LocRange locRange=__CALLER__)
    {
        return new ASTNumberLiteral(value, locRange);
    }

    override (long | :else) destructAstNumberLiteral(ASTSymbol sym) {
        if (auto lit = sym.instanceOf(ASTNumberLiteral)) {
            return lit.value;
        }
        return :else;
    }

    override ASTSymbol astStringLiteral(string text, LocRange locRange)
    {
        return new ASTStringLiteral(text, locRange);
    }

    override ASTSymbol astCharLiteral(char ch, LocRange locRange)
    {
        return new ASTCharLiteral(ch, locRange);
    }

    override (string | :else) destructAstStringLiteral(ASTSymbol sym) {
        if (auto lit = sym.instanceOf(ASTStringLiteral)) {
            return lit.text;
        }
        return :else;
    }

    override (ASTStatement[] | :else) destructAstSequence(ASTStatement stmt) {
        return stmt.instanceOf(ASTSequenceStatement)?.statements else :else;
    }

    override (ASTSymbol target, ASTArgument[] args | :else) destructAstCall(ASTSymbol sym) {
        if (auto call = sym.instanceOf(ASTCall)) {
            return (call.target, call.args);
        }
        return :else;
    }

    override ASTSymbol astFormatString(ASTSymbol[] parts, LocRange locRange) {
        return new ASTFormatString(parts, locRange);
    }

    override ASTSymbol astArrayLiteral(ASTSymbol[] values, LocRange locRange)
    {
        auto elements = [ASTArrayLiteralElement(value, locRange) for value in values];
        return new ASTArrayLiteral(elements);
    }

    override ASTSymbol astTupleLiteral(ASTSymbol[] entries, LocRange locRange)
    {
        return new ASTTupleExpr([("", entry) for entry in entries], locRange);
    }

    override ASTSymbol astTupleLiteral2((string name, ASTSymbol symbol)[] entries, LocRange locRange)
    {
        return new ASTTupleExpr(entries, locRange);
    }

    override ASTSymbol astIota(ASTSymbol from, ASTSymbol to, LocRange locRange) {
        return new ASTIota(from, to, locRange);
    }

    override ASTSymbol astArraySlice(ASTSymbol array, ASTSymbol lower, ASTSymbol upper, LocRange locRange)
    {
        return new ASTArraySlice(array, lower, upper, locRange);
    }

    override ASTSymbol astVoidLiteral(LocRange locRange)
    {
        return new ASTVoidExpression(locRange);
    }

    override ASTIdentifierSymbol astIdentifier(string name, LocRange locRange)
    {
        return new ASTIdentifier(name, false, locRange);
    }

    override (string | :else) destructAstIdentifier(ASTSymbol sym) {
        if (auto ident = sym.instanceOf(ASTIdentifier)) {
            return ident.name_;
        }
        return :else;
    }

    override ASTSymbol astNegation(ASTSymbol value, LocRange locRange)
    {
        return new ASTNegation(value, locRange);
    }

    override (ASTSymbol | :else) destructAstNegation(ASTSymbol sym) {
        if (auto neg = sym.instanceOf(ASTNegation)) {
            return neg.next;
        }
    }

    override ASTSymbol astCall(ASTSymbol target, ASTSymbol[] args, LocRange locRange)
    {
        return new ASTCall(
            target,
            [ASTArgument(sym, "", sym.locRange) for sym in args],
            locRange);
    }

    override ASTSymbol astNewExpression(ASTSymbol type, (ASTSymbol[] | ASTArgument[]) args, LocRange locRange) {
        auto arguments = args.case(
            ASTArgument[] a: a,
            ASTSymbol[] s: [ASTArgument(sym, "", sym.locRange) for sym in s]);

        return new ASTNewExpression(type, arguments, locRange);
    }

    override ASTSymbol astDestroy(ASTSymbol target, LocRange locRange)
    {
        return new ASTDestroy(target, locRange);
    }

    override ASTSymbol astStatementExpression(ASTStatement[] statements, ASTSymbol expr, LocRange locRange)
    {
        return new ASTStatementExpression(statements, expr, locRange);
    }

    override ASTSymbol astCast(ASTSymbol target, ASTSymbol value, LocRange locRange)
    {
        return new ASTCastExpr(target, value, locRange);
    }

    override (ASTSymbol target, ASTSymbol value | :else) destructAstCast(ASTSymbol sym) {
        if (auto astCast = sym.instanceOf(ASTCastExpr)) {
            return (astCast.target, astCast.value);
        }
        return :else;
    }

    override ASTStatement astExpressionStmt(ASTSymbol expr, LocRange locRange)
    {
        return new ASTExprStatement(expr, locRange);
    }

    override ASTStatement astScope(ASTStatement[] statements, LocRange locRange)
    {
        return new ASTScopeStatement(statements, locRange);
    }

    override ASTStatement astSequence(ASTStatement[] statements, LocRange locRange)
    {
        return new ASTSequenceStatement(statements, locRange);
    }

    override ASTStatement astIf((ASTSymbol | ASTStatement) test, ASTStatement then, nullable ASTStatement else_, LocRange locRange)
    {
        test.case {
            ASTSymbol sym: return new ASTIfStatement(sym, then, else_, letMode=false, locRange);
            ASTStatement stmt: {
                if (auto vardecl = stmt.instanceOf(ASTVarDeclStatement))
                    return new ASTIfStatement(vardecl, then, else_, letMode=false, locRange);
                else if (auto extractdecl = stmt.instanceOf(ASTVarExtractDeclStatement))
                    return new ASTIfStatement(extractdecl, then, else_, letMode=false, locRange);
                else assert(false);
            }
        }
    }

    override ASTStatement astForLoop(
        ASTStatement init, ASTSymbol test, ASTStatement step, ASTStatement body_, LocRange locRange)
    {
        return new ASTForLoop(init, test, step, body_, locRange);
    }

    override ASTStatement astExtForLoop(
        ASTSymbol source, ExtForVarDecl var1, (ExtForVarDecl | :none) var2, ASTStatement body_, LocRange locRange)
    {
        return new ASTExtForLoop(source, var1, var2, body_, locRange);
    }

    override ASTStatement astAssign(ASTSymbol target, ASTSymbol source, LocRange locRange)
    {
        return new ASTAssignStatement(target, source, locRange);
    }

    override ASTStatement astOpAssign(ASTSymbol left, string op, ASTSymbol right, LocRange locRange)
    {
        return new ASTOpAssignStatement(left, op, right, locRange);
    }

    override ASTStatement astDeclareVar(
        ASTIdentifierSymbol name, bool mutable, bool uninitialized, nullable ASTSymbol initial, LocRange locRange)
    {
        return new ASTVarDeclStatement(name, mutable, true, uninitialized=uninitialized, null, initial, locRange);
    }

    override ASTStatement astDeclareTypedVar(
        ASTIdentifierSymbol name, bool mutable, bool uninitialized, ASTSymbol type, nullable ASTSymbol initial, LocRange locRange)
    {
        return new ASTVarDeclStatement(name, mutable, false, uninitialized=uninitialized, type, initial, locRange);
    }

    override ASTStatement astDeclareVarExtract(
        ASTIdentifierSymbol name, bool mutable, bool infer, nullable ASTSymbol type, ASTSymbol source, LocRange locRange)
    {
        return new ASTVarExtractDeclStatement(name, mutable, infer, type, source, locRange);
    }

    override ASTSymbol astReturn(ASTSymbol value, LocRange locRange)
    {
        return new ASTReturn(value, locRange);
    }

    override ASTSymbol astBreak(LocRange locRange)
    {
        return new ASTBreak(locRange);
    }

    override ASTSymbol astContinue(LocRange locRange)
    {
        return new ASTContinue(locRange);
    }

    override ASTSymbol astSuper(LocRange locRange)
    {
        return new ASTSuper(locRange);
    }

    override ASTStatement astDeclarationStatement(ASTDeclaration target, LocRange locRange)
    {
        return new ASTDeclarationStatement(target);
    }

    override ASTStatement astQuotedStatement(string fragment, Package pak,
        ASTSymbol[] symbols, ASTStatement[] statements, ASTIdentifierSymbol[] identifiers, LocRange locRange,
        nullable MacroState macroState = null)
    {
        (int uniqueId, ASTStatement astStatement) get() with (this.mutex.locked) {
            if (this.cachedFragments.has(locRange)) {
                (int uniqueId, (ASTSymbol | ASTStatement) sym) hit = this.cachedFragments[locRange];
                hit.sym.case {
                    ASTStatement stmt: return (hit.uniqueId, stmt);
                    ASTSymbol sym: assert(false);
                }
            }
            int uniqueId = this.numCachedFragments++;
            mut uninitialized ASTStatement astStatement;
            with (this.mutex.unlocked) {
                auto parser = createFragmentParser(fragment=fragment, locRange=locRange)
                    .case(Error err: dieFragment(fragment, err));
                auto quoteLexicalContext = new QuoteLexicalContext(uniqueId, this, pak, macroState);
                astStatement = parseStatement(parser, quoteLexicalContext)
                    .case(Error err: dieFragment(fragment, err));
            }
            this.cachedFragments[locRange] = (uniqueId, astStatement);
            return (uniqueId, astStatement);
        }
        auto get = get;
        auto scope_ = QuoteScopeValue(get.uniqueId, symbols, statements, identifiers);
        return new ASTQuotedStatement(get.astStatement, scope_, locRange);
    }

    override ASTSymbol astQuotedExpression(string fragment, Package pak,
        ASTSymbol[] symbols, ASTStatement[] statements, ASTIdentifierSymbol[] identifiers, LocRange locRange)
    {
        (int uniqueId, ASTSymbol astSymbol) get() with (this.mutex.locked) {
            if (this.cachedFragments.has(locRange)) {
                (int uniqueId, (ASTSymbol | ASTStatement) value) hit = this.cachedFragments[locRange];
                hit.value.case {
                    ASTStatement stmt: assert(false);
                    ASTSymbol sym: return (hit.uniqueId, sym);
                }
            }
            int uniqueId = this.numCachedFragments++;
            mut uninitialized ASTSymbol astSymbol;
            with (this.mutex.unlocked) {
                auto parser = createFragmentParser(fragment=fragment, locRange=locRange)
                    .case(Error err: dieFragment(fragment, err));
                auto quoteLexicalContext = new QuoteLexicalContext(uniqueId, this, pak);
                astSymbol = parseExpression(parser, quoteLexicalContext)
                    .case(Error err: dieFragment(fragment, err))? else die;
            }
            this.cachedFragments[locRange] = (uniqueId, astSymbol);
            return (uniqueId, astSymbol);
        }
        auto get = get;
        auto scope_ = QuoteScopeValue(get.uniqueId, symbols, statements, identifiers);
        return new ASTQuotedExpression(get.astSymbol, scope_, locRange);
    }

    override ASTSymbol astQuotedType(string fragment, Package pak,
        ASTSymbol[] symbols, ASTStatement[] statements, ASTIdentifierSymbol[] identifiers, LocRange locRange)
    {
        (int uniqueId, ASTSymbol astType) get() with (this.mutex.locked) {
            if (this.cachedFragments.has(locRange)) {
                (int uniqueId, (ASTSymbol | ASTStatement) value) hit = this.cachedFragments[locRange];
                hit.value.case {
                    ASTStatement stmt: assert(false);
                    ASTSymbol sym: return (hit.uniqueId, sym);
                }
            }
            int uniqueId = this.numCachedFragments++;
            mut uninitialized ASTSymbol astType;
            with (this.mutex.unlocked) {
                auto parser = createFragmentParser(fragment=fragment, locRange=locRange)
                    .case(Error err: dieFragment(fragment, err));
                auto quoteLexicalContext = new QuoteLexicalContext(uniqueId, this, pak);
                astType = parseType(parser, quoteLexicalContext)
                    .case(Error err: dieFragment(fragment, err))? else die;
            }
            this.cachedFragments[locRange] = (uniqueId, astType);
            return (uniqueId, astType);
        }
        auto get = get;
        auto scope_ = QuoteScopeValue(get.uniqueId, symbols, statements, identifiers);
        return new ASTQuotedType(get.astType, scope_, locRange);
    }

    override ASTSymbol astArray(ASTSymbol elementType, bool mutableElements, LocRange locRange)
    {
        return new ASTArray(elementType, mutableElements, locRange);
    }

    override ASTSymbol astBasicType(string name, LocRange locRange)
    {
        return new ASTIdentifier(name, false, locRange);
    }

    override ASTSymbol astTypeOf(ASTSymbol value, LocRange locRange)
    {
        return new ASTTypeof(value, locRange);
    }

    override ASTSymbol astPointer(ASTSymbol target, LocRange locRange)
    {
        return new ASTPointer(target, locRange);
    }

    override ASTSymbol astFunctionPointer(ASTSymbol ret, ASTSymbol[] params, LocRange locRange)
    {
        return new ASTFunctionPointer(ret, params, locRange);
    }

    override ASTSymbol astTupleType((string name, ASTSymbol type)[] members, LocRange locRange)
    {
        return new ASTTupleType(members, locRange);
    }

    override ASTSymbolDeclaration astStructDecl(string name, ASTStructMember[] members, bool externC, LocRange locRange)
    {
        mut ASTStructEntry[] entries;
        for (member in members) entries ~= member;
        auto nameSym = new ASTIdentifier(name, false);
        auto astStruct = new ASTStructDecl(nameSym, entries, locRange);
        astStruct.externC = externC;
        return astStruct;
    }

    override ASTSymbol astUnion(string name, ASTUnionMember[] members, LocRange locRange)
    {
        return new ASTUnion(name, members, comment="", locRange);
    }

    override ASTSymbol astEitherType((ASTSymbol symbol, bool fail, LocRange locRange)[] entries, LocRange locRange)
    {
        auto entries = [ASTEitherDeclEntry(a.locRange, a.fail, a.symbol) for a in entries];

        return new ASTEitherDecl(entries);
    }

    override ASTSymbol astEitherCaseExpr(ASTSymbol base, ASTEitherCaseExprCase[] cases, LocRange locRange)
    {
        return new ASTEitherCaseExpr(locRange, base, cases);
    }

    override ASTStatement astEitherCaseStmt(
        ASTSymbol base, ASTEitherCaseStmtCase[] cases, nullable ASTStatement default_, LocRange locRange)
    {
        return new ASTEitherCaseStmt(locRange, base, cases, default_);
    }

    override ASTSymbol astNullable(ASTSymbol next, bool nullify, LocRange locRange)
    {
        return new ASTNullable(next, nullify, locRange);
    }

    override ASTExternFunctionBase astExternFunction(
        string name, ASTSymbol ret, ASTParameter[] params, bool variadic, LocRange retLocRange)
    {
        return new ASTExternFunction(name, ret, params, variadic, retLocRange);
    }

    override ASTModule astModule(
        string name, Package pak, MacroState macroState, LocRange locRange, nullable ASTModuleBase parent)
    {
        // hope parse task id doesn't matter (this is only needed for CImport macro)
        // path definitely doesn't matter, it's only for docgen
        if (!parent) return new ASTModule(name, pak, path="", moduleParseTaskId="", macroState, locRange, null);
        return new ASTModule(name, pak, path="", moduleParseTaskId="", macroState, locRange,
            parent.instanceOf(ASTModule));
    }

    override ASTDeclaration astImport(string name, string pak, string[] symbols, LocRange locRange)
    {
        auto import_ = new ASTImportStatement((:normal, name, pak), isMacroImport=false, symbols, locRange);
        auto mod = resolveImport(pak, import_, locRange);

        return new ASTImport(import_, mod);
    }

    override ASTDeclaration astImport2(string name, string pak, string[] symbols, LocRange locRange)
    {
        auto import_ = new ASTImportStatement((:normal, name, pak), isMacroImport=false, symbols, locRange);
        auto mod = resolveImport(pak, import_, locRange);

        return new ASTImport(import_, mod);
    }

    override ASTPragmaBase astPragma(string pragma_, ASTSymbol[] args, LocRange locRange)
    {
        return new ASTPragma(pragma_, args, locRange);
    }

    override ASTSymbol astParenPropertyExpression(ASTSymbol base, ASTSymbol prop, LocRange locRange)
    {
        return new ASTParenPropertyExpression(base, prop, locRange);
    }


    override ASTModule resolveImport(string pak, ASTImportStatementBase import_, LocRange locRange)
    {
        .resolveImport(this, pak, import_.instanceOf(ASTImportStatement)? else die, this.parserHelper)
            .case {
                ASTModule mod: return mod;
                Error error: exitWithError(error, this.fileIdTable);
            }
    }

    // expressions and statements
    override (nullable Expression | Error) implicitConvertTo(
        Context context, Expression from, Type to, LocRange locRange)
    {
        return .implicitConvertTo(context, from, to, locRange);
    }

    override Expression intLiteral(int value) { return new IntLiteral(value); }

    override Expression wordLiteral(Platform platform, long value) {
        return new WordLiteral(this.nativeWordType(platform), value);
    }

    override Expression boolLiteral(bool value) { return new BoolLiteral(value); }

    override Expression voidLiteral() { return new VoidExpression; }

    override Expression stringLiteral(Platform platform, string value) { return new StringLiteral(value, platform); }

    override (nullable Expression | Error) isExpressionImplCall(Context context, Symbol symbol, LocRange locRange)
    {
        return .isExpressionImplCall(symbol, context, locRange);
    }

    override Reference stackFrame(Type type) {
        return new StackFrame(type);
    }

    override (nullable Expression | Error) call(Context context, ASTSymbol target, ASTArgument[] args, LocRange locRange,
        bool isImplCall)
    {
        return .call(context, target, args, locRange, isImplCall);
    }

    override Expression mkCall(Symbol target, Expression[] args, LocRange locRange) {
        if (auto decl = target.instanceOf(FunctionDeclaration))
            return new Call(decl, args, locRange);
        assert(false);
    }

    override Expression simpleCall(Context context, string name, Type ret, Expression[] args, LocRange locRange) {
        auto decl = new FunctionDeclaration(name, ret, [Parameter.fromType(arg.type) for arg in args]);
        return new Call(decl, args, locRange);
    }

    override (Expression | Error) binaryOp(string op, Context context, Expression left, Expression right, LocRange locRange)
    {
        if (auto opOverload = left.type.binaryOp(context, op, left, right, locRange)?)
            return opOverload;
        if (op == "~") {
            return arrayCat(context, left, right, locRange);
        }
        return new BinaryOp(op, left, right, locRange);
    }

    override (Expression | Error) truthy(Context context, Expression value, LocRange locRange)
    {
        return .truthy(context, value, locRange);
    }

    override Expression castTo(Type target, Expression source)
    {
        return new CastExpr(target, source);
    }

    override Expression trivialCastTo(Type target, Expression source)
    {
        if (source.type.same(target)) return source;
        return new TrivialCastExpr(target, source);
    }

    override Expression wrap(nullable Statement before, Expression value, nullable Statement after)
    {
        if (!before && !after) return value;
        return new WrapExpression(before, value, after);
    }

    override (Expression | Error) wrapWithCleanup(Context context, Expression base,
        LocRange locRange, Expression delegate!(Expression) callback)
    {
        return .wrapWithCleanup(context, base, locRange, callback);
    }

    // wrap, allowing references
    override Expression wrapRef(nullable Statement before, Expression value, nullable Statement after)
    {
        if (!before && !after) return value;
        if (auto valueRef = value.instanceOf(Reference))
            return new WrapReference(before, valueRef, after);
        return new WrapExpression(before, value, after);
    }

    override (Expression | Error) consume(
        Context context, Expression expr, (Expression | Error) delegate!(Expression) dg)
    {
        if (expr.info.lifetime != Lifetime.gifted)
        {
            return dg(expr);
        }
        auto type = expr.type;
        auto temp = new PairedTemporaryExpr(type, Lifetime.ephemeral, context.getUniqueId);
        auto assign = new InitializeTemporaryExprStatement(temp, expr);
        auto cleanup = type.endLifetime(context, temp);
        auto result = dg(temp)?;
        return wrap(assign, result, cleanup);
    }

    override Statement consumeStmt(Context context, Expression expr, Statement delegate!(Expression) dg)
    {
        if (expr.info.lifetime != Lifetime.gifted)
        {
            return dg(expr);
        }
        auto type = expr.type;
        auto temp = new PairedTemporaryExpr(type, Lifetime.ephemeral, context.getUniqueId);
        auto assign = new InitializeTemporaryExprStatement(temp, expr);
        auto cleanup = type.endLifetime(context, temp);
        auto result = dg(temp);
        return sequence(assign, sequence(result, cleanup));
    }

    override (nullable Expression | Error) consumeTemporary(
        Context context, bool allowRefReturn, Expression expr,
        (nullable Expression | Error) delegate!(Expression) dg)
    {
        auto type = expr.type;
        auto temp = new PairedTemporaryExpr(type, Lifetime.ephemeral, context.getUniqueId);
        auto result = dg(temp)?? else return null;

        bool doCleanup = expr.info.lifetime == Lifetime.gifted;

        Statement assign = new InitializeTemporaryExprStatement(temp, expr);
        mut nullable Statement cleanup;
        if (doCleanup) {
            cleanup = type.endLifetime(context, temp);
        }
        if (allowRefReturn)
            return wrapRef(assign, result, cleanup);
        return wrap(assign, result, cleanup);
    }

    override (nullable Symbol | Error) accessMember(
        Context context, Symbol base, string member, LocRange locRange, bool allowUndefined)
    {
        return .accessMember(context, base, member, locRange, allowUndefined);
    }

    override Reference structMemberReference(Reference base, int index) {
        return new StructMemberReference(base, index);
    }

    override (nullable Symbol | Error) lookup(
        Context context, LocRange locRange, LookupReason reason, string name)
    {
        return context.namespace.lookup(name, context, reason, locRange);
    }

    override (Expression | Error) locRangeExpr(Context context, LocRange locRange)
    {
        auto fileId = astNumberLiteral(locRange.fileId);
        auto fromRow = astNumberLiteral(locRange.from.row);
        auto fromCol = astNumberLiteral(locRange.from.column);
        auto toRow = astNumberLiteral(locRange.to.row);
        auto toCol = astNumberLiteral(locRange.to.column);
        if (context.namespace.lookup("LocRange", context, LookupReason.identifier, locRange)??) {
            // we're using __RANGE__ in neat.base: don't import it again
            return (this.$expr LocRange($fileId, ($fromRow, $fromCol), ($toRow, $toCol)))
                .compile(context)?
                .beExpression?;
        } else {
            return (this.$expr ({
                import package(compiler).neat.base : LocRange;
                LocRange($fileId, ($fromRow, $fromCol), ($toRow, $toCol));
            }))
                .compile(context)?
                .beExpression?;
        }
    }

    override Reference dereference(Expression value)
    {
        return new Dereference(value);
    }

    override Expression reference(Reference ref_)
    {
        return new ReferenceExpression(ref_);
    }

    override Expression functionReference(FunctionDeclarationBase funcDecl)
    {
        return new FunctionReference(funcDecl);
    }

    override Expression pointerOffset(Expression pointer, Expression offset)
    {
        return new PointerOffset(pointer, offset);
    }

    override Statement assignStatement(Reference target, Expression value)
    {
        return new AssignStatement(target, value, :none);
    }

    override Statement assignStatement(Reference target, Expression value, LocRange locRange)
    {
        return new AssignStatement(target, value, locRange);
    }

    override Statement sequence(Statement left, nullable Statement right)
    {
        return .sequence(left, right);
    }

    override Statement sequenceStatement(Statement[] stmts)
    {
        return new SequenceStatement(stmts);
    }

    override Statement ifStatement(Expression test, Statement then, nullable Statement else_)
    {
        return new IfStatement(:none, test, then, else_, :none);
    }

    override Statement loopStatement(
        Context context, Statement initializer, Expression test, Statement body_, Statement step)
    {
        return new Loop(context.getLabel, initializer, test, body_, step, :none);
    }

    override Statement returnStatement(Expression value) {
        return new ReturnStatement(value, :none);
    }

    override Statement exprStatement(Expression test)
    {
        return new ExprStatement(test);
    }

    override (Statement | Error) unwindScope(Context context, Namespace target, Statement next)
    {
        return .unwindScope(context, target, next);
    }

    override Namespace symbolAlias(nullable Namespace parent, string name, Symbol value)
    {
        return new SymbolAlias(parent, name, value);
    }

    override DeclarationHolder variableDeclaration(
        nullable Namespace parent, string name, Platform platform, Type type, bool mut, bool borrowed, bool hidden)
    {
        return new VariableDeclaration(parent, name, platform, type, mut=mut, borrowed=borrowed, hidden);
    }

    override (Statement | Error) move(Context context, Reference target, Expression source, LocRange locRange)
    {
        return .move(context, target, source, locRange);
    }

    override (nullable Expression | Error) exprWithScratchspace(
        int uniqId, Type type, bool temporary, (nullable Statement | Error) delegate!(Reference) callback)
    {
        mut uninitialized Lifetime tempLifetime;
        if (temporary) tempLifetime = Lifetime.gifted;
        else tempLifetime = Lifetime.lexical;

        auto temp = new PairedTemporary(type, tempLifetime, uniqId);
        auto initialize = new UninitializeTemporaryStatement(temp);
        auto stmt = callback(temp)?? else return null;
        return wrap(sequence(initialize, stmt), temp, null);
    }

    override (nullable Statement | Error) stmtWithTemporary(
        int uniqId, Expression value, (nullable Statement | Error) delegate!(Reference) callback)
    {
        mut uninitialized Lifetime tempLifetime;
        if (value.info.lifetime == Lifetime.gifted) tempLifetime = Lifetime.gifted;
        else tempLifetime = Lifetime.lexical;

        auto temp = new PairedTemporary(value.type, tempLifetime, uniqId);
        auto start = new InitializeTemporaryStatement(temp, value);
        auto stmt = callback(temp)?? else return null;
        return new SequenceStatement([start, stmt]);
    }

    override (nullable Expression | Error) exprWithTemporary(
        int uniqId, Expression value, (nullable Expression | Error) delegate!(Reference) callback)
    {
        // TODO: the way gifted works here is almost certainly wrong,
        // cause the Reference can be read multiple times - that's
        // what it's for.
        mut uninitialized Lifetime tempLifetime;
        if (value.info.lifetime == Lifetime.gifted) tempLifetime = Lifetime.gifted;
        else tempLifetime = Lifetime.lexical;

        auto temp = new PairedTemporary(value.type, tempLifetime, uniqId);
        auto start = new InitializeTemporaryStatement(temp, value);
        auto expr = callback(temp)?? else return null;
        return new StatementExpression(start, expr, false);
    }

    override (nullable Statement | Error) stmtWithTemporaryExpr(
        int uniqId, Expression value, (nullable Statement | Error) delegate!(Expression) callback)
    {
        auto temp = new PairedTemporaryExpr(value.type, value.info.lifetime, uniqId);
        auto start = new InitializeTemporaryExprStatement(temp, value);
        auto stmt = callback(temp)?? else return null;
        return new SequenceStatement([start, stmt]);
    }

    override (nullable Expression | Error) exprWithTemporaryExpr(
        int uniqId, Expression value, (nullable Expression | Error) delegate!(Expression) callback)
    {
        auto temp = new PairedTemporaryExpr(value.type, value.info.lifetime, uniqId);
        auto start = new InitializeTemporaryExprStatement(temp, value);
        auto expr = callback(temp)?? else return null;
        return new StatementExpression(start, expr, gifted=false);
    }

    override (nullable Expression | Error) exprWithTemporaryExpr(
        int uniqId, Expression value, bool copyLifetime,
        (nullable Expression | Error) delegate!(Expression) callback)
    {
        auto temp = new PairedTemporaryExpr(value.type, Lifetime.none, uniqId);
        auto start = new InitializeTemporaryExprStatement(temp, value);
        auto expr = callback(temp)?? else return null;
        if (copyLifetime) return new StatementExpression(start, expr, value.info);
        else return new StatementExpression(start, expr, expr.info);
    }

    override Expression statementExpression(Statement statement, Expression expression)
    {
        return new StatementExpression(statement, expression, false);
    }

    override Expression statementExpression(Statement statement, Expression expression, ExprInfo info)
    {
        return new StatementExpression(statement, expression, info);
    }

    override (void | Error) addDefaultImports(Context context, ModuleBase module_)
    {
        (Module | Error) compile(ASTModule astMod) {
            auto coldContext = context.coldContext.withMacroState(astMod.macroState);
            return .compileModule(astMod, coldContext, addDefaultImports=false);
        }
        auto defaultMods = [compile(mod)? for mod in this.defaultImports];
        [module_.addImport(mod, public_=false, []) for mod in defaultMods];
    }

    override ModuleBase createModule(
        string name, string mangle, string moduleParseTaskId, LocRange locRange, nullable ModuleBase parent
    ) {
        mut nullable Module parentMod = null;
        if (parent) parentMod = parent.instanceOf(Module);
        return new Module(name, mangle, locRange, parentMod, moduleParseTaskId);
    }

    override FunctionDeclaration createRuntimeFunction(
        Context context, string name, Type ret, Parameter[] params, ASTStatement delegate!() makeBody)
    {
        // TODO compare types, not mangle string.
        // Bit difficult because transition requires changing the name of functions in macros.
        mut string mangledName = name ~ "_" ~ ret.mangle;
        for (param in params) {
            mangledName ~= "_" ~ param.type.mangle;
        }
        with (this.mutex.locked) {
            for (entry in cachedRuntimeFunctions) {
                if (entry.fun.name == mangledName && entry.platformIdent == context.platform.ident) {
                    context.compilingModule.addImport(entry.rtMod, public_=false, []);
                    return entry.fun;
                }
            }
        }

        auto fun = new Function(mangledName, ret, params, makeBody(), context.macroState,
            hasThisArg=false);
        auto pak = new Package("rt_" ~ mangledName, "", []);
        // parse task doesn't matter - there's no ASTModule that contains a rt fun, so they'll never need reparsing.
        auto rtMod = new Module(name, mangleModuleName(name, pak, 0), __RANGE__, null, moduleParseTaskId="");
        rtMod.register("free", Protection.public_, new FunctionDeclaration(
            "free", new Void, [Parameter.fromType(new Pointer(new Void))]));
        rtMod.register("print", Protection.public_, new FunctionDeclaration(
            "print", new Void, [Parameter.fromType(new Array(new Character, context.platform))]));
        rtMod.register("neat_runtime_alloc", Protection.public_, new FunctionDeclaration(
            "neat_runtime_alloc", new Pointer(new Void), [Parameter.fromType(context.nativeWordType)]));
        rtMod.register("neat_runtime_refcount_inc", Protection.public_, new FunctionDeclaration(
            "neat_runtime_refcount_inc", new Void, [
                Parameter.simple("label", new Array(new Character, context.platform)),
                Parameter.simple("ptr", new Pointer(new Void))]));
        rtMod.register("neat_runtime_refcount_dec", Protection.public_, new FunctionDeclaration(
            "neat_runtime_refcount_dec", new Integer, [
                Parameter.simple("label", new Array(new Character, context.platform)),
                Parameter.simple("ptr", new Pointer(new Void))]));

        fun.parent = rtMod;
        fun.resetMangleCache;
        rtMod.track(fun);
        addDefaultImports(context, rtMod).case {
            void: {}
            Error err: exitWithError(err, this.fileIdTable);
        }
        context.compilingModule.addImport(rtMod, public_=false, []);

        with (this.mutex.locked) {
            cachedRuntimeFunctions ~= CachedRuntimeFunction(fun, rtMod, context.platform.ident);
        }
        // run AFTER module was added to cache, to break dependency loop for recursive types
        rtMod.compile(context).case {
            void: {}
            Error err: exitWithError(err, this.fileIdTable);
        }

        return fun;
    }

    override Type nativeWordType(Platform platform)
    {
        BackendType type = platform.nativeWordType;
        if (type.instanceOf(BackendIntType)) return new Integer;
        if (type.instanceOf(BackendLongType)) return new Long;
        assert(false);
    }

    override Type struct_(string name, StructMemberDeclaration[] members, LocRange locRange, string manglePrefix)
    {
        return new Struct(name, members, locRange, manglePrefix);
    }

    override Type eitherType((bool fail, Type type)[] types)
    {
        return new Either(types);
    }

    override (Type | :else) isArrayType(Type type) {
        if (auto arr = type.instanceOf(Array)) return arr.elementType;
        return :else;
    }

    override (string | :else) isBasicType(Type type) {
        // see ASTIdentifier
        if (type.instanceOf(Integer)) return "int";
        if (type.instanceOf(Long)) return "long";
        if (type.instanceOf(Short)) return "short";
        if (type.instanceOf(Character)) return "char";
        if (type.instanceOf(UByte)) return "ubyte";
        if (type.instanceOf(Boolean)) return "bool";
        if (type.instanceOf(Void)) return "void";
        if (type.instanceOf(Float)) return "float";
        if (type.instanceOf(Double)) return "double";
        if (type.instanceOf(Bottom)) return "bottom";
        return :else;
    }

    override (Symbol | Error) identifier(Context context, string name, bool moduleLevel, LocRange locRange) {
        if (!moduleLevel) {
            if (name == "int") return new Integer;
            if (name == "long") return new Long;
            if (name == "short") return new Short;
            if (name == "char") return new Character;
            if (name == "ubyte") return new UByte;
            if (name == "bool") return new Boolean;
            if (name == "void") return new Void;
            if (name == "float") return new Float;
            if (name == "double") return new Double;
            if (name == "nullptr_t") return new NullPointer;
            if (name == "size_t") return context.nativeWordType;
            if (name == "bottom") return new Bottom;
            if (name == "unreachable") return new UnreachableExpr;
        }

        (nullable Symbol | Error) resolve() {
            auto reason = LookupReason.identifier;
            if (moduleLevel) {
                auto module_ = findParent!ModuleBase(context.namespace);
                return module_.lookup(name, context.withFramePointer(null, :none), reason, locRange);
            } else if (context.namespace.isContextScope) {
                return context.namespace.lookup(name, context, reason, locRange);
            } else {
                return context.namespace.lookup(name, context.withFramePointer(null, :none), reason, locRange);
            }
        }
        return resolve?? else return locRange.fail("'$(name)' not found");
    }

    override bool isClassType(Type type) {
        return type.instanceOf(ClassType) || type.instanceOf(IntfType);
    }

    // called when expr is discarded (usually via ignored return value)
    override (void | Error) discardErrorCheck(Expression expr, LocRange locRange) {
        bool isErrorClass(Type type) {
            return type.instanceOf(ClassType)?.class_.errorclass else false;
        }
        if (expr.type.isErrorClass) {
            return locRange.fail("silently discarding error class");
        } else if (auto either = expr.type.instanceOf(Either)) {
            if ([any entry.type.isErrorClass for entry in either.types]) {
                return locRange.fail("silently discarding error class");
            }
            if ([any entry.fail for entry in either.types]) {
                return locRange.fail("silently discarding failure type");
            }
        }
    }

    override string queueModuleCompilation(Context context, ASTModuleBase astModule) {
        auto astModule = astModule.instanceOf(ASTModule)? else die;
        auto taskId = "compile platform $(context.platform.ident) ast $(astModule.mangledName)";
        auto task = new AstCompileTask(taskId, astModule, context.coldContext);

        workPool.queue(task);
        if (astModule.moduleParseTaskId != "")
            workPool.dependency(provider=astModule.moduleParseTaskId, consumer=taskId);
        return taskId;
    }

    override (ModuleBase | Error) getCompiledModule(string taskId) {
        workPool.dependency(provider=taskId, consumer=:current);
        return workPool.wait(taskId).instanceOf(AstCompileTask).module_?;
    }

    override IUniqCounter uniqCounter() => new UniqCounter(this.glob);
}

private bottom dieFragment(string fragment, Error err) {
    print("while parsing quote fragment '$fragment', an error happened " ~
        "during evaltime that didn't happen during compiletime: $(err.msg)");
    assert(false);
}

struct CachedRuntimeFunction
{
    FunctionDeclaration fun;

    Module rtMod;

    string platformIdent;
}

class UniqCounter : IUniqCounter
{
    (int from, int to) range;

    GlobalUniqCounter glob;

    this(this.glob) { }

    override int next() {
        if (range.from == range.to) {
            range = this.glob.genRange;
        }
        return range.from++;
    }

    override IUniqCounter dup() => new UniqCounter(this.glob);
}

class GlobalUniqCounter
{
    int value;

    Mutex mutex;

    this() { this.mutex = new Mutex; }

    (int from, int to) genRange() {
        int length = 1000;
        mutex.lock;
        int res = this.value;
        this.value += length;
        mutex.unlock;
        return (res, res + length);
    }
}
