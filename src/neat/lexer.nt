module neat.lexer;

macro import std.macro.assert;

import neat.base;
import std.file;
import std.stdio;

// FIXME =>
// FIXME 'c'

struct Token {
    TokenType type;
    int pos;
    int row, col;
    version (firstpass)
        string toString() return "<$(row+1):$(col+1): $(cast(int) type)>";
    else
        string toString() return "<$(row+1):$(col+1): $type>";
}

// FIXME with (TokenType)
(Token[] | fail Error) tokenize(string text, string filename="", mut int row=0, mut int col=0) {
    mut Token[] result = new Token[](4);
    mut int resultIdx = 0;
    mut int pos = 0;
    mut int parenLevel = 0;
    mut int[] stringParenLevels;
    void stepRow(int dist, int cols) {
        pos += dist;
        col += cols;
    }
    void stepRow1() {
        stepRow(1, 1);
    }
    void stepNewline() {
        pos++;
        row++;
        col = 0;
    }
    void stepUtf8() {
        // FIXME return stepRow
        if (text[pos] < 0b1000_0000) { stepRow(1, 1); return; }
        if (text[pos] < 0b1110_0000) { stepRow(2, 1); return; }
        if (text[pos] < 0b1111_0000) { stepRow(3, 1); return; }
        stepRow(4, 1);
        return;
    }
    void addTokenInplace(TokenType type) {
        if (resultIdx == result.length) {
            auto old = result;
            result = new Token[](result.length * 2);
            for (i, token in old) result[i] = token;
        }
        result[resultIdx++] = Token(type, pos, row, col);
    }
    void addToken(TokenType type, bool newline=false) {
        addTokenInplace(type);
        if (newline) stepNewline;
        else stepRow1;
    }
    auto isIdentStarter = ch => ch.isAlpha || ch == "_"[0] || ch.isUtf8MbStart;
    auto isIdentMiddle = ch => ch.isAlnum || ch == "_"[0] || ch.isUtf8MbStart;
    // if (!filename.empty) print("=== tokenize $filename ===");
    void stepStringLiteral() {
        while (pos < text.length && text[pos] != "\""[0]) {
            if (pos < text.length - 1 && text[pos .. pos + 2] == "\$(") {
                stringParenLevels ~= parenLevel++;
                addToken(TokenType.formatQuoteStart);
                addToken(TokenType.lparen);
                return;
            }
            if (text[pos] == "\$"[0]) {
                addToken(TokenType.formatQuoteStart);
                if (pos < text.length && text[pos].isIdentStarter) {
                    addToken(TokenType.identifier);
                    while (pos < text.length && text[pos].isIdentMiddle)
                        pos++;
                }
                if (pos < text.length && text[pos] != "\""[0])
                    addTokenInplace(TokenType.stringLiteral);
                continue;
            }
            if (pos < text.length - 1 && text[pos] == "\\"[0]) {
                // skip escaped character
                stepRow1;
            }
            if (text[pos] == "\n"[0]) stepNewline;
            else stepUtf8;
        }
        if (pos < text.length)
            addToken(TokenType.doubleQuote);
    }
    while (pos < text.length) {
        auto ch = text[pos];
        if (ch.isIdentStarter) {
            addTokenInplace(TokenType.identifier);
            stepUtf8;
            while (pos < text.length && text[pos].isIdentMiddle)
                stepUtf8;
        }
        else if (ch.isWhitespace) {
            addToken(TokenType.whitespace, newline=text[pos] == "\n"[0]);
            while (pos < text.length && text[pos].isWhitespace) {
                if (text[pos] == "\n"[0]) stepNewline;
                else stepRow1;
            }
        }
        else if (ch.isNumeric) {
            addToken(TokenType.number);
            while (pos < text.length && (text[pos].isNumeric || text[pos] == "_"[0]))
                stepRow1;
        }
        else if (ch == "/"[0] && pos + 1 < text.length && text[pos + 1] == "/"[0]) {
            addToken(TokenType.comment);
            stepRow(1, 1);
            while (pos < text.length && text[pos] != "\n"[0])
                stepRow1;
        }
        else if (ch == "/"[0] && pos + 1 < text.length && text[pos + 1] == "*"[0]) {
            addToken(TokenType.comment);
            stepRow(1, 1);
            mut int depth = 1;
            while (pos + 1 < text.length) {
                if (text[pos .. pos + 2] == "/*") {
                    depth++;
                    stepRow(2, 2);
                } else if (text[pos .. pos + 2] == "*/") {
                    depth--;
                    stepRow(2, 2);
                    if (depth == 0) break;
                } else if (text[pos] == "\n"[0]) stepNewline;
                else stepUtf8;
            }
        }
        else if (ch == "'"[0]) {
            addToken(TokenType.singleQuote);
            if (pos < text.length && text[pos] != "'"[0])
                addTokenInplace(TokenType.charLiteral);
            while (pos < text.length && text[pos] != "'"[0]) {
                if (pos < text.length - 1 && text[pos] == "\\"[0]) {
                    // skip escaped character
                    stepRow1;
                }
                stepUtf8;
            }
            addToken(TokenType.singleQuote);
        }
        else if (ch == "\""[0]) {
            addToken(TokenType.doubleQuote);
            if (pos < text.length && text[pos] != "\""[0])
                addTokenInplace(TokenType.stringLiteral);
            stepStringLiteral;
        }
        else if (ch == "("[0]) {
            addToken(TokenType.lparen);
            parenLevel++;
        }
        else if (ch == ")"[0]) {
            addToken(TokenType.rparen);
            parenLevel--;
            if (!stringParenLevels.empty && stringParenLevels[$ - 1] == parenLevel) {
                addTokenInplace(TokenType.stringLiteral);
                stringParenLevels = stringParenLevels[0 .. $ - 1];
                stepStringLiteral;
            }
        }
        else if (ch == "."[0]) addToken(TokenType.dot);
        else if (ch == ","[0]) addToken(TokenType.comma);
        else if (ch == "`"[0]) addToken(TokenType.backtick);
        else if (ch == ":"[0]) addToken(TokenType.colon);
        else if (ch == ";"[0]) addToken(TokenType.semicolon);
        else if (ch == "<"[0]) addToken(TokenType.smaller);
        else if (ch == ">"[0]) addToken(TokenType.greater);
        else if (ch == "="[0]) addToken(TokenType.equal);
        else if (ch == "!"[0]) addToken(TokenType.exclamationmark);
        else if (ch == "?"[0]) addToken(TokenType.questionmark);
        else if (ch == "\$"[0]) addToken(TokenType.dollar);
        else if (ch == "["[0]) addToken(TokenType.lsquarebracket);
        else if (ch == "]"[0]) addToken(TokenType.rsquarebracket);
        else if (ch == "{"[0]) addToken(TokenType.lcurlybracket);
        else if (ch == "}"[0]) addToken(TokenType.rcurlybracket);
        else if (ch == "+"[0]) addToken(TokenType.plus);
        else if (ch == "-"[0]) addToken(TokenType.minus);
        else if (ch == "*"[0]) addToken(TokenType.asterisk);
        else if (ch == "/"[0]) addToken(TokenType.slash);
        else if (ch == "\\"[0]) addToken(TokenType.backslash);
        else if (ch == "^"[0]) addToken(TokenType.circumflex);
        else if (ch == "%"[0]) addToken(TokenType.percent);
        else if (ch == "~"[0]) addToken(TokenType.tilde);
        else if (ch == "&"[0]) addToken(TokenType.ampersand);
        else if (ch == "|"[0]) addToken(TokenType.bar);
        else {
            print("TODO $(cast(int) ch)");
            assert(false);
        }
    }
    addTokenInplace(TokenType.end);
    return result[0 .. resultIdx];
}

bool isAlpha(char ch) return ch >= "a"[0] && ch <= "z"[0] || ch >= "A"[0] && ch <= "Z"[0];
bool isNumeric(char ch) return ch >= "0"[0] && ch <= "9"[0];
bool isAlnum(char ch) return ch.isAlpha || ch.isNumeric;
bool isWhitespace(char ch) return ch == " "[0] || ch == "\t"[0] || ch == "\r"[0] || ch == "\n"[0];
bool isUtf8MbStart(char ch) return ch >= 0x80;

private (string | fail Error) annotate(string text) {
    import std.string : split;

    mut auto tokens = text.tokenize("")?;
    mut string annot;
    mut int pos = 0;

    while (pos < text.length) {
        while (!tokens.empty && tokens[0].pos < pos)
            tokens = tokens[1 .. $];
        if (!tokens.empty && tokens[0].pos == pos)
            version (firstpass)
                annot ~= "$(cast(int) tokens[0].type)";
            else
                annot ~= tokens[0].type.toString.front + "A"[0] - "a"[0];
        else
            annot ~= " ";
        if (text[pos] < 0b1000_0000) pos += 1;
        else if (text[pos] < 0b1110_0000) pos += 2;
        else if (text[pos] < 0b1111_0000) pos += 3;
        else pos += 4;
    }
    return annot;
}

unittest {
    assert(
        "assert(sin(Ï€) == 0);".annotate ==
        "I     LI  LIRWEEWNRS");
}

