module neat.class_;

macro import package(compiler).std.macro.listcomprehension;
macro import package(compiler).std.macro.once;
macro import package(compiler).std.macro.quasiquoting;

import backend.base;
import helpers;
import neat.array;
import neat.base;
import neat.either;
import neat.expr;
import neat.function_;
import neat.struct_;
import neat.types;
import neat.util;
import polyhash;

class ClassMethod : Function
{
    Protection protection;

    bool override_;

    bool abstract_;

    this(ClassType classType, this.locRange, this.protection, this.override_, this.abstract_, this.name,
         this.retWIP, this.params, this.statement, this.macroState, this.parent)
    {
        this.hasThisArg = true;
        this.contextType = classType;
        resetMangleCache;
    }

    override string manglePrefix()
    {
        return "$(parent.mangle)_$(this.contextType.instanceOf(ClassType).class_.name)";
    }

    Type funcPtrType()
    {
        auto params = [Parameter.fromType(this.contextType.instanceOf(ClassType))] ~ this.params;
        return new FunctionPointer(this.ret, params);
    }
}

class IntfMethod : FunctionDeclaration
{
    this(IntfType intfType, this.name, this.retWIP, this.params)
    {
        this.contextType = intfType;
    }

    override string mangle()
    {
        // TODO mangle types
        return this.contextType.instanceOf(IntfType).intf.name ~ "_" ~ this.name;
    }

    Type funcPtrType()
    {
        auto params = [Parameter.fromType(this.contextType.instanceOf(IntfType))] ~ this.params;
        return new FunctionPointer(this.ret, params);
    }
}

class ClassNamespace : Namespace
{
    ClassType class_;

    this(this.parent, this.class_) { this.isContextScope = true; }

    override (nullable Symbol | fail Error) lookup(
        string name, Context context, LookupReason reason, LocRange locRange)
    {
        if (auto thisPtr = context.framePointer) {
            auto thisPtr = new PointerCast(this.class_, thisPtr);

            if (reason != LookupReason.ufcs) {
                if (auto result = context.compiler.accessMemberWithLifetime(
                        context, thisPtr, name, locRange, true)?)
                    return result;
            }
        }

        // TODO "outer"?
        if (!this.parent) return null;
        return this.parent.lookup(name, context.withFramePointer(null), reason, locRange);
    }
}

/**
 * Class layout:
 * - super class data OR
 *   - vtable ptr
 *   - reference count
 * - class data
 * - interface pointers
 *
 * Note: Class is *not* a type, because compiling it involves some funky magic that requires
 * mutating class state and is awkward,
 * so we cannot also dup it for "nullable Class" because then we wouldn't be able to handle these changes.
 * So this is what goes on: Class is wrapped by ClassType, which is what "ClassName" resolves to.
 * Class declarations reference Class. ClassType has nullability.
 */
class Class
{
    string name;

    bool final_; // methods may not be overridden

    bool abstract_; // may contain abstract methods

    nullable Class superClass;

    Intf[] superIntfs;

    // will resolve members and methods as required
    ASTClassDecl decl;

    nullable Namespace namespace;

    (string name, Protection protection, Type type)[] members;

    ClassMethod[] methods;

    (ClassMethod | (:baseOffset, size_t offset))[] vtable; // methods appearing in the classinfo struct

    string vtableSymbol;

    (void | fail Error) result;

    string mangledName;

    Hash cachedHash;

    /**
     * dataStruct takes the form:
     * {
     *   {super data}
     *   {my own data}
     *   {interface slots}
     * }
     */
    Struct dataStruct;

    this(this.decl, this.superClass, this.superIntfs, this.namespace)
    {
        if (superClass && superClass.final_) {
            print("$(decl.locRange.repr): cannot subclass a final class");
            print("this is a compiler error, as it should have been caught earlier");
            exit(1);
        }
        assert(!!decl);
        this.name = decl.name;
        this.final_ = decl.final_;
        this.abstract_ = decl.abstract_;
        this.mangledName = namespace.mangle ~ "_class_" ~ this.name;
        // TODO this is *wildly* insufficient!
        this.cachedHash = new Hash;
        this.cachedHash.adds("Class " ~ this.mangledName);
        this.cachedHash.addl(this.members.length);
        for (member in this.members) {
            this.cachedHash.adds(member.name);
            this.cachedHash.addl(cast(int) member.protection);
            member.type.hash(this.cachedHash);
        }
        if (this.superClass)
            this.cachedHash.applyHash(this.superClass.cachedHash);
    }

    (void | fail Error) resolve(Context context)
    {
        // TODO compilation stage enum
        if (this.vtableSymbol != "") return this.result;
        this.result = this.decl.compile2(context, this);
        return this.result;
    }

    bool same(Class other)
    {
        return this.mangledName == other.mangledName;
    }

    void initDataStruct(Context context)
    {
        mut StructMemberDeclaration[] structMembers;
        if (this.superClass) {
            this.superClass.initDataStruct(context);
            structMembers ~= new StructMemberDeclaration(
                "super", Protection.public_, this.superClass.dataStruct);
        } else {
            structMembers ~= new StructMemberDeclaration(
                "super", Protection.public_, new Struct("nothing", [], this.decl.locRange, this.mangledName));
        }

        StructMemberDeclaration[] dataMembers() {
            StructMemberDeclaration toMember(typeof(this.members[0]) entry) {
                return new StructMemberDeclaration(entry.name, entry.protection, entry.type);
            }
            if (!this.superClass) {
                return [
                    new StructMemberDeclaration("__classinfo", Protection.private_, once new Pointer(new Void)),
                    new StructMemberDeclaration("__refs", Protection.private_, context.nativeWordType),
                ] ~ [a.toMember for a in this.members];
            }
            return [a.toMember for a in this.members];
        }
        structMembers ~= new StructMemberDeclaration(
            "data", Protection.public_, new Struct("data", dataMembers, this.decl.locRange, this.mangledName));

        StructMemberDeclaration[] intfSlots() {
            int slots = [sum i.slots for i in this.superIntfs];
            mut StructMemberDeclaration[] ret;
            for (i in 0 .. slots)
                ret ~= new StructMemberDeclaration(
                    "__$(name)_islot$i", Protection.public_, once new Pointer(new Void));
            return ret;
        }
        structMembers ~= new StructMemberDeclaration(
            "islots", Protection.public_, new Struct("islots", intfSlots, this.decl.locRange, this.mangledName));

        this.dataStruct = new Struct("", structMembers, this.decl.locRange, this.mangledName);
    }

    Struct classInfoStructCache;

    Struct classInfoStruct(Context context)
    {
        if (classInfoStructCache) {
            assert(classInfoStructCache.members.length == vtable.length);
            return classInfoStructCache;
        }

        StructMemberDeclaration transform(typeof(vtable[0]) entry) {
            auto sizeT = context.nativeWordType;
            return entry.case(
                ClassMethod method: new StructMemberDeclaration(method.name, Protection.public_, method.funcPtrType),
                (:baseOffset, size_t offset): new StructMemberDeclaration("", Protection.public_, sizeT));
        }

        auto vtableMembers = [transform(entry) for entry in vtable];
        classInfoStructCache = new Struct("", vtableMembers, this.decl.locRange, this.mangledName);
        return classInfoStructCache;
    }

    // FIXME: roll into vtable(), this.vtable => this.vtableCache
    (void | fail Error) genVtable(Context context)
    {
        if (this.vtableSymbol != "") return;

        assert(this.vtable.length == 0);

        // Ensure these two are added first.
        this.methods = [
            this.genInstanceofMethod(context),
            this.genReleaseMethod(context)] ~ this.methods;

        mut (ClassMethod | IntfMethod | (:baseOffset, size_t offset))[] vtable;
        if (this.superClass) {
            this.superClass.genVtable(context)?;
            for (a in this.superClass.vtable)
                vtable ~= a;
            vtable[0] = this.methods[0];
            vtable[1] = this.methods[1];
        } else {
            vtable ~= this.methods[0];
            vtable ~= this.methods[1];
        }
        int wordSize = context.nativeWordType.emit(context.platform).size(context.platform);
        // offset of intf slots in this class
        mut size_t baseOffset = this.dataStruct.emit(context.platform).memberOffset(2, context.platform);
        for (intf in this.superIntfs) {
            intf.genVtable;
            for (entry in intf.vtable) {
                entry.case {
                    IntfMethod method: vtable ~= method;
                    (:baseOffset): { // one per slot
                        vtable ~= (:baseOffset, baseOffset);
                        baseOffset += wordSize;
                    }
                }
            }
        }

        auto supervtable = vtable.dup;
        mut typeof(vtable) addedMethods;
        for (ClassMethod method in this.methods) {
            // TODO match types
            bool isCtor = method.name == "__ctor"; // workaround: no final yet, no proper masking yet
            /*
            string repr(typeof(vtable[0]) entry) {
                return entry.case(
                    ClassMethod classMethod: "ClassMethod($(classMethod.name))",
                    IntfMethod intfMethod: "IntfMethod($(intfMethod.name))",
                    (:baseOffset, size_t offset): "baseOffset($offset)");
            }
            print("$(this.name): debug: vtable = " ~ [join ", " e.repr for e in vtable]);
            */
            // ctor is always called static
            if (isCtor) {
                addedMethods ~= method;
                continue;
            }

            auto similarEntries = findSimilarEntries(supervtable, method);
            if (!similarEntries.empty) {
                auto bestEntry = [argmin(a.flaws) a for a in similarEntries];
                if (bestEntry.flaws == 0) {
                    method.locRange.assert(method.override_,
                        "Expected 'override' attribute for overriding method.")?;
                } else {
                    vtable[bestEntry.offset].case {
                        ClassMethod classMethod: validateOverride(classMethod, method)?;
                        IntfMethod intfMethod: validateOverride(intfMethod, method)?;
                        (:baseOffset, size_t offset): assert(false);
                    }
                    assert(false); // whence flaws if validateOverride passes?
                }
                vtable[bestEntry.offset] = method;
                continue;
            }

            method.locRange.assert(!method.override_,
                "'override' specified but method does not override a parent method.")?;
            // print("b: $(this.name): vtable[$(vtable.length)] = $(method.name)");
            addedMethods ~= method;
        }
        vtable ~= addedMethods;

        if (!this.abstract_) {
            for (auto method in vtable) {
                method.case {
                    ClassMethod method: {
                        if (method.abstract_)
                            return this.decl.locRange.fail(
                                "Abstract method '$(method.name)' not overridden in non-abstract class $(this.name)");
                    }
                    IntfMethod method: {
                        return this.decl.locRange.fail(
                            "Interface method '$(method.name)' not overridden in non-abstract class $(this.name)");
                    }
                    (:baseOffset, size_t offset): { }
                }
            }
        }
        (ClassMethod | (:baseOffset, size_t)) filter(typeof(vtable[0]) entry) {
            entry.case {
                ClassMethod m: return m;
                IntfMethod m: assert(false);
                (:baseOffset, size_t offset) pair: return pair;
            }
        }
        this.vtable = [filter(a) for a in vtable];
        this.vtableSymbol = this.mangledName ~ "_vtable";
    }

    (void | fail Error) validateOverride(FunctionDeclaration parent, ClassMethod child)
    {
        child.locRange.assert4(parent.params.length == child.params.length,
            "Override expected ", ltoa(parent.params.length), " arguments, not ", ltoa(child.params.length))?;
        // return type is covariant
        child.locRange.assert4(child.ret.isStrictSubtypeOf(parent.ret),
            "child return type must be strict subtype of parent return type: ",
            child.ret.repr, " and ", parent.ret.repr)?;
        for (i, parentParam in parent.params) {
            auto childParam = child.params[i];
            child.locRange.assert(parentParam.mutable == childParam.mutable,
                "parameter mutability must match between base method and override")?;
            // parameters are contravariant
            child.locRange.assert4(parentParam.type.isStrictSubtypeOf(childParam.type),
                "child argument type must be strict supertype of parent argument type: ",
                childParam.type.repr, " and ", parentParam.type.repr)?;
        }
    }

    /**
     * Find class methods that are almost, but not necessarily quite like `child`.
     * This method effectively guesses which parent method you may have meant to override.
     */
    (size_t offset, int flaws)[] findSimilarEntries(
        (ClassMethod | IntfMethod | (:baseOffset, size_t offset))[] vtable, ClassMethod child)
    {
        bool sameName(typeof(vtable[0]) entry) {
            return entry.case(
                ClassMethod classMethod: classMethod.name == child.name,
                IntfMethod intfMethod: intfMethod.name == child.name,
                (:baseOffset, size_t offset): false);
        }
        mut (size_t offset, int flaws)[] matches;
        for (i, a in vtable) {
            /**
             * TODO:
             * auto parent = a.case(ClassMethod..., IntfMethod..., (:baseOffset, size_t offset): continue);
             * ie. make return, continue and break expressions of type bottom.
             */
            mut uninitialized FunctionDeclaration parent;
            a.case {
                ClassMethod classMethod: parent = classMethod;
                IntfMethod intfMethod: parent = intfMethod;
                (:baseOffset, size_t offset): continue;
            }
            if (parent.name != child.name) continue;
            if (parent.params.length != child.params.length) continue;
            mut int flaws = 0;
            if (!child.ret.isStrictSubtypeOf(parent.ret)) flaws++;
            for (i, parentParam in parent.params) {
                if (parentParam.mutable != child.params[i].mutable) flaws++;
                if (!parentParam.type.isStrictSubtypeOf(child.params[i].type)) flaws++;
            }
            matches ~= (i, flaws);
        }
        return matches;
    }

    void declare(Generator generator)
    {
        if (generator.mod.declared(vtableSymbol))
            return;

        generator.mod.declareSymbolList(vtableSymbol, vtable.length);
    }

    void define(Generator generator)
    {
        (string | size_t) transform(typeof(vtable[0]) entry) {
            entry.case {
                ClassMethod method: {
                    method.declare(generator);
                    return method.mangle;
                }
                (:baseOffset, size_t offset): return offset;
            }
        }
        auto backendVtable = [transform(entry) for entry in vtable];

        generator.mod.defineSymbolList(vtableSymbol, backendVtable);
    }

    ClassMethod genInstanceofMethod(Context context)
    {
        mut ASTStatement[] castStmts;
        castStmts ~= context.compiler.$stmt
            import package(compiler).neat.runtime : neat_runtime_refcount_inc, neat_runtime_refcount_dec;;
        mut nullable Class current = this;
        while (current)
        {
            auto classType = new ClassType(current.notNull, zeroInitializable=false);
            auto classinfo = new ASTSymbolHelper(new ClassInfo(classType));
            castStmts ~= context.compiler.$stmt if (targetClassinfo is $classinfo) {
                void* voidPtr = this;
                return voidPtr;
            };
            // TODO allow recursion in nested fn
            mut void delegate(Intf) recurse;
            void recurse_(Intf intf) {
                auto intfType = new IntfType(intf, zeroInitializable=false);
                auto astIntf = new ASTSymbolHelper(intfType);
                auto intfClassinfo = new ASTSymbolHelper(new ClassInfo(intfType));
                castStmts ~= context.compiler.$stmt if (targetClassinfo is $intfClassinfo) {
                    $astIntf intf = this;
                    void* voidPtr = intf;
                    return voidPtr;
                };
                for (superIntf in intf.superIntfs) {
                    recurse(superIntf);
                }
            }
            recurse = &recurse_;
            for (superIntf in current.superIntfs) {
                recurse(superIntf);
            }
            current = current.superClass;
        }
        castStmts ~= context.compiler.$stmt {
            if (freeOnNull) {
                __destroy(this);
            }
            return null;
        };
        auto stmt = context.compiler.astSequence(castStmts, __RANGE__);

        auto classType = new ClassType(this, zeroInitializable=false);
        auto methodNamespace = new ClassNamespace(this.namespace, classType);
        auto params = [
            Parameter.simple("targetClassinfo", once new Pointer(new Void)),
            Parameter.simple("freeOnNull", once new Boolean),
        ];
        return new ClassMethod(
            classType, __RANGE__, Protection.public_, override_=true, abstract_=false, "__instanceof",
            once new Pointer(new Void), params,
            stmt, new MacroState, methodNamespace);
    }

    ClassMethod genReleaseMethod(Context context)
    {
        mut ASTStatement[] statements;
        // FIXME self-recursion in nested function
        mut void delegate(Class) recurse;
        void recurse_(Class self) {
            if (auto superClass = self.superClass) recurse(superClass);
            for (member in self.members) {
                auto name = context.compiler.astIdentifier(member.name, __RANGE__);
                statements ~= context.compiler.$stmt __destroy($name);;
            }
        }
        recurse = &recurse_;
        recurse(this);
        auto stmt = context.compiler.astSequence(statements, __RANGE__);

        auto classType = new ClassType(this, zeroInitializable=false);
        auto methodNamespace = new ClassNamespace(this.namespace, classType);
        return new ClassMethod(
            classType, __RANGE__, Protection.public_, override_=true, abstract_=false, "__destroy",
            once new Void, [], stmt, new MacroState, methodNamespace);
    }
}

class ClassType : Type
{
    string mangledName;

    Class class_;

    this(this.class_, this.zeroInitializable) {
        if (this.zeroInitializable)
            this.mangledName = "nullable_" ~ this.class_.mangledName;
        else this.mangledName = this.class_.mangledName;
        this.hasElaborateCopyConstructor = true;
    }

    ClassType makeNullable() {
        if (this.zeroInitializable) return this;
        return new ClassType(this.class_, zeroInitializable=true);
    }

    ClassType makeNotNullable() {
        if (!this.zeroInitializable) return this;
        return new ClassType(this.class_, zeroInitializable=false);
    }

    nullable ClassType superClass() {
        if (auto superClass = this.class_.superClass)
            return new ClassType(superClass, zeroInitializable=false);
        return null;
    }

    IntfType[] superIntfs() {
        return [new IntfType(a, zeroInitializable=false) for a in this.class_.superIntfs];
    }

    override nullable Expression implicitConvertFrom(Context context, Expression from)
    {
        // upcast
        if (from.type.instanceOf(ClassType))
        {
            mut nullable ClassType currentClass = from.type.instanceOf(ClassType);

            while (currentClass)
            {
                // Class implconv to nullable Class
                if (currentClass.same(this) || currentClass.makeNullable.same(this))
                {
                    return new PointerCast(this, from);
                }
                currentClass = currentClass.superClass;
            }
        }
        // = null
        if (from.type.instanceOf(NullPointer) && this.zeroInitializable)
        {
            return new NullExpr(this);
        }
        return null;
    }

    override BackendType emit(Platform platform)
    {
        return platform.voidp;
    }

    override string mangle() {
        return this.mangledName;
    }

    override (nullable Expression | fail Error) truthy(Context context, Expression value, LocRange locRange)
    {
        (Expression | fail Error) do_(Expression value) {
            Type voidp = once new Pointer(new Void);

            return .truthy2(new PointerCast(voidp, value), context, locRange);
        }
        return context.compiler.consume(context, value, &do_);
    }

    override Protection protectionAt(Namespace namespace)
    {
        bool sameAsThis(Namespace current) {
            if (auto provenance = current.instanceOf(ClassNamespace)) {
                if (same(provenance.class_)) return true;
            }
            if (auto parent = current.parent) return sameAsThis(parent);
            return false;
        }
        if (sameAsThis(namespace)) return Protection.private_;
        // TODO implement protected
        return Protection.public_;
    }

    override (nullable Symbol | fail Error) accessMember(
        Context context, nullable Expression baseExpr, string member, Protection protection, LocRange locRange)
    {
        bool allowed(Protection symbol) {
            int rank(Protection p) {
                if (p == Protection.public_) return 0;
                if (p == Protection.protected_) return 1;
                return 2;
            }
            return rank(symbol) <= rank(protection);
        }
        bool test(typeof(this.class_.vtable[0]) entry, bool mustInThisClass) {
            if (mustInThisClass) {
                return entry.case(
                    ClassMethod m: m.name == member && m.contextType.same(this) && allowed(m.protection),
                    (:baseOffset, size_t offset): false);
            }
            return entry.case(
                ClassMethod m: m.name == member && allowed(m.protection),
                (:baseOffset, size_t offset): false);
        }
        // if we have methods of the requested name in this class, use them preferentially.
        size_t[] methods() {
            auto methodsInThisClass = [i for i, a in this.class_.vtable where test(a, mustInThisClass=true)];
            if (!methodsInThisClass.empty) return methodsInThisClass;
            return [i for i, a in this.class_.vtable where test(a, mustInThisClass=false)];
        }
        auto methods = methods;
        if (!methods.empty) {
            // FIXME implicit typed array literal
            // Symbol[] symbols = [
            //     new ClassMethodSymbol(this.class_, baseExpr.notNull, methodIndex, staticLookup=false)
            //     for methodIndex in methods];
            Symbol[] symbols = [
                (new ClassMethodSymbol(this.class_, baseExpr.notNull, methodIndex, staticLookup=false))
                    .instanceOf(Symbol)
                    .notNull
                for methodIndex in methods];
            if (symbols.length == 1) return symbols[0];
            return new Overload(symbols);
        }

        if (!baseExpr) return null;

        // FIXME self-recursion in nested function
        mut nullable Symbol delegate(Class) recurse;
        nullable Symbol recurse_(Class self) {
            size_t memberOffset = [first i for i, m in self.members where m.name == member && allowed(m.protection) else -1];
            if (memberOffset != -1) {
                Reference asStruct = context.compiler.dereference(
                    new PointerCast(new Pointer(self.dataStruct), baseExpr.notNull));
                // select "data" substruct
                auto dataMember = new StructMemberReference(asStruct, 1);
                // select member field
                Reference memberField() {
                    if (self.superClass)
                        return new StructMemberReference(dataMember, memberOffset);
                    // skip classinfo and refs
                    return new StructMemberReference(dataMember, memberOffset + 2);
                }
                // Ephemeral because it's mutable.
                return new InfoReference(memberField, mutable=true, info=ExprInfo(Lifetime.ephemeral));
            }
            if (auto superClass = self.superClass) {
                return recurse(superClass);
            }
            return null;
        }
        recurse = &recurse_;
        return recurse(this.class_);
    }

    override nullable Expression implicitConvertTo(Context context, Expression from, Type to)
    {
        // (void*) class
        auto voidp = once new Pointer(new Void);

        // disabled cause cast() now tries to implcast first
        // and we need `cast(void*) obj` (leaking!) for `once` macro.
        // we still need proper errors
        // TODO maybe a dedi keyword for leaking a reference to C?
        /*if (to.same(voidp) && from.info.lifetime == Lifetime.gifted)
        {
            print("cannot convert temporary expression to void* - where would the reference go?");
            // TODO return (Expression | Error)
            assert(false);
        }*/
        if (to.same(voidp) && from.info.lifetime != Lifetime.gifted)
        {
            return new PointerCast(voidp, from);
        }
        return null;
    }

    override bool same(Type other) {
        if (auto otherClass = other.instanceOf(ClassType)) {
            return this.class_.same(otherClass.class_)
                && this.zeroInitializable == otherClass.zeroInitializable;
        }
        return false;
    }

    override string repr() {
        if (this.zeroInitializable) return "nullable $(this.class_.name)";
        return this.class_.name;
    }

    override void hash(Hash hash) {
        hash.applyHash(this.class_.cachedHash);
    }

    override (Expression | fail Error) copy(Context context, Expression source)
    {
        (nullable Expression | fail Error) do_(Expression source) {
            mut auto context = context;
            auto voidp = new Pointer(new Void);
            auto refCountIncFun = once new FunctionDeclaration(
                "neat_runtime_class_refcount_inc", new Void, [
                    Parameter.simple("ptr", voidp)]);
            context = context.withNamespace(context.compiler.exprAlias(
                context.namespace, "this", source));
            context = context.withNamespace(context.compiler.exprAlias(
                        context.namespace, "neat_runtime_class_refcount_inc", refCountIncFun));

            auto astCall = context.compiler.$stmt neat_runtime_class_refcount_inc(cast(void*) this);;

            return context.compiler.statementExpression(astCall.compile(context)?.statement, source);
        }
        return context.compiler.exprWithTemporaryExpr(context.getUniqueId, source, &do_)?.notNull;
    }

    override nullable Statement endLifetime(Context context, Expression expr)
    {
        (nullable Statement | fail Error) do_(Expression expr) {
            mut auto context = context;
            auto sizeT = context.nativeWordType;
            context = context.withNamespace(
                context.compiler.exprAlias(context.namespace, "this", expr));
            context = context.withNamespace(
                context.compiler.exprAlias(context.namespace, "size_t", sizeT));

            // TODO do in __destroy() once we have function imports
            auto freeFun = once new FunctionDeclaration(
                "free", new Void, [Parameter.simple("ptr", new Pointer(new Void))]);
            auto refCountDecFun = once new FunctionDeclaration(
                "neat_runtime_class_refcount_dec", new Integer, [
                    Parameter.simple("ptr", new Pointer(new Void))]);

            context = context.withNamespace(context.compiler.exprAlias(
                        context.namespace, "neat_runtime_class_refcount_dec", refCountDecFun));
            auto stmt = context.compiler.$stmt neat_runtime_class_refcount_dec(cast(void*) this);;
            return stmt.compile(context)?.statement;
        }
        return context.compiler.stmtWithTemporaryExpr(context.getUniqueId, expr, &do_).case(
            nullable Statement res: res.notNull,
            Error err: exitWithError!Statement(err));
    }

    override (nullable Expression | fail Error) binaryOp(
        Context context, string op, Expression lhs, Expression rhs, LocRange locRange)
    {
        if (op == "==") {
            mut auto rhs = rhs;
            if (auto converted = context.compiler.implicitConvertTo(context, rhs, lhs.type)) {
                rhs = converted;
            } else {
                return null;
            }
            return context.compiler.binaryOp(
                "==", context,
                new PointerCast(once new Pointer(new Void), lhs),
                new PointerCast(once new Pointer(new Void), rhs),
                __RANGE__);
        }
        return null;
    }
}

/**
 * Interface layout:
 * - vtable pointer
 * Vtable layout:
 * - EITHER OF
 *   - class base offset
 *   - primary super interface layout
 * - secondary super interface layouts
 * - own methods
 */
class Intf
{
    string name;

    Intf[] superIntfs;

    // FIXME do we need this?
    ASTIntfDecl decl;

    nullable Namespace namespace;

    IntfMethod[] methods; // methods declared in this intf

    (IntfMethod | :baseOffset)[] vtable; // layout of the classinfo subsection generated for this intf

    // TODO eventually string name will go in here for .classinfo.name
    string classInfoSymbol;

    (void | fail Error) result;

    string mangledName;

    PolyHash mangledHash;

    this(this.decl, this.superIntfs, this.namespace)
    {
        assert(!!decl);
        this.name = decl.name;
        this.mangledName = namespace.mangle ~ "_intf_" ~ this.name;
        this.mangledHash = new PolyHash("Intf" ~ this.mangledName);
    }

    public int slots() {
        // FIXME self-recursion in nested function
        mut int delegate(Intf) recurse;
        int recurse_(Intf current) {
            if (current.superIntfs.length == 0) return 1;
            return [sum recurse(i) for i in current.superIntfs];
        }
        recurse = &recurse_;
        return recurse(this);
    }

    (void | fail Error) resolve(Context context)
    {
        // TODO compilation stage enum
        if (this.classInfoSymbol != "") return result;
        this.result = this.decl.compile2(context, this);
        return this.result;
    }

    Struct intfVtableStructCache;

    Struct intfVtableStruct(Context context)
    {
        assert(this.classInfoSymbol != "");

        if (intfVtableStructCache) {
            assert(intfVtableStructCache.members.length == vtable.length);
            return intfVtableStructCache;
        }

        auto sizeT = context.nativeWordType;
        StructMemberDeclaration transform(typeof(vtable[0]) entry) {
            return entry.case(
                IntfMethod m: new StructMemberDeclaration(m.name, Protection.public_, m.funcPtrType),
                (:baseOffset): new StructMemberDeclaration("basePtr", Protection.public_, sizeT));
        }
        auto vtableMembers = [transform(method) for method in vtable];

        intfVtableStructCache = new Struct("", vtableMembers, this.decl.locRange, this.mangledName);
        return intfVtableStructCache;
    }

    // FIXME: roll into vtable(), this.vtable => this.vtableCache
    void genVtable()
    {
        if (this.classInfoSymbol != "") return;

        assert(this.vtable.length == 0);

        if (this.superIntfs.length == 0) {
            this.vtable ~= :baseOffset;
        } else {
            for (superIntf in this.superIntfs) {
                superIntf.genVtable;
                this.vtable ~= [a for a in superIntf.vtable]; // dup
            }
        }
        for (method in this.methods)
            this.vtable ~= method;
        /*
        string repr(typeof(vtable[0]) entry) {
            return entry.case(
                IntfMethod intfMethod: "IntfMethod($(intfMethod.name))",
                (:baseOffset): "baseOffset()");
        }
        print("$(this.name): debug: vtable = " ~ [join ", " e.repr for e in vtable]);
        */
        this.classInfoSymbol = this.mangledName ~ "_classinfo";
    }

    void declare(Generator generator)
    {
        if (generator.mod.declared(classInfoSymbol))
            return;

        generator.mod.declareSymbolList(classInfoSymbol, 0);
    }

    void define(Generator generator)
    {
        // placeholder to ensure a symbol with a unique id is emitted
        mut (string | size_t)[] classinfo;
        classinfo ~= cast(size_t) this;

        generator.mod.defineSymbolList(classInfoSymbol, classinfo);
    }
}

/**
 * Like ClassType, IntfType is split off from Intf to allow setting nullable with makeNullable.
 * This is not necessary, as opposed to ClassType, IntfType does not need any mutable state.
 * But it's easier to understand and remember if they're consistent.
 */
class IntfType : Type
{
    Intf intf;

    this(this.intf, this.zeroInitializable) {
        this.hasElaborateCopyConstructor = true;
    }

    override string mangle() {
        if (this.zeroInitializable)
            return "nullable_" ~ this.intf.mangledName;
        return this.intf.mangledName;
    }

    IntfType[] superIntfs() {
        return [new IntfType(a, zeroInitializable=false) for a in this.intf.superIntfs];
    }

    IntfType makeNullable() {
        if (this.zeroInitializable) return this;
        return new IntfType(this.intf, zeroInitializable=true);
    }

    IntfType makeNotNullable() {
        if (!this.zeroInitializable) return this;
        return new IntfType(this.intf, zeroInitializable=false);
    }

    // get slot pointer of target in our hierarchy
    // if not found, return the number of bases traversed
    private (Expression | int) getSlot(IntfType target, Expression islotTablePtr, mut int base) {
        // FIXME self-recursion in nested function
        mut int delegate(IntfType) recurse;
        int recurse_(IntfType current) {
            // implconv intf to nullable intf
            if (current.same(target) || current.makeNullable.same(target)) return base;
            if (current.superIntfs.length == 0) {
                base += 1;
                return -1;
            }
            for (superIntf in current.superIntfs) {
                int ret = superIntf.recurse;
                if (ret != -1) return ret;
            }
            return -1;
        }
        recurse = &recurse_;
        int slot = recurse(this);
        if (slot != -1) {
            auto basePtr = new PointerCast(once new Pointer(new Pointer(new Void)), islotTablePtr);
            return new PointerCast(target, new PointerOffset(basePtr, new IntLiteral(slot)));
        }
        return base;
    }

    override (nullable Expression | fail Error) truthy(Context context, Expression value, LocRange locRange)
    {
        (Expression | fail Error) do_(Expression value) {
            Type voidp = once new Pointer(new Void);

            return .truthy(context, new PointerCast(voidp, value), locRange);
        }
        return context.compiler.consume(context, value, &do_);
    }

    override (nullable Symbol | fail Error) accessMember(
        Context context, nullable Expression baseExpr, string member, Protection _, LocRange locRange)
    {
        bool nameMatches(typeof(this.intf.vtable[0]) entry) {
            return entry.case(
                IntfMethod m: m.name == member,
                (:baseOffset): false);
        }
        size_t methodOffset = [first i for i, a in this.intf.vtable where nameMatches(a) else -1];
        if (methodOffset != -1)
        {
            return new IntfMethodSymbol(this, baseExpr.notNull, methodOffset);
        }
        return null;
    }

    override nullable Expression implicitConvertFrom(Context context, Expression from)
    {
        // upcast
        if (from.type.instanceOf(ClassType)) {
            mut nullable ClassType currentClass = from.type.instanceOf(ClassType);
            while (currentClass) {
                auto asStructRef = new Dereference(new PointerCast(
                    new Pointer(currentClass.class_.dataStruct), from));
                auto islotTablePtr = new ReferenceExpression(new StructMemberReference(asStructRef, 2));

                // Count up slot base over all interfaces.
                mut int base = 0;
                for (intfType in currentClass.superIntfs) {
                    intfType.getSlot(this, islotTablePtr, base).case {
                        Expression expr: return expr;
                        int newBase: base = newBase;
                    }
                }
                currentClass = currentClass.superClass;
            }
            return null;
        }
        if (auto intfType = from.type.instanceOf(IntfType)) {
            intfType.getSlot(this, from, 0).case {
                Expression expr: return expr;
                int newBase: { }
            }
        }
        // = null
        if (from.type.instanceOf(NullPointer) && this.zeroInitializable)
        {
            return new NullExpr(this);
        }
        return null;
    }

    override nullable Expression implicitConvertTo(Context context, Expression from, Type to)
    {
        // (void*) class
        auto voidp = once new Pointer(new Void);
        if (to.same(voidp) && from.info.lifetime != Lifetime.gifted)
        {
            return new PointerCast(voidp, from);
        }
        return null;
    }

    override BackendType emit(Platform platform)
    {
        return platform.voidp;
    }

    override bool same(Type other) {
        if (auto otherIntf = other.instanceOf(IntfType)) {
            // TODO module
            return otherIntf.intf.name == this.intf.name
                && otherIntf.zeroInitializable == this.zeroInitializable;
        }
        return false;
    }

    override string repr() {
        if (this.zeroInitializable) return "nullable $(this.intf.name)";
        return this.intf.name;
    }

    override void hash(Hash hash) {
        hash.apply(intf.mangledHash.add, intf.mangledHash.mult);
    }

    override (Expression | fail Error) copy(Context context, Expression source)
    {
        mut Context context = context;
        (nullable Expression | fail Error) do_(Expression source) {
            auto sizeT = context.nativeWordType;
            auto refCountIncFun = new FunctionDeclaration(
                "neat_runtime_refcount_inc", new Void, [
                    Parameter.simple("label", new Array(new Character, context.platform)),
                    Parameter.simple("ptr", new Pointer(new Void))]);

            // why do we need to ignore lifetime? what actually eats a lifetime here??
            context = context.withNamespace(context.compiler.exprAlias(
                context.namespace, "this",
                new OverrideLifetimeExpr(source, ExprInfo(Lifetime.permanent))));
            context = context.withNamespace(
                context.compiler.exprAlias(context.namespace, "size_t", sizeT));
            context = context.withNamespace(context.compiler.exprAlias(
                        context.namespace, "neat_runtime_refcount_inc", refCountIncFun));
            context = context.withNamespace(context.compiler.exprAlias(
                        context.namespace, "inc_name", new StringLiteral("inc " ~ this.intf.name, context.platform)));

            auto incref = context.compiler.$stmt
            if (!!this) {
                auto baseOffset = **cast(size_t**) this;
                auto object = &(cast(char*) this)[-baseOffset];
                neat_runtime_refcount_inc(inc_name, &(cast(size_t*) object)[1]);
            };
            return context.compiler.statementExpression(
                incref.compile(context)?.statement,
                source);
        }
        return context.compiler.exprWithTemporaryExpr(context.getUniqueId, source, &do_)?.notNull;
    }

    override nullable Statement endLifetime(Context context, Expression expr)
    {
        mut Context context = context;
        // disable lifetime management
        // (otherwise we get an infinite cycle when the compiler
        // tries to clean up 'this' after the __destroy() call by
        // ending its lifetime (ad infinitum).
        auto tempThis = new PairedTemporaryExpr(expr.type, Lifetime.permanent, context.getUniqueId);
        auto initTemp = new InitializeTemporaryExprStatement(tempThis, expr);

        auto sizeT = context.nativeWordType;
        context = context.withNamespace(
            context.compiler.exprAlias(context.namespace, "this", tempThis));
        context = context.withNamespace(
            context.compiler.exprAlias(context.namespace, "size_t", sizeT));

        // TODO do in __destroy() once we have function imports
        auto freeFun = once new FunctionDeclaration(
            "free", new Void, [Parameter.simple("ptr", new Pointer(new Void))]);
        auto refCountDecFun = new FunctionDeclaration(
            "neat_runtime_refcount_dec", new Integer, [
                Parameter.simple("label", new Array(new Character, context.platform)),
                Parameter.simple("ptr", new Pointer(new Void))]);

        context = context.withNamespace(context.compiler.exprAlias(
                    context.namespace, "free", freeFun));
        context = context.withNamespace(context.compiler.exprAlias(
                    context.namespace, "neat_runtime_refcount_dec", refCountDecFun));
        context = context.withNamespace(context.compiler.exprAlias(
                    context.namespace, "dec_name", new StringLiteral("dec " ~ this.intf.name, context.platform)));
        auto stmt = context.compiler.$stmt
            if (!!this) {
                auto baseOffset = **cast(size_t**) this;
                auto object = &(cast(char*) this)[-baseOffset];
                if (neat_runtime_refcount_dec(dec_name, &(cast(size_t*) object)[1]))
                {
                    // manually call __destroy method, second entry in the object vtable
                    auto fn = (*cast(void function(void*)**) object)[1];
                    fn(object);
                    free(object);
                }
            };
        stmt.compile(context).case {
            StatementCompileResult res:
                return context.compiler.sequence(initTemp, res.statement);
            Error err: assert(false);
        }
    }

    override (nullable Expression | fail Error) binaryOp(
        Context context, string op, Expression lhs, Expression rhs, LocRange locRange)
    {
        if (op == "==") {
            mut auto rhs = rhs;
            if (auto converted = context.compiler.implicitConvertTo(context, rhs, lhs.type)) {
                rhs = converted;
            } else {
                return null;
            }
            return context.compiler.binaryOp(
                "==", context,
                new PointerCast(once new Pointer(new Void), lhs),
                new PointerCast(once new Pointer(new Void), rhs),
                __RANGE__);
        }
        return null;
    }
}

/// Checks that first is a Liskov-substitutable subtype of second (without implicit conversion).
/// This is the sense in which two classes are substitutable in parameters or return types.
bool isStrictSubtypeOf(Type first, Type second)
{
    mut nullable ClassType firstClass = first.instanceOf(ClassType), secondClass = second.instanceOf(ClassType);
    if (firstClass && secondClass)
    {
        // TODO check interface slots here once that's a thing (count distance from each root parent?)
        while (firstClass)
        {
            if (firstClass.same(secondClass)) return true;
            firstClass = firstClass.superClass;
        }
        return false;
    }
    mut nullable Either firstEither = first.instanceOf(Either), secondEither = second.instanceOf(Either);
    if (firstEither && secondEither) {
        return firstEither.types.length == secondEither.types.length
            && [all firstEither.types[i].type.isStrictSubtypeOf(secondEither.types[i].type)
                for i in 0 .. firstEither.types.length];
    }
    return first.same(second);
}

class ClassMethodSymbol : LateSymbol
{
    Class class_; // TODO does this cause a ref cycle? remove?

    Expression baseExpr;

    size_t methodOffset;

    // We somehow selected a method of a specific class. Bypass vtable lookup.
    // For instance, used for super methods.
    bool staticLookup;

    this(this.class_, this.baseExpr, this.methodOffset, this.staticLookup) {}

    override LateSymbolResult resolve(Context context) {
        auto tmpBaseExpr = new PairedTemporaryExpr(baseExpr.type, Lifetime.ephemeral, context.getUniqueId);
        auto setup = new InitializeTemporaryExprStatement(tmpBaseExpr, baseExpr);

        mut nullable Statement teardown = null;
        if (baseExpr.info.lifetime == Lifetime.gifted) {
            teardown = baseExpr.type.endLifetime(context, tmpBaseExpr);
        }

        mut uninitialized Expression funcPtr;
        if (this.class_.final_ || this.staticLookup) {
            this.class_.vtable[methodOffset].case {
                ClassMethod method: funcPtr = new FunctionReference(method);
                (:baseOffset, size_t offset): assert(false);
            }
        } else {
            Reference classInfo = context.compiler.dereference(context.compiler.dereference(new PointerCast(
                new Pointer(new Pointer(class_.classInfoStruct(context))),
                tmpBaseExpr)));
            Expression funcPtrValue = new StructMemberReference(classInfo, methodOffset);
            auto funcPtrType = funcPtrValue.type.instanceOf(FunctionPointer);

            auto funcPtrWithVoidpThis = new FunctionPointer(funcPtrType.ret, [param for param in funcPtrType.params]);
            funcPtrWithVoidpThis.params[0] = Parameter.fromType(once new Pointer(new Void));
            funcPtr = new PointerCast(funcPtrWithVoidpThis, funcPtrValue);
        }

        return LateSymbolResult(setup=setup, funcPtr=funcPtr, firstArg=tmpBaseExpr, teardown=teardown);
    }

    override string repr() {
            this.class_.vtable[this.methodOffset].case {
                ClassMethod method: return "$(method.name)()";
                (:baseOffset, size_t offset): assert(false);
            }
    }
}

class IntfMethodSymbol : LateSymbol
{
    IntfType intfType; // TODO does this cause a ref cycle? remove?

    Expression baseExpr;

    // methodOffset includes base offsets.
    size_t methodOffset;

    this(this.intfType, this.baseExpr, this.methodOffset) {}

    override LateSymbolResult resolve(Context context) {
        auto tmpBaseExpr = new PairedTemporaryExpr(baseExpr.type, Lifetime.ephemeral, context.getUniqueId);
        auto setup = new InitializeTemporaryExprStatement(tmpBaseExpr, baseExpr);
        Reference classInfo = context.compiler.dereference(context.compiler.dereference(new PointerCast(
            new Pointer(new Pointer(this.intfType.intf.intfVtableStruct(context))),
            tmpBaseExpr)));
        Expression funcPtrValue = new StructMemberReference(classInfo, methodOffset);
        auto funcPtr = funcPtrValue.type.instanceOf(FunctionPointer);

        auto funcPtrWithVoidpThis = new FunctionPointer(funcPtr.ret, [param for param in funcPtr.params]);
        funcPtrWithVoidpThis.params[0] = Parameter.fromType(once new Pointer(new Void));
        auto funcPtrValue = new PointerCast(funcPtrWithVoidpThis, funcPtrValue);

        auto astBaseExpr = new ASTSymbolHelper(tmpBaseExpr);
        auto astObjectPtr = context.compiler.$expr ({
            auto baseOffset = **cast(size_t**) $astBaseExpr;
            &(cast(char*) $astBaseExpr)[-baseOffset];
        });

        mut nullable Statement teardown = null;
        if (baseExpr.info.lifetime == Lifetime.gifted) {
            teardown = baseExpr.type.endLifetime(context, tmpBaseExpr);
        }

        // gather errors
        (Expression | Error) do_() {
            return astObjectPtr.compile(context)?.beExpression(__RANGE__)?;
        }
        do_.case {
            Expression expr:
                return LateSymbolResult(setup=setup, funcPtr=funcPtrValue, firstArg=expr, teardown=teardown);
            Error err: assert(false);
        }
    }
    override string repr() return "TODO IntfMethodSymbol";
}

struct ASTClassDeclMember
{
    Protection protection;

    string name;

    ASTSymbol type;

    LocRange locRange;
}

struct ASTClassDeclMethod
{
    Protection protection;

    bool override_;

    bool abstract_;

    string name;

    ASTSymbol ret;

    (ASTParameter | ASTThisAssignment)[] params;

    LocRange locRange;

    string comment;

    ASTStatement body_;
}

class ASTClassVersionBlock
{
    string name;
    ASTClassEntry[] then, else_;
    this(this.name, this.then, this.else_) { }
}

alias ASTClassEntry = (ASTClassDeclMember | ASTClassDeclMethod | ASTDeclaration | ASTClassVersionBlock);

class ASTClassDecl : ASTSymbolDeclaration
{
    ASTSymbol[] supers;

    bool final_;

    bool abstract_;

    ASTClassEntry[] members;

    MacroState macroState;

    string comment;

    this(this.name, this.supers, this.final_, this.abstract_,
         this.members, this.macroState, this.locRange, this.comment) { }

    override (ClassType | fail Error) compileSymbol(Context context)
    {
        mut nullable Class superClass = null;
        mut Intf[] superIntfs = [];
        for (i, super_ in this.supers) {
            auto superObj = super_.compile(context)?;
            auto superClassTest = superObj.instanceOf(ClassType);
            if (i == 0 && superClassTest) {
                // first super may be a class
                superClass = superClassTest.class_;
            } else {
                // all others must be intfs
                auto superIntf = superObj.instanceOf(IntfType);
                super_.locRange.assert(!!superIntf, "super type is not an interface")?;
                superIntfs ~= superIntf.intf;
            }
        }
        return new ClassType(new Class(this, superClass, superIntfs, context.namespace),
            zeroInitializable=false);
    }

    (void | fail Error) compile2(Context context, Class target)
    {
        auto classType = new ClassType(target, zeroInitializable=false);
        auto classScope = context.compiler.symbolAlias(context.namespace, target.name, classType);

        mut Context currentContext = context.withNamespace(classScope);
        mut (string name, Protection protection, Type type)[] memberFields;
        // Do those later; they need fields resolved for this.field assignments.
        mut (ASTClassDeclMethod method, Context context)[] lateMemberMethods;

        (void | fail Error) walk(ASTClassEntry entry) {
            entry.case {
                ASTClassDeclMember member: {
                    auto type = member.type.compile(currentContext)?.beType(member.locRange)?;
                    memberFields ~= (member.name, member.protection, type);
                }
                ASTClassDeclMethod method: {
                    lateMemberMethods ~= (method, currentContext);
                }
                /**
                 * Note: currentContext gets overwritten even in version blocks,
                 * because version blocks *don't* open a scope.
                 */
                ASTDeclaration astDecl:
                    currentContext = currentContext.withNamespace(
                        astDecl.compile(currentContext)?);
                ASTClassVersionBlock ver:
                    if ([any a == ver.name for a in context.platform.versions]) {
                        [walk(entry)? for entry in ver.then];
                    } else {
                        [walk(entry)? for entry in ver.else_];
                    }
            }
        }
        [walk(a)? for a in this.members];

        target.members = memberFields;

        target.methods = new ClassMethod[](lateMemberMethods.length);
        target.initDataStruct(context);
        for (i, entry in lateMemberMethods) {
            ASTClassDeclMethod method = entry.method;
            auto methodContext = entry.context;
            // TODO types?
            auto paramContext = methodContext.withLabelPrefix(
                "$(context.namespace.mangle)_$(target.name)_$(method.name)");

            auto methodParams = new Parameter[](method.params.length);
            for (k, param in method.params) {
                param.case {
                    ASTThisAssignment param:
                        nullable Type findType(Class self) {
                            if (auto superClass = self.superClass)
                                if (auto ret = findType(superClass))
                                    return ret;
                            return [first m.type for m in self.members where m.name == param.name else null];
                        }
                        auto type = findType(target);
                        param.locRange.assert2(!!type, "no such member: ", param.name)?;
                        auto type = type.notNull;
                        methodParams[k] = .compile(param, type, paramContext)?;
                    ASTParameter param:
                        methodParams[k] = .compile(param, paramContext)?;
                }
            }

            auto classType = new ClassType(target, zeroInitializable=false);
            auto methodNamespace = new ClassNamespace(currentContext.namespace, classType);
            target.methods[i] = new ClassMethod(
                classType,
                method.locRange,
                method.protection,
                method.override_,
                method.abstract_,
                method.name,
                method.ret.compile(methodContext)?.beType(method.locRange)?,
                methodParams,
                method.body_,
                this.macroState,
                methodNamespace);
        }
        target.genVtable(currentContext)?;
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTClassDecl'!"); assert(false); }
}

struct ASTIntfDeclMethod
{
    string name;

    ASTSymbol ret;

    ASTParameter[] params;

    LocRange locRange;
}

class ASTIntfDecl : ASTSymbolDeclaration
{
    ASTSymbol[] superIntfs;

    (ASTIntfDeclMethod | ASTDeclaration)[] members;

    MacroState macroState;

    this(this.name, this.superIntfs, this.members, this.macroState, this.locRange) { }

    override (IntfType | fail Error) compileSymbol(Context context)
    {
        mut Intf[] superIntfs = [];
        if (this.superIntfs.length > 0) {
            for (superIntf in this.superIntfs) {
                auto superIntfSym = superIntf.compile(context)?;
                superIntf.locRange.assert(!!superIntfSym, "super interface not found")?;
                auto superIntfType = superIntfSym.instanceOf(IntfType);
                superIntf.locRange.assert(!!superIntfType, "super interface is not an interface")?;
                superIntfs ~= superIntfType.intf;
            }
        }
        return new IntfType(
            new Intf(this, superIntfs, context.namespace),
            zeroInitializable=false);
    }

    (void | fail Error) compile2(Context context, Intf target)
    {
        auto intfType = new IntfType(target, zeroInitializable=false);
        auto intfScope = context.compiler.symbolAlias(context.namespace, target.name, intfType);

        mut Context currentContext = context.withNamespace(intfScope);

        for (member in this.members) {
            member.case {
                ASTIntfDeclMethod method: {
                    auto methodParams = new Parameter[](method.params.length);
                    for (k, param in method.params) {
                        methodParams[k] = Parameter(
                            false,
                            param.name,
                            param.mutable,
                            type=param.type.compile(currentContext)?.beType(param.locRange)?,
                            null);
                    }

                    target.methods ~= new IntfMethod(
                        intfType,
                        method.name,
                        method.ret.compile(currentContext)?.beType(method.locRange)?,
                        methodParams);
                }
                ASTDeclaration astDecl: {
                    currentContext = currentContext.withNamespace(
                        astDecl.compile(currentContext)?);
                }
            }
        }

        target.genVtable;
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTIntfDecl'!"); assert(false); }
}

(nullable ASTSymbolDeclaration | fail Error) parseClassDecl(Parser parser, LexicalContext lexicalContext)
{
    mut bool classAbstract = false;
    mut bool classFinal = false;
    parser.begin;
    auto comment = parser.parseLastComment;
    auto from = parser.from;
    while (true) {
        if (parser.acceptIdentifier("abstract")) {
            classAbstract = true;
            continue;
        }
        if (parser.acceptIdentifier("final")) {
            classFinal = true;
            continue;
        }
        break;
    }
    if (!parser.acceptIdentifier("class"))
    {
        parser.revert;
        return null;
    }
    parser.commit;

    string name = parser.parseIdentifier;
    auto locRange = parser.to(from);

    (nullable ASTSymbolDeclaration | fail Error) parseRest() {
        mut ASTSymbol[] supers;
        if (parser.acceptToken(TokenType.colon)) {
            while (true) {
                auto super_ = lexicalContext.compiler.parseType(parser, lexicalContext)?;
                parser.assert_(!!super_, "expected super class identifier")?;
                supers ~= super_.notNull;
                if (parser.acceptToken(TokenType.comma)) continue;
                break;
            }
        }

        mut ASTClassEntry[] members;
        parser.expectToken(TokenType.lcurlybracket)?;
        while (!parser.acceptToken(TokenType.rcurlybracket)) {
            (void | fail Error) do_() {
                members ~= parseClassEntry(parser, lexicalContext, name)?;
            }
            parser.verifyTransactions("parse rule imbalance", &do_)?;
        }
        return new ASTClassDecl(
            name, supers, classFinal, classAbstract,
            members, lexicalContext.macroState, locRange, comment);
    }
    if (auto ret = lexicalContext.compiler.parseTemplateStub(parser, lexicalContext, name, comment, &parseRest)?)
        return ret;
    return parseRest?;
}

(ASTClassEntry[] | fail Error) parseClassEntry(Parser parser, LexicalContext lexicalContext, string className)
{
    if (parser.acceptIdentifier("version")) {
        mut ASTClassEntry[] then, else_;
        parser.expectToken(TokenType.lparen)?;
        string versionStr = parser.parseIdentifier;
        parser.expectToken(TokenType.rparen)?;
        if (parser.acceptToken(TokenType.lcurlybracket)) {
            while (!parser.acceptToken(TokenType.rcurlybracket)) {
                then ~= parser.parseClassEntry(lexicalContext, className)?;
            }
        } else {
            then ~= parser.parseClassEntry(lexicalContext, className)?;
        }
        if (parser.acceptIdentifier("else")) {
            if (parser.acceptToken(TokenType.lcurlybracket)) {
                while (!parser.acceptToken(TokenType.rcurlybracket)) {
                    else_ ~= parser.parseClassEntry(lexicalContext, className)?;
                }
            } else {
                else_ ~= parser.parseClassEntry(lexicalContext, className)?;
            }
        }
        // FIXME explicitly type hinted literal
        ASTClassEntry result = new ASTClassVersionBlock(versionStr, then, else_);
        return [result];
    }

    auto comment = parser.parseLastComment;
    auto from = parser.from;
    mut nullable ASTSymbol retType;
    mut string memberName;
    mut bool override_ = false;
    mut bool abstract_ = false;
    mut Protection protection = Protection.public_;
    while (true) {
        if (parser.acceptIdentifier("override")) {
            override_ = true;
            continue;
        }
        if (parser.acceptIdentifier("abstract")) {
            abstract_ = true;
            continue;
        }
        // FIXME only allow one
        // FIXME parseProtection?
        if (parser.acceptIdentifier("public")) {
            protection = Protection.public_;
            continue;
        }
        if (parser.acceptIdentifier("private")) {
            protection = Protection.private_;
            continue;
        }
        if (parser.acceptIdentifier("protected")) {
            protection = Protection.protected_;
            continue;
        }
        break;
    }

    if (auto decl = lexicalContext.compiler.parseDeclaration(parser, lexicalContext)?) {
        // TODO return [ASTClassEntry: decl];
        ASTClassEntry entry = decl;
        return [entry];
    }

    if (parser.acceptIdentifier("this"))
    {
        parser.assert_(!override_, "cannot override constructor")?;
        retType = new ASTIdentifier("void", false, __RANGE__);
        memberName = "__ctor";
    }
    else
    {
        retType = lexicalContext.compiler.parseType(parser, lexicalContext)?;
        parser.assert_(!!retType, "expected member type")?;
        string ident = parser.parseIdentifier;
        memberName = ident;
        parser.assert_(memberName.length > 0, "expected member name")?;
    }
    auto locRange = parser.to(from);
    if (parser.acceptToken(TokenType.lparen)) // method
    {
        auto params = parseParameterList(parser, lexicalContext, variadic=false, thisAssignment=true)?;
        assert(!params.variadic);
        mut nullable ASTStatement stmt = null;
        if (abstract_ && parser.acceptToken(TokenType.semicolon)) {
            ASTSymbol astName = new ASTStringLiteral(className ~ "." ~ memberName, __RANGE__);
            stmt = lexicalContext.compiler.$stmt {
                import package(compiler).neat.runtime.stdlib : exit;

                print("Error: " ~ $astName ~ ": called an unimplemented method!");
                exit(1);
            };
        } else {
            stmt = lexicalContext.compiler.parseFunctionBody(parser, lexicalContext)?;
        }
        ASTClassEntry entry = ASTClassDeclMethod(
            protection, override_, abstract_, memberName,
            retType.notNull, params.params, locRange, comment, stmt.notNull);
        return [entry];
    }
    else
    {
        mut ASTClassEntry[] members;
        (void | fail Error) addMember(LocRange locRange) {
            locRange.assert(!override_, "cannot override class member")?;
            locRange.assert(!abstract_, "cannot declare class member abstract")?;
            members ~= ASTClassDeclMember(protection, memberName, retType.notNull, locRange);
        }
        addMember(locRange)?;
        while (!parser.acceptToken(TokenType.semicolon)) {
            parser.expectToken(TokenType.comma)?;
            if (parser.acceptToken(TokenType.semicolon)) break;
            auto memberFrom = parser.from;
            string ident = parser.parseIdentifier;
            auto memberLocRange = parser.to(from);
            memberName = ident;
            memberLocRange.assert(memberName.length > 0, "expected member name")?;
            addMember(memberLocRange)?;
        }
        return members;
    }
}

(nullable ASTSymbolDeclaration | fail Error) parseIntfDecl(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto comment = parser.parseLastComment;
    auto from = parser.from;
    if (!parser.acceptIdentifier("interface"))
    {
        parser.revert;
        return null;
    }
    parser.commit;

    string name = parser.parseIdentifier;
    auto declLocRange = parser.to(from);

    (nullable ASTSymbolDeclaration | fail Error) parseRest() {
        mut ASTSymbol[] superIntfs;
        if (parser.acceptToken(TokenType.colon)) {
            while (true) {
                auto superIntf = lexicalContext.compiler.parseType(parser, lexicalContext)?;
                parser.assert_(!!superIntf, "expected super interface")?;
                superIntfs ~= superIntf.notNull;
                if (parser.acceptToken(TokenType.comma)) continue;
                break;
            }
        }
        mut (ASTIntfDeclMethod | ASTDeclaration)[] members;
        parser.expectToken(TokenType.lcurlybracket)?;
        while (!parser.acceptToken(TokenType.rcurlybracket))
        {
            auto from = parser.from;

            if (auto decl = lexicalContext.compiler.parseDeclaration(parser, lexicalContext)?) {
                members ~= decl;
                continue;
            }

            nullable ASTSymbol retType = lexicalContext.compiler.parseType(parser, lexicalContext)?;
            parser.to(from).assert(!!retType, "expected member type")?;
            string memberName = parser.parseIdentifier;
            parser.to(from).assert(memberName.length > 0, "expected member name")?;
            auto locRange = parser.to(from);
            parser.expectToken(TokenType.lparen)?;
            auto params = parseParameterList(parser, lexicalContext, variadic=false, thisAssignment=true)?;
            assert(!params.variadic);
            auto params = params.params;
            parser.expectToken(TokenType.semicolon)?;
            // TODO error on specific parameter
            locRange.assert(
                [all a.case(ASTParameter: true, ASTThisAssignment: false) for a in params],
                "no 'this.' in interface method")?;
            // FIXME bottom
            ASTParameter fail() { assert(false); }
            auto astParameters = [a.case(ASTParameter p: p, ASTThisAssignment: fail) for a in params];
            members ~= ASTIntfDeclMethod(memberName, retType.notNull, astParameters, locRange);
        }
        return new ASTIntfDecl(name, superIntfs, members, lexicalContext.macroState, declLocRange);
    }
    if (auto ret = lexicalContext.compiler.parseTemplateStub(parser, lexicalContext, name, comment, &parseRest)?)
        return ret;
    return parseRest?;
}

class ClassInfo : Expression
{
    (ClassType | IntfType) classType;

    this(this.classType) {
        this.type = once new Pointer(new Void);
        this.info = ExprInfo(Lifetime.permanent);
    }

    override int emit(Generator output)
    {
        this.classType.case {
            ClassType classType: {
                classType.class_.declare(output);
                return output.fun.symbolList(classType.class_.vtableSymbol);
            }
            IntfType intfType: {
                intfType.intf.declare(output);
                return output.fun.symbolList(intfType.intf.classInfoSymbol);
            }
        }
    }

    override void hash(Hash hash) {
        hash.adds("ClassInfo");
        classType.case {
            ClassType classType: classType.hash(hash);
            IntfType intfType: intfType.hash(hash);
        }
    }
    override string repr() return classType.case(ClassType c: c.repr, IntfType i: i.repr) ~ ".classinfo";
}

class NewClassExpression : Expression
{
    ClassType classType;

    this(this.classType) {
        this.type = this.classType;
        // the archetypal example
        this.info = ExprInfo(Lifetime.gifted);
    }

    override int emit(Generator output)
    {
        // oh boy!
        BackendType voidp = once (new Pointer(new Void)).emit(output.platform);
        BackendType sizeT = output.platform.nativeWordType;
        auto basicClassStruct = new BackendStructType([voidp, sizeT]);

        int classDataSize = this.classType.class_.dataStruct.emit(output.platform).size(output.platform);
        int classInfoPtr = (new ClassInfo(classType)).emit(output);
        int classPtr = output.fun.call(
            voidp, "neat_runtime_alloc", [output.fun.wordLiteral(output.platform, classDataSize)]);

        int classInfoTarget = output.fun.fieldOffset(basicClassStruct, classPtr, 0);
        output.fun.store(voidp, classInfoTarget, classInfoPtr);
        int refCount = output.fun.fieldOffset(basicClassStruct, classPtr, 1);
        int one = output.fun.wordLiteral(output.platform, 1);
        // write interface slot pointers
        for (int i, entry in classType.class_.vtable) {
            entry.case {
                ClassMethod method: continue;
                (:baseOffset, size_t offset): {
                    // void*[] class_islot1;
                    auto vtablePtrType = once new BackendPointerType(new BackendPointerType(new BackendVoidType));
                    // &class_islot1
                    auto interfaceSlot = output.fun.bitcast(
                        output.fun.ptrOffset(
                            once new BackendCharType,
                            classPtr,
                            output.fun.intLiteral(offset)),
                        once new BackendPointerType(vtablePtrType));

                    auto vtableOffset = output.fun.intLiteral(i);
                    auto vtableOffsetPtr = output.fun.ptrOffset(
                        once new BackendPointerType(new BackendVoidType),
                        classInfoPtr,
                        vtableOffset);

                    output.fun.store(
                        vtablePtrType,
                        interfaceSlot,
                        vtableOffsetPtr);
                }
            }
        }
        output.fun.call(
            once new BackendVoidType,
            "neat_runtime_refcount_set",
            [output.fun.bitcast(refCount, voidp), one]);

        return classPtr;
    }

    override void hash(Hash hash) { hash.adds("NewClassExpression"); classType.hash(hash); }
    override string repr() return "$(classType.repr).__new";
}

class ASTInstanceOf : ASTSymbol
{
    ASTSymbol base;

    ASTSymbol target;

    this(this.base, this.target, this.locRange) { }

    override (Symbol | fail Error) compile(Context context)
    {
        Expression base = this.base.compile(context)?.beExpressionImplCall(context, locRange)?;
        auto type = base.type;
        auto baseinfo = base.info;
        locRange.assert(
            type.instanceOf(ClassType) || type.instanceOf(IntfType),
            "Base of instanceOf must be class or interface.")?;
        (nullable Expression | fail Error) do_(Expression base) {
            auto targetSym = target.compile(context)?;
            nullable ClassType targetClass = targetSym.instanceOf(ClassType);
            nullable IntfType targetIntf = targetSym.instanceOf(IntfType);
            locRange.assert(targetClass || targetIntf, "Target of instanceOf must be class or interface.")?;
            if (targetClass) {
                // might be in a template instantiated with targetClass!
                auto targetClassModule = findParent!ModuleBase(targetClass.class_.namespace);

                context.compilingModule.addModuleDependency(targetClassModule.notNull);
                if (auto classType = type.instanceOf(ClassType))
                    checkDyncastValidity(fromClass=classType.class_, toClass=targetClass.class_, this.locRange)?;
            }
            Type target() {
                // instanceof can return null
                if (targetClass) return targetClass.makeNullable;
                else return targetIntf.makeNullable;
            }
            Expression classInfo() {
                if (auto targetClass = targetClass) return new ClassInfo(targetClass);
                else if (auto targetIntf = targetIntf) return new ClassInfo(targetIntf);
                else assert(false);
            }
            ASTSymbol astTarget = new ASTSymbolHelper(target);
            ASTSymbol astClassInfo = new ASTSymbolHelper(classInfo);

            // disable lifetime accounting for this call
            auto plainBase = new OverrideLifetimeExpr(base, ExprInfo(Lifetime.permanent));
            bool freeOnNull = baseinfo.lifetime == Lifetime.gifted;
            auto astFreeOnNull = context.compiler.astBoolLiteral(freeOnNull, __RANGE__);

            if (type.instanceOf(IntfType)) {
                auto astBase = new ASTSymbolHelper(plainBase);
                auto instanceOfExpr = context.compiler.$expr ({
                    auto baseOffset = **cast(size_t**) $astBase;
                    auto object = &(cast(char*) $astBase)[-baseOffset];
                    // vtable 0 is always instanceof
                    auto fn = (*cast($astTarget function(void*, void*, bool)**) object)[0];
                    fn(object, $astClassInfo, $astFreeOnNull);
                });
                if (auto ret = instanceOfExpr.compile(context)?.beExpression(__RANGE__)?)
                    return new OverrideLifetimeExpr(ret, baseinfo);
                return null;
            }

            // must exist.
            Symbol instanceOf = context.compiler.accessMember(
                    context, plainBase, "__instanceof", locRange, false)?
                .notNull;
            auto astInstanceOf = new ASTSymbolHelper(instanceOf);
            auto astArgs = [ASTArgument(astClassInfo, "", __RANGE__), ASTArgument(astFreeOnNull, "", __RANGE__)];
            auto ret = new PointerCast(target, context.compiler.call(
                    context, astInstanceOf, astArgs, locRange, false)?
                .notNull);

            // reuse ownership accounting of source
            return new OverrideLifetimeExpr(ret, baseinfo);

        }
        return context.compiler.exprWithTemporaryExpr(context.getUniqueId, base, &do_)
            .case(nullable Expression expr: expr.notNull, Error err: err);
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTInstanceOf'"); assert(false); }
}

/**
 * fromClass must be a supertype of toClass; else, due to single class inheritance,
 * this cast is impossible.
 */
(void | fail Error) checkDyncastValidity(Class fromClass, Class toClass, LocRange locRange)
{
    locRange.assert(
        toClass.hasAsParent(fromClass) || fromClass.hasAsParent(toClass),
        "$(fromClass.name) can never cast to $(toClass.name)")?;
}

bool hasAsParent(Class class_, Class parent)
{
    if (class_.same(parent)) return true; // vacuous
    if (auto next = class_.superClass) return next.hasAsParent(parent);
    return false;
}

(nullable ASTSymbol | fail Error) parseInstanceOf(Parser parser, LexicalContext lexicalContext, ASTSymbol left)
{
    parser.begin;
    auto from = parser.from;
    if (!(parser.acceptToken(TokenType.dot) && parser.acceptIdentifier("instanceOf")))
    {
        parser.revert;
        return null;
    }
    parser.expectToken(TokenType.lparen)?;
    nullable ASTSymbol type = lexicalContext.compiler.parseType(parser, lexicalContext)?;
    parser.expectToken(TokenType.rparen)?;
    parser.commit;
    return new ASTInstanceOf(left, type.notNull, parser.to(from));
}

class ASTNewExpression : ASTSymbol
{
    ASTSymbol type;

    ASTArgument[] astArgs;

    this(this.type, this.astArgs, this.locRange) { }

    override (Symbol | fail Error) compile(Context context)
    {
        Type type = this.type.compile(context)?.beType(this.locRange)?;

        if (auto classType = type.instanceOf(ClassType)) {
            Expression classptr = new NewClassExpression(classType);

            this.locRange.assert2(!!classType, "expected new <class>, not %s", type.repr)?;

            (nullable Expression | fail Error) do_(Expression classptr) {
                // don't clean up classptr after constructor call, we're continuing its lifetime
                nullable Symbol ctor = context.compiler.accessMember(
                    context,
                    new OverrideLifetimeExpr(classptr, ExprInfo(Lifetime.permanent)),
                    "__ctor", this.locRange, false)?;
                assert(!!ctor);
                auto astCtor = new ASTSymbolHelper(ctor.notNull);
                auto ctorCall = context.compiler.exprStatement(
                        context.compiler.call(context, astCtor, this.astArgs, this.locRange, false)?
                    .notNull);

                return context.compiler.statementExpression(ctorCall, classptr);
            }
             return context.compiler.exprWithTemporaryExpr(context.getUniqueId, classptr, &do_)?.notNull;
        }
        if (auto arrayType = type.instanceOf(Array)) {
            this.locRange.assert(this.astArgs.length == 1, "expected one argument to array constructor")?;

            Type sizeT = context.nativeWordType;
            auto length = expectImplicitConvertTo(
                context,
                this.astArgs[0].sym.compile(context)?.beExpressionImplCall(context, this.locRange)?,
                sizeT,
                this.locRange)?;
            return new ArrayAllocation(arrayType.elementType, length, context.platform);
        }
        this.locRange.assert2(false, "don't know how to allocate ", type.repr)?;
    }

    override ASTSymbol quote(Quoter quoter) {
        auto quotedArgs = [
            quoter.compiler.astCall(
                quoter.compiler.astIdentifier("ASTArgument", locRange), [
                    arg.sym.quote(quoter),
                    quoter.compiler.astStringLiteral(arg.name, locRange),
                    quoter.quoteLocRange(arg.locRange)], locRange)
            for arg in this.astArgs];
        return quoter.compilerCall("astNewExpression", [
            this.type.quote(quoter),
            quoter.compiler.astArrayLiteral(quotedArgs, locRange)], locRange);
    }
}

class Super : Symbol
{
    ClassType classType;

    this(this.classType) { }

    (Symbol | fail Error) lookup(Context context, string name, LocRange locRange) {
        auto superClass = this.classType.class_.superClass.notNull;
        bool matches(typeof(this.classType.class_.vtable[0]) entry) {
            return entry.case(
                ClassMethod m: m.name == name,
                (:baseOffset, size_t offset): false);
        }
        auto methodOffset = [first i for i, a in superClass.vtable where matches(a) else -1];
        locRange.assert3(methodOffset != -1, "Method '", name, "' not found in super class!")?;
        auto baseExpr = context.namespace.lookup("this", context, LookupReason.identifier, locRange)?
            .instanceOf(Expression)
            .notNull;
        return new ClassMethodSymbol(superClass, baseExpr, methodOffset, staticLookup=true);
    }

    override string repr() return "super";
}

/**
 * The 'super' keyword. Only supports the syntax `super.foo` to select a superclass method statically.
 */
class ASTSuper : ASTSymbol
{
    this(this.locRange) { }

    override (Symbol | fail Error) compile(Context context) {
        auto classNs = findParent!ClassNamespace(context.namespace);
        locRange.assert(!!classNs, "'super' may only appear in class")?;
        locRange.assert(!!classNs.class_.superClass, "'super' may only appear in class that has parent class")?;
        return new Super(classNs.class_);
    }

    override ASTSymbol quote(Quoter quoter) {
        ASTArgument[] noArgs; // hax: [] can't convert to an Either of two arrays
        return quoter.compiler.astNewExpression(
            quoter.compiler.astIdentifier("ASTSuper", __RANGE__), noArgs, __RANGE__);
    }

    override string repr() { return "super"; }
}

class ASTNullable : ASTSymbol
{
    ASTSymbol next;

    // true = nullable, false = nonnullable
    bool nullify;

    this(this.next, this.nullify, this.locRange) { }

    override (Symbol | fail Error) compile(Context context) {
        auto next = this.next.compile(context)?.beType(this.locRange)?;
        if (nullify) {
            if (auto classType = next.instanceOf(ClassType))
                return classType.makeNullable;
            else if (auto intfType = next.instanceOf(IntfType))
                return intfType.makeNullable;
        } else {
            if (auto classType = next.instanceOf(ClassType))
                return classType.makeNotNullable;
            else if (auto intfType = next.instanceOf(IntfType))
                return intfType.makeNotNullable;
        }
        context.assert2(false, this.locRange, "Cannot mark type as (non)nullable: $(next.repr)")?;
    }

    override ASTSymbol quote(Quoter quoter) {
        ASTSymbol quoteBool(bool b) {
            if (b) return quoter.compiler.astIdentifier("true", __RANGE__);
            return quoter.compiler.astIdentifier("false", __RANGE__);
        }
        return quoter.compilerCall("astNullable", [
            this.next.quote(quoter),
            quoteBool(this.nullify)], locRange);
    }

    override string repr() {
        if (nullify) return "nullable $(next.repr)";
        else return "nonnullable $(next.repr)";
    }
}
