module std.json.stream;

macro import std.json.macro;
macro import std.macro.assert;
macro import std.macro.easymacro;
macro import std.macro.quasiquoting;

import std.json;

alias JsonToken = (
    string |
    nullptr_t |
    bool |
    int |
    // double |
    :arrayStart |
    :arrayEnd |
    :objectStart |
    :objectEnd |
    :objectKey, string key
);

string repr(JsonToken token) {
    return token.case(
        string s: "\"$s\"",
        nullptr_t: "null",
        bool b: "$b",
        int i: "$i",
        :arrayStart: "[",
        :arrayEnd: "]",
        :objectStart: "{",
        :objectEnd: "}",
        (:objectKey, string key): "\"$key\":",
    );
}

abstract class JsonSource
{
    abstract JsonToken front();

    abstract void popFront();

    abstract bool empty();
}

abstract class JsonSink
{
    abstract void put(JsonToken token) {
        assert(false);
    }
}

class JsonValueSource : JsonSource
{
    alias StackEntry = (
        JSONValue |
        JSONValue[] |
        (string key, JSONValue value)[] |
        JSONValue, (string key, JSONValue value)[]);

    StackEntry mut[] stack;

    JsonToken front_;

    bool empty_;

    this(JSONValue value) {
        this.stack ~= value;
        this.empty_ = false;
        popFront;
    }

    override bool empty() => this.empty_;

    override JsonToken front() => front_;

    override void popFront() {
        if (this.stack.empty) {
            this.empty_ = true;
            return;
        }
        this.front_ = nextToken;
    }

    StackEntry head() => this.stack[$ - 1];

    void pop() {
        this.stack = this.stack[0 .. $ - 1];
    }

    JsonToken nextToken() {
        JsonToken transform(JSONValue value) {
            value.value.case {
                :false:
                    return false;
                :true:
                    return true;
                int i:
                    return i;
                string s:
                    return s;
                JSONValue[] array:
                    this.stack ~= array;
                    return :arrayStart;
                (string key, JSONValue value)[] obj:
                    this.stack ~= obj;
                    return :objectStart;
            }
        }
        head.case {
            JSONValue value:
                pop;
                return transform(value);
            JSONValue[] array:
                if (array.empty) {
                    pop;
                    return :arrayEnd;
                } else {
                    auto nextValue = array[0];
                    this.stack[$ - 1] = array[1 .. $];
                    return nextValue.transform;
                }
            (string key, JSONValue value)[] obj:
                if (obj.empty) {
                    pop;
                    return :objectEnd;
                } else {
                    auto nextEntry = obj[0];
                    this.stack[$ - 1] = (nextEntry.value, obj[1 .. $]);
                    return (:objectKey, nextEntry.key);
                }
            (JSONValue nextValue, (string key, JSONValue value)[] obj):
                this.stack[$ - 1] = obj;
                return nextValue.transform;
        }
    }
}

unittest
{
    import std.algorithm : array;

    auto value = JSONValue({"a": 3, "b": [4, 5, 6], "c": "Hello World"});
    auto source = new JsonValueSource(value);
    mut JsonToken[] tokens;
    while (!source.empty) {
        tokens ~= source.front;
        source.popFront;
    }
    assert(tokens == [
        :objectStart,
            (:objectKey, key="a"),
                3,
            (:objectKey, key="b"),
                :arrayStart,
                    4, 5, 6,
                :arrayEnd,
            (:objectKey, key="c"),
                "Hello World",
        :objectEnd,
    ]);
}

class JsonValueSink : JsonSink
{
    (JSONValue | :nothing | :error, string msg) value;

    (
        :array, JSONValue[] |
        :objectKey, (string, JSONValue)[] |
        :objectValue, string key, (string, JSONValue)[]
    ) mut[] stack;

    this() {
        this.value = :nothing;
    }

    override void put(JsonToken token) {
        // bleh... better way to abort puts?
        // TODO stdlib error type hierarchy
        this.value.case {
            (:error, string msg): return;
            JSONValue value:
                if (stack.empty) {
                    return error("multiple values in output stream");
                }
                stack[$ - 1].case {
                    (:array, JSONValue[] values):
                        stack[$ - 1] = (:array, values ~ value);
                        this.value = :nothing;
                    (:objectKey, (string, JSONValue)[]):
                        return error("invalid token order: got value but expected object key");
                    (:objectValue, string key, (string, JSONValue)[] values):
                        stack[stack.length - 1] = (:objectKey, values ~ (key, value));
                        this.value = :nothing;
                }
            :nothing: {}
        }
        token.case {
            string s: this.value = JSONValue(s);
            nullptr_t: this.value = JSONValue(null);
            bool b: this.value = JSONValue(b);
            int i: this.value = JSONValue(i);
            // double d: this.value = JSONValue(d);
            :arrayStart:
                this.stack ~= (:array, null);
            :arrayEnd:
                this.stack[$ - 1].case {
                    (:array, JSONValue[] values):
                        this.value = JSONValue(values);
                    (:objectKey, (string, JSONValue)[]):
                        return error("invalid token order: got ']' but expected object key");
                    (:objectValue, string key, (string, JSONValue)[]):
                        return error("invalid token order: got ']' but expected object value");
                }
                this.stack = this.stack[0 .. $ - 1];
            :objectStart:
                this.stack ~= (:objectKey, null);
            :objectEnd:
                this.stack[$ - 1].case {
                    (:array, JSONValue[]):
                        return error("invalid token order: got '}' but expected array value");
                    (:objectKey, (string, JSONValue)[] values):
                        this.value = JSONValue(values);
                    (:objectValue, string key, (string, JSONValue)[]):
                        return error("invalid token order: got '}' but expected object value");
                }
                this.stack = this.stack[0 .. $ - 1];
            (:objectKey, string key):
                this.stack[$ - 1].case {
                    (:array, JSONValue[] values):
                        return error("invalid token order: got '$key:' but expected array member");
                    (:objectKey, (string, JSONValue)[] values):
                        stack[$ - 1] = (:objectValue, key, values);
                    (:objectValue, string key, (string, JSONValue)[]):
                        return error("invalid token order: got '$key:' but expected object value");
                }
        }
    }

    void error(string msg) {
        this.value = (:error, msg);
    }
}

void encode(T)(T value, JsonSink sink) {
    macro {
        import neat.array;
        import neat.struct_;
        import neat.types;

        auto T = type("T")?;
        if (T.instanceOf(Integer) || T.instanceOf(Long) || T.instanceOf(Short) || T.instanceOf(Boolean)) {
            code { sink.put(value); }
        } else if (auto array_ = T.instanceOf(Array)) {
            if (array_.elementType.instanceOf(Character)) {
                code { sink.put(value); }
            } else {
                code {
                    sink.put(:arrayStart);
                    for (entry in value)
                        .encode(entry, sink);
                    sink.put(:arrayEnd);
                }
            }
        } else if (auto struct_ = T.instanceOf(Struct)) {
            code { sink.put(:objectStart); }
            for (member in struct_.members) {
                auto name = compiler.astIdentifier(member.name, __RANGE__);
                auto nameStr = compiler.astStringLiteral(member.name, __RANGE__);
                code {
                    sink.put((:objectKey, $nameStr));
                    .encode(value.$name, sink);
                }
            }
            code { sink.put(:objectEnd); }
        } else {
            return __RANGE__.fail("Don't know how to encode $(T.repr)");
        }
    }
}

///
unittest {
    auto sink = new JsonValueSink;
    5.encode(sink);
    assert(sink.value == JSONValue(5));
}

///
unittest {
    auto sink = new JsonValueSink;
    [2, 3].encode(sink);
    assert(sink.value == JSONValue([2, 3]));
}

///
unittest {
    struct S {
        int a;
        string[] b;
        bool c;
    }
    auto sink = new JsonValueSink;
    S(2, ["foo", "bar"], false).encode(sink);
    assert(sink.value == JSONValue({"a": 2, "b": ["foo", "bar"], "c": false}));
}

struct DecodeError
{
    string message;

    string toString() => "DecodeError($message)";
}

(T | fail DecodeError) decode(T)(JsonSource source) {
    if (source.empty) return DecodeError("end of input reached while decoding");
    auto token = source.front;
    source.popFront;
    macro {
        import neat.array;
        import neat.struct_;
        import neat.types;
        import neat.util : ASTSymbolHelper;

        auto T = type("T")?;
        if (T.instanceOf(Integer) || T.instanceOf(Long) || T.instanceOf(Short)) {
            code {
                token.case {
                    int i: return cast(T) i;
                    default: return DecodeError("expected integer, but got $(token.repr)");
                }
            }
        } else if (T.instanceOf(Boolean)) {
            code {
                token.case {
                    bool b: return b;
                    default: return DecodeError("expected boolean, but got $(token.repr)");
                }
            }
        } else if (auto array_ = T.instanceOf(Array)) {
            auto astElementType = new ASTSymbolHelper(array_.elementType);
            if (array_.elementType.instanceOf(Character)) {
                code {
                    token.case {
                        string s: return s;
                        default: return DecodeError("expected string, but got $(token.repr)");
                    }
                }
            } else {
                code {
                    if (token != :arrayStart)
                        return DecodeError("expected '[', but got $(token.repr)");
                    mut T result;
                    while (source.front != :arrayEnd) {
                        result ~= .decode!($astElementType)(source)?;
                    }
                    source.popFront;
                    return result;
                }
            }
        } else if (auto struct_ = T.instanceOf(Struct)) {
            code {
                if (token != :objectStart)
                    return DecodeError("expected '{', but got $(token.repr)");
            }
            mut ASTSymbol[] args;
            for (i, member in struct_.members) {
                auto astName = compiler.astStringLiteral(member.name, __RANGE__);
                auto astFieldType = new ASTSymbolHelper(member.type);
                auto astField = compiler.astIdentifier("field$i", __RANGE__);
                code { mut ($astFieldType | :none) $astField = :none; }
                args ~= compiler.$expr $astField.case(:none: return DecodeError("missing field $($astName)"));
            }
            code {
                while (true) {
                    source.front.case {
                        :objectEnd:
                            source.popFront;
                            break;
                        (:objectKey, string key):
                            source.popFront;
                            macro {
                                for (i, member in struct_.members) {
                                    auto astFieldType = new ASTSymbolHelper(member.type);
                                    auto astField = compiler.astIdentifier("field$i", __RANGE__);
                                    auto nameStr = compiler.astStringLiteral(member.name, __RANGE__);
                                    code {
                                        if (key == $nameStr) {
                                            $astField = .decode!($astFieldType)(source)?;
                                            continue;
                                        }
                                    }
                                }
                            }
                            return DecodeError("expected object member, but got $(token.repr)");
                        default:
                            return DecodeError("expected object key, but got $(token.repr)");
                    }
                }
            }
            auto call = compiler.(astCall(astIdentifier("T", __RANGE__), args, __RANGE__));
            code { return $call; }
        } else {
            return __RANGE__.fail("Don't know how to decode $(T.repr)");
        }
    }
}

///
unittest
{
    auto source = a => new JsonValueSource(a);

    assert(JSONValue(5).source.decode!int == 5);
    assert(JSONValue(true).source.decode!bool == true);
    assert(JSONValue("foo").source.decode!string == "foo");
    assert(JSONValue([2, 3, 4]).source.decode!(int[]) == [2, 3, 4]);
    assert(JSONValue(["foo", "bar"]).source.decode!(string[]) == ["foo", "bar"]);

    struct S {
        int a;
        string[] b;
        bool c;
        string toString() => "S($a, $b, $c)";
    }
    assert(JSONValue({"a": 2, "b": ["foo", "bar"], "c": false}).source.decode!S == S(2, ["foo", "bar"], false));
}
