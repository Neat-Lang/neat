// TODO reinline back into neat.base
module neat.errorhelper;

import backend.base;

class Error __errorclass
{
    LocRange[] stack;

    string msg;

    this(this.stack, this.msg) { }

    string toString() => "Error($msg)";
}

interface FileIdTable
{
    int toFileId(string filename);
    void setInheritedFileId(int id, string filename);
    string toFileName(int fileId);
    void pin(int fileId);
}

extern(C) void exit(int);

struct LocRange {
    int fileId;
    (int row, int column) from;
    (int row, int column) to;

    string repr(FileIdTable fileIdTable) {
        return "TODO";
        // return fileIdTable.toFileName(fileId) ~ ":" ~ itoa(from.row + 1) ~ ":" ~ itoa(from.column + 1);
    }

    string toString() {
        if (to.row || to.column) {
            return "[?$fileId]:$(from.row+1):$(from.column+1)..$(to.row+1):$(to.column+1)";
        }
        return "[?$fileId]:$(from.row+1):$(from.column+1)";
    }

    Error fail(string message) {
        return new Error([this], message);

    }

    // This should have been caught earlier.
    void hardCheck(bool flag, string message) {
        if (flag) return;
        print("$(toString): Internal compiler error!");
        print(message);
        exit(1);
    }

    bottom die(string message) {
        print("$(toString): Internal compiler error!");
        print(message);
        exit(1);
    }

    BackendLocation toBackendLoc(FileIdTable fileIdTable) {
        mut BackendLocation ret;
        ret.file = fileIdTable.toFileName(fileId);
        ret.line = from.row;
        ret.column = from.column;
        return ret;
    }

    (void | fail Error) assert(bool test, (string delegate!() | string) msg) {
        if (!test) return this.fail(msg.case(string delegate!() dg: dg()));
    }
}
