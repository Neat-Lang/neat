module neat.array;

macro import package(compiler).std.macro.hash;
macro import package(compiler).std.macro.once;
macro import package(compiler).std.macro.quasiquoting;

import backend.base;
import helpers;
import neat.base;
import neat.types;
import neat.util;
import polyhash;

/**
 * There are two things called "array": T[] and the data structure it references.
 * We will call the first an "array value" and the second the "array object".
 *
 * Array values have the following layout:
 * {
 *      size_t length;
 *      T* ptr;
 *      T* base;
 * }
 *
 * Array objects have the following layout:
 * {
 *      size_t references;
 *      size_t capacity; // total length
 *      size_t used; // length in use (used for realloc)
 * }
 * They are then followed directly by the array data.
 */
class Array : Type
{
    (Type | PendingSymbol) pendingElementType;

    bool mutableElements;

    BackendType backendType;

    this(this.pendingElementType, Platform platform, this.mutableElements=false) {
        this.zeroInitializable = true;
        this.hasElaborateCopyConstructor = true;
        BackendType mut[] types = new BackendType mut[](3);
        types[0] = platform.nativeWordType;
        // No Element type here; there would be an infinite recursion with self-referential types like JSONValue.
        types[1] = platform.voidp;
        types[2] = platform.voidp;
        this.backendType = new BackendStructType(types.freeze, internal=true);
    }

    Type elementType() {
        Type resolvePending(PendingSymbol s) {
            // BIG TODO: What exactly is supposed to happen in the Error case here?!
            // Can we find a better way to maybe avoid running into that
            // class ErrorType : Type seems like admitting defeat.
            // Maybe like a class PendingSymbolSet, that gathers them all during compilation (in context?)
            // we're gonna need context downmerging anyway, for stackframes
            s.resolve.case {
                Symbol sym: sym.beType.case {
                    Type type: return type;
                    Error err: assert(false);
                }
                Error err: assert(false);
            }
        }
        return this.pendingElementType.case(
            Type t: t,
            PendingSymbol s: resolvePending(s)
        );
    }

    override BackendType emit(Platform platform)
    {
        return this.backendType;
    }

    override bool same(Type other)
    {
        if (auto otherArray = other.instanceOf(Array)) {
            return otherArray.elementType.same(this.elementType)
                && otherArray.mutableElements == this.mutableElements;
        }
        return false;
    }

    override string repr() {
        if (this.mutableElements)
            return this.elementType.repr ~ " mut[]";
        return this.elementType.repr ~ "[]";
    }

    override string mangle() {
        if (this.mutableElements)
            return "mut_array_" ~ this.elementType.mangle;
        return "array_" ~ this.elementType.mangle;
    }

    override void hash(Hash hash) {
        hash.adds("array");
        hash.addl(this.mutableElements);
        this.pendingElementType.case {
            Type t: t.hash(hash);
            PendingSymbol s: s.hash(hash);
        }
    }

    override (Expression | Error) copy(Context context, Expression source, LocRange locRange)
    {
        auto compiler = context.compiler;

        (nullable Expression | Error) do_(Expression source) {
            mut auto context = context.withNamespace(context.compiler.exprAlias(context.namespace, "source", source));
            auto refCountIncFun = new FunctionDeclaration(
                "neat_runtime_refcount_inc2", new Void, [
                    Parameter.simple("label", new Pointer(new Character)),
                    Parameter.simple("ptr", new Pointer(new Void))]);
            context = context.withNamespace(context.compiler.exprAlias(
                        context.namespace, "neat_runtime_refcount_inc2", refCountIncFun));
            // count up reference
            auto stmt = compiler.$stmt if (source.base) {
                neat_runtime_refcount_inc2("array acquire", source.base);
            };
            auto result = stmt.compile(context)?;
            return compiler.statementExpression(result.statement, source);
        }
        return compiler.exprWithTemporaryExpr(context.getUniqueId, source, &do_)?? else die;
    }

    override nullable Statement endLifetime(Context context, Expression value)
    {
        return context.compiler.exprStatement(releaseArray(context, value));
    }

    override (nullable Symbol | Error) accessMember(
        Context context, nullable Expression base, string field, Protection _, LocRange locRange)
    {
        auto base = base.case(null: return null);
        if (field == "length")
            return arrayLength(base, context)?;
        if (field == "ptr")
            return arrayPointer(this.elementType, base, context)?;
        if (field == "base")
            return arrayBase(base, context)?;
        if (field == "front")
            return context.compiler.dereference(
                arrayPointer(this.elementType, base, context)?);
        if (field == "dup")
            return arrayDup(context, base);
        /**
         * Dangerous op: turn a T mut[] into a T[].
         * Use only to indicate that you no longer intend to mutate the array.
         * This is useful when a value has a separate creation and use phase.
         */
        if (field == "freeze")
            return arrayFreeze(base, context);
        if (field == "empty") {
            auto length = arrayLength(base, context)?;

            return context.compiler.binaryOp(
                "==", context, length, context.compiler.wordLiteral(context.platform, 0), locRange);
        }
        if (field == "next") {
            auto length = arrayLength(base, context)?;

            return new ArraySlice(
                base, context.compiler.wordLiteral(context.platform, 1), length, locRange, context.platform);
        }
        return null;
    }

    override (nullable Expression | Error) binaryOp(
        Context context, string op, Expression left, Expression right, LocRange locRange)
    {
        if (op == "==" && right.type.instanceOf(Array)) {
            (Expression | Error) do1(Expression left) {
                (Expression | Error) do2(Expression right) {
                    return arrayEqual(context, left, right);
                }
                return context.compiler.consume(context, right, &do2);
            }
            return context.compiler.consume(context, left, &do1);
        }
        return null;
    }

    override (nullable Expression | Error) implicitConvertFrom(
        Context context, Expression source, LocRange locRange)
    {
        if (source.type.instanceOf(NullPointer) && this.zeroInitializable) {
            return new EmptyArrayLiteral(this);
        }
        return null;
    }

    override (nullable Expression | Error) implicitConvertTo(
        Context context, Expression source, Type target, LocRange locRange)
    {
        if (auto targetArray = target.instanceOf(Array)) {
            if (mutableElements != targetArray.mutableElements)
                return null;
            // trivial array conversion
            if (elementType.triviallyConvertsTo(targetArray.elementType)) {
                return context.compiler.trivialCastTo(target, source);
            }
            // polysemous array literal conversion
            if (auto arrayLit = source.instanceOf(ArrayLiteral)) {
                mut Expression[] replacements;
                for (value in arrayLit.values) {
                    if (auto casted = context.compiler.implicitConvertTo(context, value,
                            targetArray.elementType, locRange)?)
                    {
                        replacements ~= casted;
                    } else {
                        return null;
                    }
                }
                return new ArrayLiteral(targetArray.elementType, replacements, context.platform);
            }
        }
        return null;
    }

    override (nullable Expression | Error) truthy(Context context, Expression expr, LocRange locRange)
    {
        (Expression | Error) do_(Expression expr) {
            return context.compiler.truthy(context, new ArrayPointer(this.elementType, expr), locRange);
        }
        return context.compiler.consume(context, expr, &do_);
    }
}

class ASTArray : ASTSymbol
{
    ASTSymbol elementType;

    bool mutableElements;

    this(this.elementType, this.mutableElements, this.locRange=__CALLER__) { }

    override (Type | Error) compile(Context context)
    {
        auto sym = this.elementType.compile(context)?;
        if (auto pending = sym.instanceOf(PendingSymbol))
        {
            return new Array(pending, context.platform);
        }
        auto symtype = sym.beType(this.locRange)?;
        return new Array(symtype, context.platform, mutableElements);
    }

    override string repr() {
        return elementType.repr ~ "[]";
    }
}

int getArrayLen(Generator output, Type arrayType, int arrayReg) {
    return output.fun.field(arrayType.emit(output.platform), arrayReg, 0);
}

(Expression | Error) arrayLength(Expression base, Context context) => context.compiler.wrapWithCleanup(
    context, base, __RANGE__, a => new ArrayLength(a, context.nativeWordType));

(Expression | Error) arrayPointer(Type elementType, Expression base, Context context) =>
    context.compiler.wrapWithCleanup(context, base, __RANGE__, a => new ArrayPointer(elementType, a));

(Expression | Error) arrayBase(Expression base, Context context) => context.compiler.wrapWithCleanup(
    context, base, __RANGE__, a => new ArrayBase(a));

(Expression | Error) arrayFreeze(Expression base, Context context) => context.compiler.wrapWithCleanup(
    context, base, __RANGE__, a => new ArrayFreeze(a, context.platform));

class ArrayLength : Expression
{
    Expression arrayValue;

    this(this.arrayValue, this.type) { this.info = ExprInfo(Lifetime.gifted); }

    override int emit(Generator output)
    {
        int arrayReg = this.arrayValue.emit(output);

        return getArrayLen(output, this.arrayValue.type, arrayReg);
    }

    override void hash(Hash hash) { hash.adds("ArrayLength"); this.arrayValue.hash(hash); }

    override string repr() { return "($(this.arrayValue.repr)).length"; }
}

int getArrayPtr(Generator output, Array arrayType, int arrayReg)
{
    return output.fun.bitcast(
        output.fun.field(arrayType.emit(output.platform), arrayReg, 1),
        new BackendPointerType(arrayType.elementType.emit(output.platform), output.platform));
}

(Symbol | Error) arrayDup(Context context, Expression base) {
    auto base = new ASTSymbolHelper(base);
    return (context.compiler.$expr ({
        auto base = $base;
        auto result = new typeof(*base.ptr) mut[](base.length);
        for (i, var in base) result[i] = var; // TODO __emplace
        result;
    })).compile(context);
}

// turn a T mut[] into a T[].
class ArrayFreeze : Expression
{
    Expression value;

    this(this.value, Platform platform) {
        auto arrayType = this.value.type.instanceOf(Array)? else die;
        this.type = new Array(arrayType.pendingElementType, platform, mutableElements=false);
        this.info = value.info;
    }

    override int emit(Generator output) {
        return this.value.emit(output);
   }

    override void hash(Hash hash) { hash.adds("freeze"); value.hash(hash); }

    override string repr() { return "($(value.repr)).freeze"; }
}

class ArrayPointer : Expression
{
    Type elementType;

    Expression arrayValue;

    this(this.elementType, this.arrayValue) {
        this.type = new Pointer(this.elementType);
        this.info = ExprInfo(Lifetime.permanent);
    }

    override int emit(Generator output)
    {
        int arrayReg = this.arrayValue.emit(output);

        return getArrayPtr(output, this.arrayValue.type.instanceOf(Array)? else die, arrayReg);
    }

    override void hash(Hash hash) { hash.adds("ArrayPointer"); this.arrayValue.hash(hash); }

    override string repr() { return "($(this.arrayValue.repr)).ptr"; }
}

int getArrayBase(Generator output, Type arrayType, int arrayReg)
{
    return output.fun.field(arrayType.emit(output.platform), arrayReg, 2);
}

class ArrayBase : Expression
{
    Expression arrayValue;

    this(this.arrayValue) {
        this.type = once new Pointer(new Void);
        this.info = ExprInfo(Lifetime.permanent);
    }

    override int emit(Generator output)
    {
        int arrayReg = this.arrayValue.emit(output);

        return getArrayBase(output, this.arrayValue.type, arrayReg);
    }

    override void hash(Hash hash) { hash.adds("ArrayBase"); this.arrayValue.hash(hash); }

    override string repr() { return "($(this.arrayValue.repr)).__base"; }
}

int makeArray(Generator output, Type elementType, int lenReg, int ptrReg, int baseReg)
{
    BackendType structType = (new Array(elementType, output.platform)).emit(output.platform);
    auto voidp = output.platform.voidp;

    return output.fun.structLiteral(structType, [
        lenReg,
        output.fun.bitcast(ptrReg, voidp),
        baseReg
    ]);
}

// TODO use this as a basis for all array-allocating expressions
class ArrayAllocation : Expression
{
    Type elementType;

    (Expression | size_t) length;

    this(this.elementType, bool mutableElements, this.length, Platform platform) {
        this.type = new Array(this.elementType, platform, mutableElements);
        this.info = ExprInfo(Lifetime.gifted);
    }

    override int emit(Generator output)
    {
        auto backendSizeT = output.platform.nativeWordType;
        auto voidp = output.platform.voidp;
        auto backendElementType = this.elementType.emit(output.platform);
        int elementSizeReg = output.fun.wordLiteral(output.platform, backendElementType.size);
        int threeWordSizeReg = output.fun.wordLiteral(output.platform, backendSizeT.size * 3);
        int oneReg = output.fun.wordLiteral(output.platform, 1);
        int twoReg = output.fun.wordLiteral(output.platform, 2);
        int threeReg = output.fun.wordLiteral(output.platform, 3);
        int arrayLength = this.length.case(
            Expression ex: ex.emit(output),
            size_t sz: output.fun.wordLiteral(output.platform, sz));
        int arrayBytes = output.fun.binop("*", backendSizeT, arrayLength, elementSizeReg);
        int totalArrayBytes = output.fun.binop("+", backendSizeT, arrayBytes, threeWordSizeReg);
        int arrayBase = output.fun.call(voidp, "neat_runtime_alloc", [totalArrayBytes]);
        // ptr = base + 2
        int arrayPtr = output.fun.bitcast(output.fun.ptrOffset(backendSizeT, arrayBase, threeReg), voidp);
        // base[0] = refs (1)
        // base[1] = allocated length (in elements)
        // base[2] = used length (in elements, inited to allocated length)
        output.fun.call(
            once new BackendVoidType,
            "neat_runtime_refcount_set",
            [arrayBase, oneReg]);
        output.fun.store(backendSizeT, output.fun.ptrOffset(backendSizeT, arrayBase, oneReg), arrayLength);
        output.fun.store(backendSizeT, output.fun.ptrOffset(backendSizeT, arrayBase, twoReg), arrayLength);

        int arrayPtrBc = output.fun.bitcast(arrayPtr, new BackendPointerType(backendElementType, output.platform));
        return makeArray(output, this.elementType, arrayLength, arrayPtrBc, arrayBase);
    }

    override void hash(Hash hash) {
        hash.adds("ArrayAllocation");
        this.length.case {
            Expression ex: ex.hash(hash);
            size_t sz: hash.addl(sz);
        }
    }

    override string repr() {
        string len = length.case(Expression e: e.repr, size_t s: "$s");
        return "new $(elementType.repr)[]($(len))";
    }
}

class ArraySlice : Expression
{
    Expression base;

    Expression lower;

    Expression upper;

    LocRange locRange;

    Array arrayType;

    this(this.base, this.lower, this.upper, this.locRange, Platform platform) {
        auto baseType = this.base.type;
        if (auto arrayType = baseType.instanceOf(Array)) {
            this.arrayType = arrayType;
        } else if (auto pointerType = baseType.instanceOf(Pointer)) {
            this.arrayType = new Array(pointerType.target, platform);
        } else {
            print("$(locRange.toString): slice of non-array/non-pointer - catch this earlier!");
            exit(1);
        }
        this.type = this.arrayType;
        this.info = this.base.info;
    }

    override int emit(Generator output)
    {
        assert(lower.type.emit(output.platform).same(output.platform.nativeWordType));
        assert(upper.type.emit(output.platform).same(output.platform.nativeWordType));

        BackendType voidp = output.platform.voidp;

        auto elementType = this.arrayType.elementType.emit(output.platform);

        int baseReg = this.base.emit(output);
        int lowerReg = this.lower.emit(output);
        int upperReg = this.upper.emit(output);
        mut int base, ptr;
        if (this.base.type.instanceOf(Array)) {
            base = getArrayBase(output, this.arrayType, baseReg);
            ptr = getArrayPtr(output, this.arrayType, baseReg);
        } else {
            base = output.fun.bitcast(output.fun.wordLiteral(output.platform, 0), voidp);
            ptr = baseReg;
        }
        // ptr = ptr + lower
        int newPtr = output.fun.ptrOffset(elementType, ptr, lowerReg);
        // len = upper - lower
        int newLen = output.fun.binop(
            "-", output.platform.nativeWordType,
            upperReg, lowerReg);

        // TODO acquire ref
        return makeArray(output, this.arrayType.elementType, newLen, newPtr, base);
    }

    override void hash(Hash hash) {
        hash.adds("ArraySlice");
        base.hash(hash);
        lower.hash(hash);
        upper.hash(hash);
    }
    override string repr() return "$(base.repr)[$(lower.repr) .. $(upper.repr)]";
}

Expression arrayEqual(Context context, Expression left, Expression right) {
    auto compiler = context.compiler;

    Array leftArray = left.type.instanceOf(Array)? else die;
    Array rightArray = right.type.instanceOf(Array)? else die;

    Parameter[] params = [
        Parameter.simple("left", leftArray),
        Parameter.simple("right", rightArray),
    ];

    ASTStatement body_()
    {
        if (leftArray.elementType.same(once new Character)
            && rightArray.elementType.same(once new Character)) {
            return compiler.$stmt {
                import package(compiler).neat.runtime.stdlib : memcmp;

                if (left.length != right.length) return false;
                return memcmp(left.ptr, right.ptr, left.length) == 0;
            };
        }
        return compiler.$stmt {
            if (left.length != right.length) return false;
            for (i in 0 .. left.length) {
                if (left[i] != right[i]) return false;
            }
            return true;
        };
    }

    auto fn = compiler.createRuntimeFunction(context, "array_eq", new Boolean, params, &body_);

    return context.compiler.mkCall(fn, [left, right]);
}

Expression releaseArray(Context context, Expression value) {
    auto compiler = context.compiler;

    Array array = value.type.instanceOf(Array)? else die;
    Parameter[] params = [Parameter.simple("value", array)];

    ASTStatement body_()
    {
        return compiler.$stmt {
            if (!value.base) return;
            if (!neat_runtime_refcount_dec2("array release", value.base))
                return;
            for (i in 0 .. value.length) {
                __destroy(value[i]);
            }
            free(value.base);
        };
    }

    auto fn = compiler.createRuntimeFunction(context, "arrayrelease", new Void, params, &body_);

    return context.compiler.mkCall(fn, [value]);
}

(Expression | Error) arrayCat(Context context, mut Expression left, mut Expression right, LocRange locRange) {
    auto compiler = context.compiler;

    Array leftArray = left.type.instanceOf(Array)? else die;

    mut (nullable Expression | :unknown) ltr_ = :unknown;
    (nullable Expression | Error) ltr() {
        if (ltr_ == :unknown)
            ltr_ = context.compiler.implicitConvertTo(context, left, right.type, locRange)?;
        // TODO bottom assert
        return ltr_.case(:unknown: return null);
    }

    mut (nullable Expression | :unknown) rtl_ = :unknown;
    (nullable Expression | Error) rtl() {
        if (rtl_ == :unknown)
            rtl_ = context.compiler.implicitConvertTo(context, right, left.type, locRange)?;
        // TODO bottom assert
        return rtl_.case(:unknown: return null);
    }

    bool sameType = left.type.same(right.type);
    bool appendElementType = leftArray.elementType.same(right.type)
        || leftArray.elementType.implicitConvertFrom(context, right, locRange)?;
    bool appendArrays = sameType || ltr? || rtl?;

    // TODO should element append really live in this function?
    // if we factor it out the logic gets a bit easier probably.
    if (!appendElementType && !appendArrays) {
        return locRange.fail("incompatible types for concat: " ~ left.type.repr ~ " and " ~ right.type.repr);
    }

    (Expression left, Expression right | Error) merge() {
        if (sameType || appendElementType) return (left, right);
        if (auto rtl = rtl?) return (left, rtl);
        return (ltr?? else die, right);
    }
    auto = merge?;

    ASTStatement body_() {
        if (appendElementType) {
            return compiler.$stmt {
                if (left.base) {
                    size_t prevCap = (cast(size_t*) left.base)[1];
                    size_t* prevUsed = &(cast(size_t*) left.base)[2];
                    auto prevFrontier = &(cast(typeof(left.ptr)) &(cast(size_t*) left.base)[3])[*prevUsed];
                    if (&left.ptr[left.length] is prevFrontier && *prevUsed < prevCap) {
                        *prevUsed += 1;
                        prevFrontier[0] = right;
                        return left[0 .. $ + 1];
                    }
                }
                auto result = new typeof(left)(left.length * 2 + 1);
                for (i, src in left) result.ptr[i] = src;
                result.ptr[left.length] = right;
                // used
                (cast(size_t*) result.base)[2] = left.length + 1;
                return result[0 .. left.length + 1];
            };
        } else if (appendArrays) {
            return compiler.$stmt {
                // TODO don't try freeing result[i] on move-into
                auto newLength = left.length + right.length;
                if (left.base) {
                    size_t prevCap = (cast(size_t*) left.base)[1];
                    size_t* prevUsed = &(cast(size_t*) left.base)[2];
                    auto prevFrontier = &(cast(typeof(left.ptr)) &(cast(size_t*) left.base)[3])[*prevUsed];
                    if (&left.ptr[left.length] is prevFrontier && *prevUsed + right.length <= prevCap) {
                        *prevUsed += right.length;
                        for (i, value in right) prevFrontier[i] = value;
                        return left[0 .. newLength];
                    }
                }
                auto result = new typeof(left)(left.length * 2 + right.length);
                for (i, value in left) result.ptr[i] = value;
                for (i, value in right) result.ptr[left.length + i] = value;
                (cast(size_t*) result.base)[2] = newLength;
                return result[0 .. newLength];
            };
        } else assert(false);
    }
    Parameter[] params = [
        Parameter.simple("left", left.type),
        Parameter.simple("right", right.type)];
    auto fn = compiler.createRuntimeFunction(context, "arrayCat", left.type, params, &body_);
    auto astFn = new ASTSymbolHelper(fn);
    auto astLeft = new ASTSymbolHelper(left);
    auto astRight = new ASTSymbolHelper(right);

    return compiler.call(
            context, astFn, [
                ASTArgument(astLeft, "", __RANGE__), ASTArgument(astRight, "", __RANGE__)],
            locRange, false)?? else die;
}

(Statement | Error) arrayCatAssign(Context context, Reference left, Expression right, LocRange locRange) {
    auto compiler = context.compiler;

    Array leftArray = left.type.instanceOf(Array)? else die;
    bool appendElementType = leftArray.elementType.same(right.type)
        || leftArray.elementType.implicitConvertFrom(context, right, locRange)?;
    bool appendArrays = leftArray.same(right.type);

    if (!appendElementType && !appendArrays) {
        return locRange.fail("incompatible types for '~=': " ~ leftArray.repr ~ " and " ~ right.type.repr);
    }

    ASTStatement body_() {
        // TODO below
        auto astNewLeft = (compiler.$expr newLeft) if leftArray.mutableElements else (compiler.$expr newLeft.freeze);
        if (appendElementType) {
            return compiler.$stmt {
                if (leftp.base) {
                    size_t prevRefs = (cast(size_t*) leftp.base)[0];
                    size_t prevCap = (cast(size_t*) leftp.base)[1];
                    size_t* prevUsed = &(cast(size_t*) leftp.base)[2];
                    auto prevFrontier = &(cast(typeof(leftp.ptr)) &(cast(size_t*) leftp.base)[3])[*prevUsed];
                    if (&leftp.ptr[leftp.length] is prevFrontier && *prevUsed < prevCap) {
                        *prevUsed += 1;
                        prevFrontier[0] = __take(right);
                        *leftp = (*leftp)[0 .. $ + 1];
                        return;
                    }
                    /**
                     * If leftp is single-owner (TODO rt function for this) we can optimize here:
                     * we should *not* take references in `leftp` and then free them via assignment, but instead
                     * do moves.
                     * We can safely do this, because nobody else but us can mess with the references in leftp.
                     * Then we can skip the leftp array-free, and instead just free(), because we're taking over
                     * every reference.
                     * Note that this optimization can only be applied if leftp references the entire used part
                     * of the array object.
                     * See also below.
                     */
                    if (prevRefs == 1 && *prevUsed == leftp.length) {
                        auto result = new typeof(*leftp.ptr) mut[](leftp.length * 2 + 1);
                        for (mut size_t i = 0; i < leftp.length; i++)
                            __moveEmplace(leftp.ptr[i], result.ptr[i]);
                        // this is fishy. but seems to work. what was I doing with this parameter...
                        __moveEmplace(right, result.ptr[leftp.length]);
                        // used
                        (cast(size_t*) result.base)[2] = leftp.length + 1;
                        auto newLeft = result[0 .. leftp.length + 1];
                        auto newLeft = $astNewLeft;
                        free(leftp.base);
                        __copyEmplace(newLeft, *leftp);
                        return;
                    }
                }
                auto result = new typeof(*leftp.ptr) mut[](leftp.length * 2 + 1);
                for (mut size_t i = 0; i < leftp.length; i++)
                    __copyEmplace(leftp.ptr[i], result.ptr[i]);
                result.ptr[leftp.length] = __take(right);
                // used
                (cast(size_t*) result.base)[2] = leftp.length + 1;
                auto newLeft = result[0 .. leftp.length + 1];
                // TODO
                *leftp = $astNewLeft;
            };
        } else if (appendArrays) {
            return compiler.$stmt {
                auto newLength = leftp.length + right.length;
                if (leftp.base) {
                    // if prevRefs is 1, it must be threadsafe and can never become non-1
                    // TODO do we need to acquire here?
                    size_t prevRefs = (cast(size_t*) leftp.base)[0];
                    size_t prevCap = (cast(size_t*) leftp.base)[1];
                    size_t* prevUsed = &(cast(size_t*) leftp.base)[2];
                    auto prevFrontier = &(cast(typeof(leftp.ptr)) &(cast(size_t*) leftp.base)[3])[*prevUsed];
                    if (&leftp.ptr[leftp.length] is prevFrontier && *prevUsed + right.length <= prevCap) {
                        *prevUsed += right.length;
                        for (mut size_t i = 0; i < right.length; i++)
                            __copyEmplace(right.ptr[i], prevFrontier[i]);
                        *leftp = (*leftp)[0 .. newLength];
                        return;
                    }
                    // explanation see above!
                    if (prevRefs == 1 && *prevUsed == leftp.length) {
                        auto result = new typeof(*leftp.ptr) mut[](leftp.length * 2 + right.length);
                        for (mut size_t i = 0; i < leftp.length; i++)
                            __moveEmplace(leftp.ptr[i], result.ptr[i]);
                        // TODO we can theoretically do the same optimization here if right has only one owner
                        for (mut size_t i = 0; i < right.length; i++)
                            __copyEmplace(right.ptr[i], result.ptr[leftp.length + i]);
                        (cast(size_t*) result.base)[2] = newLength;
                        auto newLeft = result[0 .. newLength];
                        auto newLeft = $astNewLeft;
                        free(leftp.base);
                        __copyEmplace(newLeft, *leftp);
                        return;
                    }
                }
                auto result = new typeof(*leftp.ptr) mut[](leftp.length * 2 + right.length);
                for (mut size_t i = 0; i < leftp.length; i++)
                    __copyEmplace(leftp.ptr[i], result.ptr[i]);
                for (mut size_t i = 0; i < right.length; i++)
                    __copyEmplace(right.ptr[i], result.ptr[leftp.length + i]);
                (cast(size_t*) result.base)[2] = newLength;
                // TODO
                auto newLeft = result[0 .. newLength];
                *leftp = $astNewLeft;
            };
        } else assert(false);
    }
    Parameter[] params = [
        Parameter.simple("leftp", new Pointer(leftArray)),
        Parameter.simple("right", right.type)];
    auto fn = compiler.createRuntimeFunction(context, "arrayCatAssign", new Void, params, &body_);
    auto astFn = new ASTSymbolHelper(fn);
    auto astLeftPtr = new ASTSymbolHelper(compiler.reference(left));
    mut ASTSymbol astRight = new ASTSymbolHelper(right);
    if (appendElementType) {
        if (right.info.lifetime == Lifetime.gifted)
            astRight = new ASTOverrideLifetime(astRight, Lifetime.lexical);
        if (right.info.lifetime == Lifetime.lexical || right.info.lifetime == Lifetime.ephemeral)
            astRight = new ASTLeakExpr(astRight);
    }

    return compiler.call(
            context, astFn, [
                ASTArgument(astLeftPtr, "", __RANGE__), ASTArgument(astRight, "", __RANGE__)],
            locRange, false)?
        .(compiler.exprStatement(that? else die));
}

(nullable ASTSymbol | Error) parseArrayLiteral(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    if (parser.acceptToken(TokenType.lsquarebracket)) { }
    else {
        parser.revert;
        return null;
    }
    mut ASTArrayLiteralElement[] values;
    while (true) {
        if (parser.acceptToken(TokenType.rsquarebracket)) break;
        auto from = parser.from;
        ASTSymbol value = lexicalContext.compiler.parseExpression(parser, lexicalContext)??
            else return parser.fail("array literal member expected");
        values ~= ASTArrayLiteralElement(value, parser.to(from));
        if (parser.acceptToken(TokenType.rsquarebracket)) break;
        parser.expectToken(TokenType.comma)?;
    }
    parser.commit;
    return new ASTArrayLiteral(values);
}

// marker: type that converts to any array type.
// type of [].
class EmptyArrayType : Type
{
    this() { this.zeroInitializable = true; }

    override BackendType emit(Platform platform) {
        return new BackendVoidType;
    }

    override bool same(Type other) {
        return !!other.instanceOf(EmptyArrayType);
    }

    override (nullable Expression | Error) implicitConvertTo(
        Context context, Expression source, Type target, LocRange locRange)
    {
        if (target.instanceOf(Array)) {
            return new EmptyArrayLiteral(target);
        }
        return null;
    }

    override string repr() { return "typeof([])"; }
    override void hash(Hash hash) { hash.adds("EmptyArrayType"); }
}

class EmptyArrayLiteral : Expression
{
    nullable Type type_; // may be null

    this(this.type_) {
        if (auto type = this.type_) this.type = type; // Very good code.
        else this.type = new EmptyArrayType;
        this.info = ExprInfo(Lifetime.permanent);
    }

    override int emit(Generator generator) {
        if (!this.type_)
            return generator.fun.voidLiteral;
        auto elementType = this.type_.instanceOf(Array).elementType;
        auto voidp = generator.platform.voidp;
        auto elementp = new BackendPointerType(elementType.emit(generator.platform), generator.platform);

        int len = generator.fun.wordLiteral(generator.platform, 0);
        int ptr = generator.fun.bitcast(generator.fun.intLiteral(0), elementp);
        int base = generator.fun.bitcast(generator.fun.intLiteral(0), voidp);

        return makeArray(generator, elementType, len, ptr, base);
    }

    override void hash(Hash hash) {
        hash.adds("EmptyArrayLiteral");
        if (this.type_)
            this.type_.hash(hash);
        else
            hash.adds(" generic");
    }
    override string repr() return "[]";
}

struct ASTArrayLiteralElement
{
    ASTSymbol value;

    LocRange locRange;
}

class ASTArrayLiteral : ASTSymbol
{
    ASTArrayLiteralElement[] elements;

    this(this.elements) { }

    override (Expression | Error) compile(Context context) {
        if (!this.elements.length)
            return new EmptyArrayLiteral(null);
        mut Expression mut[] values;
        for (element in this.elements)
            values ~= element.value.compile(context)?.beExpressionImplCall(context, element.locRange)?;
        auto merger = new TypeMerger;
        for (i, element in this.elements) {
            merger.add(values[i], element.locRange, context)?;
        }
        auto mergeType = merger.type(context)? else die;
        for (i in 0 .. this.elements.length) {
            auto elemLocRange = this.elements[i].value.locRange;
            if (auto castValue = context.compiler.implicitConvertTo(context, values[i], mergeType, elemLocRange)?) {
                if (castValue.info.lifetime.(Lifetime.(that == gifted || that == none)))
                    values[i] = castValue;
                else
                    values[i] = castValue.copy(context, elements[i].locRange)?;
            }
            else
                return this.elements[i].locRange.fail("cannot convert to shared type $(mergeType.repr)");
        }
        return new ArrayLiteral(mergeType, values.freeze, context.platform);
    }
}

class ArrayLiteral : ArrayAllocation
{
    Expression[] values;

    // TODO super()
    this(this.elementType, this.values, Platform platform) {
        this.length = this.values.length;
        this.type = new Array(this.elementType, platform);
        this.info = ExprInfo(Lifetime.gifted);
    }

    override int emit(Generator output)
    {
        auto targetReg = super.emit(output);
        auto ptrReg = getArrayPtr(output, this.type.instanceOf(Array)? else die, targetReg);
        auto backendElementType = elementType.emit(output.platform);
        for (i, value in values) {
            int offsetReg = output.fun.wordLiteral(output.platform, i);
            int offsetPtrReg = output.fun.ptrOffset(backendElementType, ptrReg, offsetReg);
            int valueReg = value.emit(output);
            output.fun.store(backendElementType, offsetPtrReg, valueReg);
        }
        return targetReg;
    }

    override void hash(Hash hash) {
        hash.adds("ArrayLiteral");
        super.hash(hash);
        for (value in values) value.hash(hash);
    }

    override string repr() {
        mut string res;
        for (i, value in this.values) {
            if (i) res ~= ", ";
            res ~= value.repr;
        }
        return "[$res]";
    }
}

/**
 * $ for length in an array index context.
 */
class ASTArrayLength : ASTSymbol
{
    this(this.locRange=__CALLER__) { }

    override (Symbol | Error) compile(Context context) {
        import neat.base : assert;
        auto surroundingArraySymbol = context.compiler.lookup(
            context, __RANGE__, LookupReason.identifier, "__array")?;
        assert(locRange,
            surroundingArraySymbol && surroundingArraySymbol.instanceOf(Expression),
            () => "'\$' can only be used inside an array index context")?;

        return new ArrayLength(
            surroundingArraySymbol.instanceOf(Expression)? else die,
            context.nativeWordType);
    }

    override string repr() => "\$";
}

// TODO this should be a template in the runtime
class ArrayCastExpr : Expression
{
    Expression source;

    Array target;

    this(this.source, this.target) { this.type = target; this.info = source.info; }

    override int emit(Generator generator) {
        Array sourceArray = source.type.instanceOf(Array)? else die;
        auto sourceArrayElemBk = sourceArray.elementType.emit(generator.platform);
        int sourceSize = sourceArrayElemBk.size;
        auto targetArrayElemBk = target.elementType.emit(generator.platform);
        int destSize = targetArrayElemBk.size;
        int sourceReg = source.emit(generator);
        int arrayBase = generator.getArrayBase(sourceArray, sourceReg);
        int arrayPtr = generator.getArrayPtr(sourceArray, sourceReg);

        // TODO validate length conversion matchup
        int sourceElemSzReg = generator.fun.wordLiteral(generator.platform, sourceSize);
        int destElemSzReg = generator.fun.wordLiteral(generator.platform, destSize);
        auto backendSizeT = generator.platform.nativeWordType;
        int sourceLen = generator.getArrayLen(sourceArray, sourceReg);
        int totalBytes = generator.fun.binop("*", backendSizeT, sourceLen, sourceElemSzReg);
        int newLen = generator.fun.binop("/", backendSizeT, totalBytes, destElemSzReg);

        return generator.makeArray(target.elementType, lenReg=newLen, ptrReg=arrayPtr, baseReg=arrayBase);
    }

    override void hash(Hash hash) { hash.adds("ArrayCastExpr"); source.hash(hash); target.hash(hash); }
    override string repr() { return "cast($(target.repr)) $(source.repr)"; }
}

/**
 * Even though the lifetime logic does not support this, sometimes it's
 * useful to be able to borrow an expression anyways.
 * (for instance, for (a in array) borrows a from array.
 * TODO move to compiler/expr.
 */
class ASTOverrideLifetime : ASTSymbol
{
    ASTSymbol source;

    Lifetime lifetime;

    this(this.source, this.lifetime, this.locRange=__CALLER__) { }

    override (Symbol | Error) compile(Context context) {
        auto source = this.source.compile(context)?.beExpression(this.locRange)?;
        return new OverrideLifetimeExpr(source, ExprInfo(this.lifetime));
    }
}

/**
 * Leak a reference.
 */
class ASTLeakExpr : ASTSymbol
{
    ASTSymbol source;

    this(this.source, this.locRange=__CALLER__) { }

    override (Symbol | Error) compile(Context context) {
        auto source = this.source.compile(context)?.beExpression(this.locRange)?;
        return new OverrideLifetimeExpr(source.type.copy(context, source, this.source.locRange)?, source.info);
    }
}
