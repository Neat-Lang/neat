module backend.llvm;

macro import std.macro.assert;
macro import std.macro.cimport;
macro import std.macro.listcomprehension;

import backend.base;
import neat.hash;
import std.string;
import std.thread;

import c_header("llvm-c/BitWriter.h");
import c_header("llvm-c/Core.h");
import c_header("llvm-c/DebugInfo.h");
import c_header("llvm-c/Target.h");
import c_header("llvm-c/TargetMachine.h");

pragma(lib, "LLVM");

LLVMTypeRef translate(BackendType type, LLVMContextRef context, Platform platform, bool returnType) {
    assert(!!type);
    if (type.instanceOf(BackendLongType)) return LLVMInt64TypeInContext(context);
    if (type.instanceOf(BackendIntType)) return LLVMInt32TypeInContext(context);
    if (type.instanceOf(BackendShortType)) return LLVMInt16TypeInContext(context);
    if (type.instanceOf(BackendCharType)) return LLVMInt8TypeInContext(context);
    if (type.instanceOf(BackendFloatType)) return LLVMFloatTypeInContext(context);
    if (type.instanceOf(BackendDoubleType)) return LLVMDoubleTypeInContext(context);
    if (type.instanceOf(BackendVoidType)) {
        if (returnType) return LLVMVoidTypeInContext(context);
        return LLVMStructTypeInContext(context, null, 0, false);
    }
    auto backendSpacerType = type.instanceOf(BackendSpacerType);
    if (backendSpacerType) return LLVMArrayType(LLVMInt8TypeInContext(context), backendSpacerType.size_);
    auto backendPointerType = type.instanceOf(BackendPointerType);
    if (backendPointerType) {
        if (backendPointerType.target.instanceOf(BackendVoidType)) {
            return LLVMPointerType(LLVMInt8TypeInContext(context), 0);
        }
        return LLVMPointerType(
            translate(backendPointerType.target, context, platform, false),
            0);
    }
    auto backendStructType = type.instanceOf(BackendStructType);
    if (backendStructType) {
        mut LLVMTypeRef[] types;
        for (member in backendStructType.members) {
            types ~= translate(member, context, platform, false);
        }
        return LLVMStructTypeInContext(context, types.ptr, cast(int) types.length, false);
    }
    if (auto backendFpType = type.instanceOf(BackendFunctionPointerType)) {
        return LLVMPointerType(translateFunc(backendFpType, context, platform), 0);
    }
    auto backendSAtype = type.instanceOf(BackendStaticArrayType);
    if (backendSAtype) {
        return LLVMArrayType(
            translate(backendSAtype.element, context, platform, false),
            cast(int) backendSAtype.length);
    }
    print(type.repr);
    assert(false);
}

nullable BackendType toAmd64ParamType(BackendType type, Platform platform) {
    if (type.size(platform) > 16) return null;
    mut auto sseFields = new int[](2), intFields = new int[](2), unkFields = new int[](2);
    mut auto fill = new int[](2);
    void walk(int offset, BackendType type) {
        assert(offset < 16);
        fill[offset / 8] = (offset % 8) + type.size(platform);
        if (type.instanceOf(BackendFloatType) || type.instanceOf(BackendDoubleType))
            sseFields[offset / 8] += 1;
        else if (type.instanceOf(BackendLongType) || type.instanceOf(BackendIntType)
            || type.instanceOf(BackendShortType) || type.instanceOf(BackendCharType))
            intFields[offset / 8] += 1;
        else if (auto struct_ = type.instanceOf(BackendStructType)) {
            for (int i, field in struct_.members) {
                walk(offset + struct_.memberOffset(i, platform), field);
            }
        }
        else
            unkFields[offset / 8] += 1;
    }
    walk(0, type);
    mut BackendType[] blobs;
    for (i in 0 .. 2) {
        bool isSSE = sseFields[i] > 0, isInt = intFields[i] > 0, isUnk = unkFields[i] > 0;
        BackendType intFillType() {
            if (fill[i] > 4) return new BackendLongType;
            if (fill[i] > 2) return new BackendIntType;
            if (fill[i] > 1) return new BackendShortType;
            return new BackendCharType;
        }
        BackendType doubleFillType() {
            if (fill[i] > 4) return new BackendDoubleType;
            return new BackendFloatType;
        }
        if (isInt && !isUnk) blobs ~= intFillType;
        else if (isSSE && !isUnk) blobs ~= doubleFillType;
        else if (isUnk) return null;
    }
    if (blobs.length == 1) return blobs[0];
    return new BackendStructType(blobs);
}

unittest {
    // TODO literal
    mut BackendType[] inputArray;
    inputArray ~= new BackendFloatType; inputArray ~= new BackendIntType; inputArray ~= new BackendIntType;
    auto input = new BackendStructType(inputArray);
    auto output = toAmd64ParamType(input, new Platform(new BackendLongType, PlatformFlags(), versions=null));

    mut BackendType[] expectedArray;
    expectedArray ~= new BackendLongType; expectedArray ~= new BackendIntType;
    assert(output.same(new BackendStructType(expectedArray)));
}

LLVMTypeRef translateFunc(BackendFunctionPointerType backendFpType, LLVMContextRef context, Platform platform) {
    bool sret = passByMemory(backendFpType.ret, platform);
    mut LLVMTypeRef returnType;
    mut LLVMTypeRef[] paramTypes;

    if (sret) returnType = LLVMVoidTypeInContext(context);
    else returnType = translate(backendFpType.ret, context, platform, true);
    if (!sret) {
        if (auto translatedType = toAmd64ParamType(backendFpType.ret, platform)) {
            returnType = translate(translatedType, context, platform, true);
        }
    }

    if (sret) {
        paramTypes ~= LLVMPointerType(
            translate(backendFpType.ret, context, platform, true), 0);
    }
    for (param in backendFpType.params) {
        if (auto translatedType = toAmd64ParamType(param, platform)) {
            paramTypes ~= translate(translatedType, context, platform, false);
            continue;
        }
        if (passByMemory(param, platform)) {
            paramTypes ~= LLVMPointerType(
                translate(param, context, platform, false), 0);
            continue;
        }
        paramTypes ~= translate(param, context, platform, false);
    }
    return LLVMFunctionType(returnType, paramTypes.ptr, cast(int) paramTypes.length, backendFpType.variadic);
}

bool passByMemory(BackendType type, Platform platform) {
    // AMD64 ABI, rule 5c: aggregates over 16 bytes that are not SSE are passed in memory (byval).
    if (type.instanceOf(BackendStructType) && type.size(platform) > 16)
        return true;
    return false;
}

class LLVMBackend : Backend {
    Mutex mutex;
    this(this.mutex) {
        LLVMInitializeX86TargetInfo;
        LLVMInitializeX86Target;
        LLVMInitializeX86TargetMC;
        LLVMInitializeX86AsmParser;
        LLVMInitializeX86AsmPrinter;
    }
    override LLVMBackendModule createModule(Platform platform, BackendLocation loc, bool forMacro) {
        return new LLVMBackendModule(platform, loc, forMacro, this.mutex);
    }
    override void hash(Hash hash) {
        hash.adds("LLVM");
    }
}

struct DeclarationEntry
{
    string name;
    bool function_;
    BackendType type;
}

void defineIntrinsics(LLVMBackendModule mod, Platform platform) {
    BackendType voidp = platform.voidp;
    BackendType sizet = platform.nativeWordType;
    {
        auto argTypes = new BackendType[](3);
        argTypes[0] = voidp;
        argTypes[1] = voidp;
        argTypes[2] = sizet;
        mod.declare("memcpy", voidp, argTypes, variadic=false);
    }
    mod.declare("neat_runtime_alloc", voidp, [sizet], variadic=false);
    mod.declare("neat_runtime_refcount_set", new BackendVoidType, [voidp, sizet], variadic=false);
}

class LLVMBackendModule : BackendModule {
    Platform platform;

    int literalId;
    BackendType[string] globals;

    bool forMacro;

    LLVMContextRef context;
    LLVMTargetMachineRef machine;

    LLVMModuleRef module_;

    LLVMDIBuilderRef dibuilder;
    LLVMMetadataRef dicu;

    Mutex mutex;

    this(this.platform, BackendLocation loc, this.forMacro, this.mutex) {
        this.context = LLVMContextCreate;

        auto comps = split(loc.file, "/");
        auto dir = join(comps[0 .. $ - 1], "/");
        auto filename = comps[$ - 1];

        this.module_ = LLVMModuleCreateWithNameInContext(filename.toStringz, context);
        this.dibuilder = LLVMCreateDIBuilder(this.module_);

        char* triple = "x86_64-pc-linux-gnu";
        char* error;
        LLVMTargetRef target;
        bool succ = LLVMGetTargetFromTriple(triple, &target, &error) == 0;
        assert(succ);
        this.machine = LLVMCreateTargetMachine(
            target, triple, "generic", LLVMGetHostCPUFeatures, LLVMCodeGenLevelNone, LLVMRelocPIC, LLVMCodeModelDefault);
        auto datalayout = LLVMCreateTargetDataLayout(machine);
        auto datalayoutStr = LLVMCopyStringRepOfTargetData(datalayout);

        LLVMSetTarget(this.module_, "x86_64-pc-linux-gnu");
        LLVMSetDataLayout(this.module_, datalayoutStr);

        with (this.mutex.locked) {
            auto verStr = "Debug Info Version";
            LLVMAddModuleFlag(
                this.module_, LLVMModuleFlagBehaviorWarning,
                verStr.ptr, verStr.length,
                LLVMValueAsMetadata(LLVMConstInt(LLVMInt32TypeInContext(this.context), 3, SignExtend=false)));
            auto dwarfStr = "Dwarf Version";
            LLVMAddModuleFlag(
                this.module_, LLVMModuleFlagBehaviorWarning,
                dwarfStr.ptr, dwarfStr.length,
                LLVMValueAsMetadata(LLVMConstInt(LLVMInt32TypeInContext(this.context), 2, SignExtend=false)));
            auto picLevel = "PIC Level";
            LLVMAddModuleFlag(
                this.module_, LLVMModuleFlagBehaviorWarning,
                picLevel.ptr, picLevel.length,
                LLVMValueAsMetadata(LLVMConstInt(LLVMInt32TypeInContext(this.context), 1, SignExtend=false)));
        }

        auto file = LLVMDIBuilderCreateFile(
            dibuilder,
            filename.ptr, filename.length,
            dir.ptr, dir.length);
        this.dicu = LLVMDIBuilderCreateCompileUnit(
            dibuilder,
            LLVMDWARFSourceLanguageC,
            file, "neat".ptr, 4,
            false, null, 0,
            0, null, 0,
            LLVMDWARFEmissionFull, 0, false,
            false, null, 0, null, 0);

        defineIntrinsics(this, platform);
    }

    void writeOutput(string file) {
        import std.string : cToString, endsWith;

        // LLVMPrintModuleToFile(this.module_, (file ~ ".ll").toStringz, null);
        if (file.endsWith(".bc")) {
            LLVMWriteBitcodeToFile(this.module_, file.toStringz);
            LLVMContextDispose(this.context);
            return;
        }
        char* error;
        // :-(
        with (this.mutex.locked) {
            bool succ = LLVMTargetMachineEmitToFile(this.machine, this.module_, file.toStringz, LLVMObjectFile, &error) == 0;
            if (!succ) {
                print("compilation failed: $(cToString(error))");
                assert(false);
            }
            LLVMContextDispose(this.context);
        }
    }

    LLVMTypeRef translate(BackendType type, bool returnType) {
        return .translate(type, this.context, this.platform, returnType=returnType);
    }

    override bool declared(string name) { return this.globals.has(name); }

    override void declare(string name, BackendType ret, BackendType[] params, bool variadic)
    {
        assert(!this.declared(name));
        auto type = new BackendFunctionPointerType(ret, params, variadic);
        auto llFunctionType = translateFunc(type, this.context, this.platform);
        auto llFunction = LLVMAddFunction(module_, name.toStringz, llFunctionType);
        llSetCoerceAttribs(llFunction, ret, params);
        this.globals[name] = type;
    }

    void llSetCoerceAttribs(LLVMValueRef llFun, BackendType ret, BackendType[] params) {
        bool sret = passByMemory(ret, this.platform);
        if (sret) {
            auto sretAttrKind = LLVMGetEnumAttributeKindForName("sret", 4);
            assert(sretAttrKind != 0);
            auto sretTypeAttr = LLVMCreateTypeAttribute(
                this.context, sretAttrKind, translate(ret, true));
            // first attribute is sret
            LLVMAddAttributeAtIndex(llFun, 1, sretTypeAttr);
        }
        for (i, param in params) {
            if (passByMemory(param, this.platform)) {
                auto byvalAttrKind = LLVMGetEnumAttributeKindForName("byval", 5);
                assert(byvalAttrKind != 0);
                auto byvalTypeAttr = LLVMCreateTypeAttribute(
                    this.context, byvalAttrKind, translate(param, false));
                // base-1 (0 is return type), + 1 for sret parameter
                int base = 1 + sret;
                LLVMAddAttributeAtIndex(llFun, base + cast(int) i, byvalTypeAttr);
            }
        }
    }

    void declareVar(string name, BackendType type)
    {
        if (this.declared(name))
            return;
        auto llType = translate(type, false);
        LLVMAddGlobal(this.module_, llType, name.toStringz);
        this.globals[name] = type;
    }

    override BackendFunction define(
        string name, string decoration, BackendType ret, BackendType[] args, BackendLocation loc)
    {
        this.globals[name] = new BackendFunctionPointerType(ret, args, variadic=false);

        return new LLVMBackendFunction(this, name, ret, args, loc, decoration);
    }

    override void declareSymbolList(string name, size_t length)
    {
        auto globalType = new BackendStaticArrayType(
            new BackendFunctionPointerType(new BackendVoidType, new BackendType[](0), variadic=false), cast(int) length);
        auto llType = translate(globalType, false);
        LLVMAddGlobal(this.module_, llType, name.toStringz);
        this.globals[name] = globalType;
    }

    override void defineSymbolList(string name, (string | size_t)[] symbols)
    {
        if (forMacro && neat_runtime_symbol_defined_in_main(name))
            return;

        auto defaultFpType = new BackendFunctionPointerType(
            new BackendVoidType, new BackendType[](0), variadic=false);
        auto defaultFpTypeL = translate(defaultFpType, false);
        auto globalType = new BackendStaticArrayType(defaultFpType, cast(int) symbols.length);

        mut LLVMValueRef[] symbolList;
        for (symbol in symbols) {
            symbol.case {
                string sym: {
                    auto fun = LLVMGetNamedFunction(this.module_, sym.toStringz);
                    symbolList ~= LLVMConstBitCast(fun, defaultFpTypeL);
                }
                size_t l: {
                    auto int_ = LLVMConstInt(LLVMInt32TypeInContext(this.context), l, SignExtend=false);
                    symbolList ~= LLVMConstIntToPtr(int_, defaultFpTypeL);
                }
            }
        }
        auto array = LLVMConstArray(defaultFpTypeL, symbolList.ptr, cast(int) symbolList.length);
        auto llvmType = translate(globalType, false);

        mut uninitialized LLVMValueRef var;
        if (auto existingVar = LLVMGetNamedGlobal(this.module_, name.toStringz)) {
            var = existingVar;
        } else {
            var = LLVMAddGlobal(this.module_, llvmType, name.toStringz);
        }
        LLVMSetInitializer(var, array);

        this.globals[name] = globalType;
    }

    string nextLiteral() {
        string res = "str" ~ itoa(this.literalId);
        this.literalId = this.literalId + 1;
        return res;
    }

    BackendType globalType(string name) {
        return this.globals.get(name, ({
            .print("no such global " ~ name);
            assert(false);
            BackendType t = new BackendVoidType; t;
        }));
    }

    override void done()
    {
        LLVMDIBuilderFinalize(this.dibuilder);
        LLVMDisposeDIBuilder(this.dibuilder);
    }
}

extern(C) bool neat_runtime_symbol_defined_in_main(string symbol);

struct RegDefine
{
    int reg;
    BackendType type;
    LLVMValueRef value;
}

struct RegDefines
{
    // reg is index. FIXME hashmap
    RegDefine[] regDefines;
    void add(RegDefine define) {
        resize(define.reg + 1);
        regDefines[define.reg] = define;
    }
    void resize(int targetLength) {
        if (regDefines.length < targetLength) {
            auto copy = new RegDefine[](targetLength * 2);
            for (i, regDefine in regDefines)
                copy[i] = regDefine;
            regDefines = copy;
        }
    }
    (RegDefine | fail :notFound) get(int reg) {
        if (reg >= regDefines.length || regDefines[reg].reg != reg)
            return :notFound;
        return regDefines[reg];
    }
}

extern(C) LLVMBuilderRef LLVMCreateNoFolderBuilderInContext(LLVMContextRef C);

class LLVMBackendFunction : BackendFunction, PhiCapable {
    string name;
    LLVMBackendModule mod;
    BackendType ret_;
    BackendType[] params;

    RegDefines regDefines;
    int regId;
    int blockId;
    string curLabel;

    // correct for sret, byvalue
    LLVMValueRef[] llArgs;
    LLVMMetadataRef difun;

    LLVMValueRef function_;
    LLVMBuilderRef builder;
    LLVMBuilderRef entryBuilder;
    LLVMBasicBlockRef[string] labels;

    Mutex mutex;

    LLVMBasicBlockRef llLabel(string name) {
        if (!this.labels.has(name)) {
            this.labels[name] = LLVMAppendBasicBlockInContext(
                this.mod.context, this.function_, name.toStringz);
        }
        return this.labels[name];
    }

    this(this.mod, this.name, this.ret_, this.params, BackendLocation loc, string decoration)
    {
        auto fpType = new BackendFunctionPointerType(this.ret_, this.params, false);
        auto llFpType = translateFunc(fpType, this.mod.context, this.mod.platform);
        if (auto llExistingFunction = LLVMGetNamedFunction(this.mod.module_, this.name.toStringz)) {
            this.function_ = llExistingFunction;
        } else {
            this.function_ = LLVMAddFunction(this.mod.module_, this.name.toStringz, llFpType);
            this.mod.llSetCoerceAttribs(this.function_, this.ret_, this.params);
        }

        auto comps = split(loc.file, "/");
        auto dir = join(comps[0 .. $ - 1], "/");
        auto filename = comps[$ - 1];

        auto unit = LLVMDIBuilderCreateFile(
            this.mod.dibuilder, filename.ptr, filename.length,
            dir.ptr, dir.length);
        /*auto diType = LLVMDIBuilderCreateSubroutineType(
            this.mod.dibuilder,
            unit,
            [this.mod.translate(a, false) for a in this.params].ptr,
            this.params.length,
            0);*/
        auto diType = LLVMDIBuilderCreateSubroutineType(
            this.mod.dibuilder,
            unit,
            null, 0,
            0);
        this.difun = LLVMDIBuilderCreateFunction(
            this.mod.dibuilder, unit,
            name.ptr, name.length,
            decoration.ptr, decoration.length,
            unit, 0, diType,
            false, true, 0, /* LLVMDIFlagPrototyped */ 256 /* why? */, false);
        this.function_.LLVMSetSubprogram(this.difun);

        this.regId = 1;
        this.blockId = 1;
        this.builder = LLVMCreateBuilderInContext(this.mod.context);
        this.entryBuilder = LLVMCreateBuilderInContext(this.mod.context);

        // 'entry' branches into 'first' in done(), until then it just gets filled with static allocas
        LLVMPositionBuilderAtEnd(this.entryBuilder, llLabel("entry"));
        LLVMPositionBuilderAtEnd(this.builder, llLabel("first"));

        llArgs = new LLVMValueRef[](this.params.length);
        bool sret = passByMemory(this.ret_, this.mod.platform);
        mut int llvmParamId = sret;
        for (int i, param in params) {
            if (auto amd64Type = toAmd64ParamType(param, this.mod.platform)) {
                auto llParam = this.mod.translate(param, false);
                auto llAllocaReg = LLVMBuildAlloca(this.entryBuilder, llParam, "tmparg$i".toStringz);
                auto llAmd64Type = this.mod.translate(amd64Type, false);
                auto llAmd64Ptr = this.mod.translate(new BackendPointerType(amd64Type), false);
                auto llAllocaAmd64Ptr = LLVMBuildBitCast(
                    this.builder, llAllocaReg, llAmd64Ptr, "argload_alloca$i".toStringz);
                auto paramPtr = LLVMGetParam(this.function_, llvmParamId++);
                LLVMBuildStore(this.builder, paramPtr, llAllocaAmd64Ptr);
                llArgs[i] = LLVMBuildLoad(this.builder, llAllocaReg, "argload$i".toStringz);
            } else if (passByMemory(param, this.mod.platform)) {
                auto paramPtr = LLVMGetParam(this.function_, llvmParamId++);
                llArgs[i] = LLVMBuildLoad(
                    this.builder, paramPtr, "arg$i.load".toStringz);
            } else {
                llArgs[i] = LLVMGetParam(this.function_, llvmParamId++);
            }
        }
    }
    LLVMValueRef llReg(int reg) {
        this.regDefines.get(reg).case {
            RegDefine def:
                return def.value;
            (:notFound):
                print("unknown register $reg while emitting $(this.name)");
                assert(false);
        }
    }
    BackendType regType(int reg) {
        this.regDefines.get(reg).case {
            RegDefine def:
                return def.type;
            (:notFound):
                print("unknown register $reg while emitting $(this.name)");
                assert(false);
        }
    }
    void defReg2(int reg, BackendType type, LLVMValueRef value) {
        this.regDefines.add(RegDefine(reg, type, value));
    }
    int defReg(BackendType type, LLVMValueRef value) {
        int reg = this.nextReg;
        this.defReg2(reg, type, value);
        return reg;
    }
    private int nextReg() {
        int result = this.regId;
        this.regId = this.regId + 1;
        return result;
    }
    override string getLabel() {
        return "Label" ~ itoa(this.blockId);
    }
    override string getCurrentLabel() {
        return curLabel;
    }
    override void setLabel(string label) {
        curLabel = label;
        LLVMPositionBuilderAtEnd(builder, llLabel(label));
    }
    override void setLocation(BackendLocation loc) {
        auto di = LLVMDIBuilderCreateDebugLocation(this.mod.context, loc.line + 1, loc.column, this.difun, null);
        LLVMSetCurrentDebugLocation2(builder, di);
    }
    override int arg(int index) {
        return this.defReg(this.params[index], this.llArgs[index]);
    }
    // TODO template all these with alias?
    override int intLiteral(long value) {
        auto llType = this.mod.translate(new BackendIntType, false);
        return this.defReg(new BackendIntType, LLVMConstInt(llType, value, false));
    }
    override int shortLiteral(int value) {
        auto llType = this.mod.translate(new BackendShortType, false);
        return this.defReg(new BackendShortType, LLVMConstInt(llType, value, false));
    }
    override int byteLiteral(int value) {
        auto llType = this.mod.translate(new BackendCharType, false);
        return this.defReg(new BackendCharType, LLVMConstInt(llType, value, false));
    }
    override int longLiteral(long value) {
        auto llType = this.mod.translate(new BackendLongType, false);
        return this.defReg(new BackendLongType, LLVMConstInt(llType, value, false));
    }
    override int floatLiteral(float value) {
        auto llType = this.mod.translate(new BackendFloatType, false);
        return this.defReg(new BackendFloatType, LLVMConstReal(llType, value));
    }
    override int doubleLiteral(double value) {
        auto llType = this.mod.translate(new BackendDoubleType, false);
        return this.defReg(new BackendDoubleType, LLVMConstReal(llType, value));
    }
    override int wordLiteral(Platform platform, size_t value) {
        auto llType = this.mod.translate(platform.nativeWordType, false);
        return this.defReg(platform.nativeWordType, LLVMConstInt(llType, value, false));
    }
    override int stringLiteral(string text) {
        // TODO move to LLVMBackendModule
        // FIXME work around llvm-12 threadsafety issue(?)
        with (this.mod.mutex.locked) {
            auto ptrType = new BackendPointerType(new BackendCharType);
            string literalId = this.mod.nextLiteral;
            auto llType = this.mod.translate(
                new BackendStaticArrayType(new BackendCharType, cast(int) text.length), false);
            auto stringVar = LLVMAddGlobal(this.mod.module_, llType, literalId.toStringz);
            LLVMSetLinkage(stringVar, LLVMPrivateLinkage);
            LLVMSetUnnamedAddress(stringVar, LLVMGlobalUnnamedAddr);
            LLVMSetGlobalConstant(stringVar, true);
            LLVMSetInitializer(stringVar, LLVMConstStringInContext(
                this.mod.context, text.ptr, cast(int) text.length, DontNullTerminate=true));
            auto stringVal = LLVMConstPointerCast(stringVar, this.mod.translate(ptrType, false));

            return this.defReg(ptrType, stringVal);
        }
    }
    override int voidLiteral() {
        return zeroLiteral(new BackendVoidType);
    }
    override void unreachable() {
        LLVMBuildUnreachable(this.builder);
        this.blockId += 1;
    }
    override int zeroLiteral(BackendType type) {
        return this.defReg(type, LLVMConstNull(this.mod.translate(type, false)));
    }
    override int structLiteral(BackendType struct_, int[] regs) {
        auto llType = this.mod.translate(struct_, false);
        mut int curReg = this.defReg(struct_, LLVMGetUndef(llType));
        for (int i, reg in regs) {
            int nextReg = this.nextReg;
            auto nextVal = LLVMBuildInsertValue(
                this.builder, this.llReg(curReg), this.llReg(reg), i, "reg$nextReg".toStringz);
            this.defReg2(nextReg, struct_, nextVal);
            curReg = nextReg;
        }
        return curReg;
    }
    override int symbolList(string name) {
        int reg = this.nextReg;
        auto type = this.mod.globalType(name);
        auto llType = this.mod.translate(type, false);
        auto llGlobal = LLVMGetNamedGlobal(this.mod.module_, name.toStringz);
        assert(!!llGlobal);

        auto bytePtr = new BackendPointerType(new BackendCharType);
        auto llCast = LLVMConstBitCast(llGlobal, this.mod.translate(bytePtr, false));
        return this.defReg(bytePtr, llCast);
    }
    override int globalVar(string name, BackendType type) {
        this.mod.declareVar(name, type);
        int reg = this.nextReg;
        auto llGlobal = LLVMGetNamedGlobal(this.mod.module_, name.toStringz);
        assert(!!llGlobal);
        auto llLoad = LLVMBuildLoad(
            this.builder, llGlobal, "reg$reg".toStringz);
        return this.defReg(type, llLoad);
    }
    override int binop(string op, BackendType type, int left, int right) {
        mut uninitialized (:op, LLVMOpcode | :fcmp, LLVMRealPredicate | :icmp, LLVMIntPredicate) llOp;
        if (type.instanceOf(BackendFloatType) || type.instanceOf(BackendDoubleType)) {
            if (op == "+") llOp = (:op, LLVMFAdd);
            else if (op == "-") llOp = (:op, LLVMFSub);
            else if (op == "*") llOp = (:op, LLVMFMul);
            else if (op == "/") llOp = (:op, LLVMFDiv);
            else if (op == "==") llOp = (:fcmp, LLVMRealOEQ);
            else if (op == "!=") llOp = (:fcmp, LLVMRealONE);
            else if (op == "<") llOp = (:fcmp, LLVMRealOLT);
            else if (op == "<=") llOp = (:fcmp, LLVMRealOLE);
            else if (op == ">") llOp = (:fcmp, LLVMRealOGT);
            else if (op == ">=") llOp = (:fcmp, LLVMRealOGE);
            else { .print(op); assert(false); }
        } else if (type.instanceOf(BackendLongType) || type.instanceOf(BackendIntType)
                || type.instanceOf(BackendShortType) || type.instanceOf(BackendCharType)) {
            if (op == "+") llOp = (:op, LLVMAdd);
            else if (op == "-") llOp = (:op, LLVMSub);
            else if (op == "*") llOp = (:op, LLVMMul);
            else if (op == "/") llOp = (:op, LLVMSDiv);
            else if (op == "%") {
                return wrappedRemainder(type, left, right);
            }
            else if (op == "__%") llOp = (:op, LLVMSRem);
            else if (op == "&") llOp = (:op, LLVMAnd);
            else if (op == "^") llOp = (:op, LLVMXor);
            else if (op == "|") llOp = (:op, LLVMOr);
            else if (op == "<<") llOp = (:op, LLVMShl);
            else if (op == ">>") llOp = (:op, LLVMAShr);
            else if (op == ">>>") llOp = (:op, LLVMLShr);
            else if (op == "==") llOp = (:icmp, LLVMIntEQ);
            else if (op == "!=") llOp = (:icmp, LLVMIntNE);
            else if (op == "<") llOp = (:icmp, LLVMIntSLT);
            else if (op == "<=") llOp = (:icmp, LLVMIntSLE);
            else if (op == ">") llOp = (:icmp, LLVMIntSGT);
            else if (op == ">=") llOp = (:icmp, LLVMIntSGE);
            else { .print(op); assert(false); }
        } else if (type.isPointer && (op == "==" || op == "!=")) {
            if (op == "==") llOp = (:icmp, LLVMIntEQ);
            else if (op == "!=") llOp = (:icmp, LLVMIntNE);
            else { .print(op); assert(false); }
        } else {
            .print("unknown op $op on $(type.repr)");
            assert(false);
        }
        mut int reg = this.nextReg;
        auto llResult = llOp.case(
            (:op, LLVMOpcode op):
                LLVMBuildBinOp(this.builder, op, llReg(left), llReg(right), "reg$reg".toStringz),
            (:fcmp, LLVMRealPredicate pred):
                LLVMBuildFCmp(this.builder, pred, llReg(left), llReg(right), "reg$reg".toStringz),
            (:icmp, LLVMIntPredicate pred):
                LLVMBuildICmp(this.builder, pred, llReg(left), llReg(right), "reg$reg".toStringz));
        if (isBooleanOp(op)) {
            reg = this.nextReg;
            auto lli32 = this.mod.translate(new BackendIntType, false);
            auto llZext = LLVMBuildZExt(this.builder, llResult, lli32, "reg$reg".toStringz);
            this.defReg2(reg, new BackendIntType, llZext);
        } else {
            this.defReg2(reg, type, llResult);
        }
        return reg;
    }
    int wrappedRemainder(BackendType type, int left, int right) {
        int op(int left, string op, int right) { return binop(op, type, left, right); }
        // ((a % b) + b) % b
        return left.op("__%", right).op("+", right).op("__%", right);
    }
    override int bitcast(int from, BackendType to) {
        mut nullable BackendType fromType;
        this.regDefines.get(from).case {
            RegDefine def: {
                if (def.type.same(to)) return from;
                fromType = def.type;
            }
            (:notFound): {
                print("bitcast reg $from, which is not known, in $(this.name)");
                assert(false);
            }
        }
        bool shorter(BackendType left, BackendType right) {
            // TODO validate both are a numeric type
            return left.size(this.mod.platform) < right.size(this.mod.platform);
        }

        assert(!fromType || !fromType.instanceOf(BackendStructType));
        assert(!fromType || fromType.instanceOf(BackendPointerType) || to.instanceOf(BackendPointerType)
            || fromType.size(this.mod.platform) >= to.size(this.mod.platform));

        int reg = this.nextReg;
        mut LLVMValueRef llRes;
        auto llTo = this.mod.translate(to, false);
        if (auto fromType = fromType) {
            if (!fromType.instanceOf(BackendPointerType) && to.instanceOf(BackendPointerType))
                llRes = LLVMBuildIntToPtr(this.builder, llReg(from), llTo, "reg$reg".toStringz);
            else if (fromType.instanceOf(BackendPointerType) && !to.instanceOf(BackendPointerType))
                llRes = LLVMBuildPtrToInt(this.builder, llReg(from), llTo, "reg$reg".toStringz);
            else if (fromType.instanceOf(BackendDoubleType) && to.instanceOf(BackendFloatType))
                llRes = LLVMBuildFPTrunc(this.builder, llReg(from), llTo, "reg$reg".toStringz);
            else if (!fromType.instanceOf(BackendPointerType) && to.shorter(fromType))
                llRes = LLVMBuildTrunc(this.builder, llReg(from), llTo, "reg$reg".toStringz);
            else
                llRes = LLVMBuildBitCast(this.builder, llReg(from), llTo, "reg$reg".toStringz);
        } else
            llRes = LLVMBuildBitCast(this.builder, llReg(from), llTo, "reg$reg".toStringz);
        this.defReg2(reg, to, llRes);
        return reg;
    }
    override int zeroExtend(int value, BackendType to) {
        int reg = this.nextReg;
        auto llRes = LLVMBuildZExt(
            this.builder, llReg(value), this.mod.translate(to, false), "reg$reg".toStringz);
        this.defReg2(reg, to, llRes);
        return reg;
    }
    override int signExtend(int value, BackendType to) {
        int reg = this.nextReg;
        auto llRes = LLVMBuildSExt(
            this.builder, llReg(value), this.mod.translate(to, false), "reg$reg".toStringz);
        this.defReg2(reg, to, llRes);
        return reg;
    }
    override int trunc(int value, BackendType to) {
        int reg = this.nextReg;
        auto llRes = LLVMBuildTrunc(
            this.builder, llReg(value), this.mod.translate(to, false), "reg$reg".toStringz);
        this.defReg2(reg, to, llRes);
        return reg;
    }
    override int convert(int reg, BackendType to) {
        RegDefine def() {
            this.regDefines.get(reg).case {
                RegDefine def: return def;
                (:notFound): assert(false);
            }
        }
        auto def = def;
        auto from = def.type;
        bool isInt(BackendType type) {
            return !!type.instanceOf(BackendIntType);
        }
        bool isFloat(BackendType type) {
            return type.instanceOf(BackendFloatType) || type.instanceOf(BackendDoubleType);
        }
        int target = this.nextReg;
        auto llTo = this.mod.translate(to, false);
        mut LLVMValueRef llTarget;
        if (from.isInt && to.isFloat)
            llTarget = LLVMBuildSIToFP(this.builder, llReg(reg), llTo, "reg$target".toStringz);
        else if (from.isFloat && to.isInt)
            llTarget = LLVMBuildFPToSI(this.builder, llReg(reg), llTo, "reg$target".toStringz);
        else if (from.instanceOf(BackendFloatType) && to.instanceOf(BackendDoubleType))
            llTarget = LLVMBuildFPExt(this.builder, llReg(reg), llTo, "reg$target".toStringz);
        else if (from.instanceOf(BackendDoubleType) && to.instanceOf(BackendFloatType))
            llTarget = LLVMBuildFPTrunc(this.builder, llReg(reg), llTo, "reg$target".toStringz);
        else assert(false);
        this.defReg2(target, to, llTarget);
        return target;
    }

    (BackendType[] params, int[] args) patchVariadicParams(BackendFunctionPointerType type, int[] args) {
        if (!type.variadic || type.params.length >= args.length)
            return (type.params, args);
        mut int[] realArgs = args[0 .. type.params.length];
        auto variadicArgs = args[type.params.length .. $];
        mut BackendType[] realParams = type.params;
        for (i, auto reg in variadicArgs) {
            RegDefine def() {
                this.regDefines.get(reg).case {
                    RegDefine def: return def;
                    (:notFound): assert(false);
                }
            }
            auto def = def;
            realParams ~= def.type;
            // variadic floats are promoted to double
            auto arg = args[type.params.length + i];
            if (def.type.instanceOf(BackendFloatType)) {
                auto newArg = this.nextReg;
                auto llDouble = this.mod.translate(new BackendDoubleType, false);
                auto llNewArg = LLVMBuildFPExt(this.builder, llReg(arg), llDouble, "reg$newArg".toStringz);
                this.defReg2(newArg, new BackendDoubleType, llNewArg);
                realArgs ~= newArg;
            } else {
                realArgs ~= arg;
            }
        }
        assert(realParams.length == args.length);
        return (realParams, realArgs);
    }

    int callImpl(BackendType retType, BackendFunctionPointerType fpType, (int | string) target, int[] args) {
        auto patch = patchVariadicParams(fpType, args);
        BackendType[] params = patch.params;
        int[] args = patch.args;
        int reg = this.nextReg;

        mut LLVMValueRef llRetReg;
        mut LLVMValueRef[] llArgs;
        bool sret = passByMemory(retType, this.mod.platform);
        if (sret) {
            auto llRetType = this.mod.translate(retType, true);
            llRetReg = LLVMBuildAlloca(this.entryBuilder, llRetType, "reg$reg.ret".toStringz);
            llArgs ~= llRetReg;
        }
        for (int i, arg in args) {
            if (auto amd64Type = toAmd64ParamType(params[i], this.mod.platform)) {
                auto llParam = this.mod.translate(params[i], false);
                auto llAlloca = LLVMBuildAlloca(this.entryBuilder, llParam, "reg$reg.coerce$i".toStringz);
                LLVMBuildStore(this.builder, llReg(arg), llAlloca);
                auto llAmd64PtrType = this.mod.translate(new BackendPointerType(amd64Type), false);
                auto llAllocaAsAmd64Ptr = LLVMBuildBitCast(
                    this.builder, llAlloca, llAmd64PtrType, "reg$reg.coerce$i.cast".toStringz);
                llArgs ~= LLVMBuildLoad(this.builder, llAllocaAsAmd64Ptr, "reg$reg.load".toStringz);
            } else if (passByMemory(params[i], this.mod.platform)) {
                auto llParam = this.mod.translate(params[i], false);
                auto llAlloca = LLVMBuildAlloca(this.entryBuilder, llParam, "reg$reg.coerce$i".toStringz);
                LLVMBuildStore(this.builder, llReg(arg), llAlloca);
                llArgs ~= llAlloca;
            } else {
                llArgs ~= llReg(arg);
            }
        }

        mut LLVMValueRef llFun;

        target.case {
            string name:
                llFun = LLVMGetNamedFunction(this.mod.module_, name.toStringz);
                if (!llFun) {
                    print("couldn't find target named function $name");
                    assert(false);
                }
            int reg:
                llFun = llReg(reg);
        }

        mut string name = "reg$reg";
        if (sret || retType.instanceOf(BackendVoidType)) {
            name = "";
        }

        // TODO lines
        auto llLoc = LLVMDIBuilderCreateDebugLocation(
            LLVMGetModuleContext(this.mod.module_), 0, 0, this.difun, null);
        LLVMSetCurrentDebugLocation2(this.builder, llLoc);

        auto llCall = LLVMBuildCall(
            this.builder, llFun, llArgs.ptr, cast(int) llArgs.length, name.toStringz);

        if (sret) {
            auto sretAttrKind = LLVMGetEnumAttributeKindForName("sret", 4);
            assert(sretAttrKind != 0);
            auto sretTypeAttr = LLVMCreateTypeAttribute(
                this.mod.context, sretAttrKind, this.mod.translate(retType, true));
            // base-1, first parameter
            LLVMAddCallSiteAttribute(llCall, 1, sretTypeAttr);
        }

        for (int i, param in params) {
            if (passByMemory(param, this.mod.platform)) {
                auto byvalAttrKind = LLVMGetEnumAttributeKindForName("byval", 5);
                assert(byvalAttrKind != 0);
                auto byvalTypeAttr = LLVMCreateTypeAttribute(
                    this.mod.context, byvalAttrKind, this.mod.translate(param, false));
                // base-1 (0 is return type), + 1 for sret parameter
                int base = 1 + sret;
                LLVMAddCallSiteAttribute(llCall, base + cast(int) i, byvalTypeAttr);
            }
        }

        if (sret) {
            auto llLoad = LLVMBuildLoad(this.builder, llRetReg, "reg$reg.ret".toStringz);
            this.defReg2(reg, retType, llLoad);
        } else if (!retType.instanceOf(BackendVoidType)) {
            if (auto amd64Type = toAmd64ParamType(retType, this.mod.platform)) {
                auto llAmd64Type = this.mod.translate(amd64Type, false);
                auto llAlloca = LLVMBuildAlloca(this.entryBuilder, llAmd64Type, "reg$reg.ret.coerce".toStringz);
                LLVMBuildStore(this.builder, llCall, llAlloca);
                auto llRetPtrType = this.mod.translate(new BackendPointerType(retType), false);
                auto llAllocaAsRetPtr = LLVMBuildBitCast(
                    this.builder, llAlloca, llRetPtrType, "reg$reg.ret.cast".toStringz);
                auto llLoad = LLVMBuildLoad(this.builder, llAllocaAsRetPtr, "reg$reg.ret.load".toStringz);
                this.defReg2(reg, retType, llLoad);
            } else
                this.defReg2(reg, retType, llCall);
        }

        return reg;
    }

    override int call(BackendType ret, string name, int[] args) {
        if (!mod.declared(name)) { .print(name ~ " not declared"); assert(false); }
        BackendFunctionPointerType globalType() {
            if (auto type = this.mod.globalType(name).instanceOf(BackendFunctionPointerType))
                return type;
            assert(false);
        }
        auto type = globalType;
        return callImpl(type.ret, type, name, args);
    }

    override int getFuncPtr(BackendType type, string name) {
        return this.defReg(type,
            LLVMGetNamedFunction(this.mod.module_, name.toStringz));
    }

    override int callFuncPtr(BackendType type, int callReg, int[] args) {
        auto backendFpType = type.instanceOf(BackendFunctionPointerType).notNull;

        return callImpl(retType=backendFpType.ret, fpType=backendFpType, callReg, args);
    }

    override int load(BackendType backendType, int source) {
        int reg = this.nextReg;
        if (backendType.instanceOf(BackendVoidType)) {
            // fake reg
            this.defReg2(reg, backendType, null);
            return reg;
        }
        auto llType = this.mod.translate(backendType, false);
        auto llVal = LLVMBuildLoad(this.builder, llReg(source), "reg$reg".toStringz);
        this.defReg2(reg, backendType, llVal);
        return reg;
    }
    override int staticAlloca(BackendType backendType) {
        int reg = this.nextReg;
        auto llType = this.mod.translate(backendType, false);
        auto llAlloca = LLVMBuildAlloca(this.entryBuilder, llType, "reg$reg".toStringz);
        this.defReg2(reg, new BackendPointerType(backendType), llAlloca);
        if (!backendType.instanceOf(BackendVoidType)) {
            LLVMBuildStore(this.builder, LLVMConstNull(llType), llAlloca);
        }
        return reg;
    }
    override int field(BackendType backendType, int source, int index) {
        auto backendStructType = backendType.instanceOf(BackendStructType);
        assert(!!backendStructType);

        int reg = this.nextReg;
        auto llExtract = LLVMBuildExtractValue(this.builder, llReg(source), index, "reg$reg".toStringz);
        this.defReg2(reg, backendStructType.members[index], llExtract);
        return reg;
    }
    override int fieldOffset(BackendType backendType, int source, size_t index) {
        auto backendStructType = backendType.instanceOf(BackendStructType);
        assert(!!backendStructType);

        int reg1 = this.bitcast(source, new BackendPointerType(backendType));
        int reg2 = this.nextReg;
        auto int32Type = LLVMInt32TypeInContext(this.mod.context);
        auto indices = [
            LLVMConstInt(int32Type, 0, false),
            LLVMConstInt(int32Type, index, false)];
        auto elemType = backendStructType.members[index];
        auto llStructType = this.mod.translate(backendType, false);

        auto llGep = LLVMBuildGEP2(
            this.builder, llStructType, llReg(reg1), indices.ptr, cast(int) indices.length, "reg$reg2".toStringz);
        this.defReg2(reg2, new BackendPointerType(elemType), llGep);
        return reg2;
    }
    override int ptrOffset(BackendType backendType, int ptrReg, int offsetReg) {
        auto ptrType = new BackendPointerType(backendType);

        int reg1 = this.bitcast(ptrReg, ptrType);
        int reg2 = this.nextReg;
        auto int32Type = LLVMInt32TypeInContext(this.mod.context);
        auto indices = [llReg(offsetReg)];
        auto llElemType = this.mod.translate(backendType, false);

        auto llGep = LLVMBuildGEP2(
            this.builder, llElemType, llReg(reg1), indices.ptr, cast(int) indices.length, "reg$reg2".toStringz);
        this.defReg2(reg2, ptrType, llGep);
        return reg2;
    }
    override void store(BackendType backendType, int targetReg, int valueReg) {
        if (backendType.instanceOf(BackendVoidType)) return;
        LLVMBuildStore(this.builder, llReg(valueReg), llReg(targetReg));
    }
    override void ret(int reg) {
        bool sret = passByMemory(this.ret_, this.mod.platform);
        if (this.ret_.instanceOf(BackendVoidType)) {
            LLVMBuildRetVoid(this.builder);
        } else if (sret) {
            LLVMBuildStore(this.builder, llReg(reg), LLVMGetParam(this.function_, 0));
            LLVMBuildRetVoid(this.builder);
        } else {
            if (auto amd64Type = toAmd64ParamType(this.ret_, this.mod.platform)) {
                auto llAmd64Type = this.mod.translate(amd64Type, false);
                auto llAlloca = LLVMBuildAlloca(this.entryBuilder, llAmd64Type, "reg$reg.ret.coerce".toStringz);
                auto llRetPtrType = this.mod.translate(new BackendPointerType(this.ret_), false);
                auto llAllocaAsRetPtr = LLVMBuildBitCast(
                    this.builder, llAlloca, llRetPtrType, "reg$reg.ret.cast".toStringz);
                LLVMBuildStore(this.builder, llReg(reg), llAllocaAsRetPtr);
                auto llRetVal = LLVMBuildLoad(this.builder, llAlloca, "reg$reg.ret.load".toStringz);
                LLVMBuildRet(this.builder, llRetVal);
            } else
                LLVMBuildRet(this.builder, llReg(reg));
        }
        this.blockId += 1;
    }
    override void branch(string label) {
        LLVMBuildBr(this.builder, llLabel(label));
        this.blockId += 1;
    }
    override void testBranch(int reg, string thenLabel, string elseLabel) {
        int testReg = this.nextReg;
        auto lli32 = LLVMInt32TypeInContext(this.mod.context);
        auto llZero = LLVMConstNull(lli32);
        auto llIcmp = LLVMBuildICmp(this.builder, LLVMIntNE, llReg(reg), llZero, "reg$testReg".toStringz);
        LLVMBuildCondBr(this.builder, llIcmp, llLabel(thenLabel), llLabel(elseLabel));
        this.blockId += 1;
    }
    override void switch_(int reg, (int value, string label)[] targets, string defaultTarget) {
        auto lli32 = LLVMInt32TypeInContext(this.mod.context);
        auto switchInstr = LLVMBuildSwitch(
            this.builder, llReg(reg), llLabel(defaultTarget), cast(int) targets.length);
        for (target in targets) {
            LLVMAddCase(switchInstr, LLVMConstInt(lli32, target.value, false), llLabel(target.label));
        }
        this.blockId += 1;
    }
    override int phi(BackendType backendType, (string pred, int reg)[] sources) {
        auto phiType = this.mod.translate(backendType, false);
        int reg = this.nextReg;
        auto llPhi = LLVMBuildPhi(this.builder, phiType, "reg$reg".toStringz);
        for (source in sources) {
            auto sourceBlock = llLabel(source.pred);
            auto sourceReg = llReg(source.reg);
            LLVMAddIncoming(llPhi, &sourceReg, &sourceBlock, 1);
        }
        this.defReg2(reg, backendType, llPhi);
        return reg;
    }
    override void done() {
        LLVMBuildBr(this.entryBuilder, llLabel("first"));
    }
}

bool isPointer(BackendType type) {
    return type.instanceOf(BackendPointerType) || type.instanceOf(BackendFunctionPointerType);
}

private template notNull(T) {
    nonnullable T notNull(nullable T arg) {
        if (auto a = arg) return a;
        assert(false);
    }
}
